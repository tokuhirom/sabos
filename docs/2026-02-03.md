# 2026-02-03: Day 3 — ELF バイナリのロードと実行

Day 2 でユーザーモード (Ring 3) + プロセス分離まで実装した。でもユーザープログラムはカーネルバイナリに Rust 関数として埋め込まれていて、独立したバイナリではなかった。今日はいよいよ外部の ELF バイナリをカーネルにロードして Ring 3 で実行できるようにする。

## 今日のゴール

1. **ユーザープログラム crate の作成**: `x86_64-unknown-none` ターゲットで独立した ELF64 バイナリを生成
2. **ELF パーサー**: ELF64 ヘッダーとプログラムヘッダーをパースして LOAD セグメントを抽出
3. **ELF ローダー**: LOAD セグメントをプロセスのアドレス空間にマッピングしてデータをコピー
4. **シェルコマンド**: `elf` コマンドで ELF バイナリをロード・実行

## 設計判断

### ELF バイナリの配置方法

UEFI Boot Services を終了するとファイルシステムにアクセスできなくなるため、`include_bytes!` でカーネルバイナリにコンパイル時に埋め込む方式にした。将来的にファイルシステムを実装すればディスクから読み込む方式に切り替えられる。

### ターゲットの選択

ユーザープログラムは `x86_64-unknown-none` ターゲットでビルドする。これは OS を持たないベアメタル環境向けの ELF64 バイナリを出力する。カーネルの `x86_64-unknown-uefi` (PE 形式) とは別のフォーマットで、リンカスクリプトで `.text` セクションを `0x400000` (4MiB) に配置する。

### なぜ 0x400000 なのか

Linux の ELF ローダーがデフォルトで使うベースアドレスが `0x400000`。歴史的にこのアドレスが使われてきた理由は、低アドレス領域（0x0〜0x400000）をカーネルやヌルポインタガードに使えるように空けておくため。今回もこの慣習に従った。

### ABI の違い

重要な設計上のポイントとして、カーネル (`x86_64-unknown-uefi`) は **Microsoft x64 ABI** を使うのに対し、ユーザープログラム (`x86_64-unknown-none`) は **System V AMD64 ABI** を使う。システムコールのアセンブリでは System V 規約（rax=syscall番号, rdi=引数1, rsi=引数2）でレジスタをセットし、カーネル側のハンドラが Microsoft ABI の引数レジスタ（rcx, rdx, r8）に変換する。

## 実装ログ

### ユーザープログラム crate (`user/`)

`user/` ディレクトリに独立した Rust crate を作成した。`#![no_std]` + `#![no_main]` で OS なし環境向けのバイナリを生成する。

エントリポイント `_start` は `extern "C"` リンケージで、System V ABI に従う。`int 0x80` でシステムコールを呼び、SYS_WRITE (1) で "Hello from ELF binary!\n" を出力して SYS_EXIT (60) で終了する。

リンカスクリプト (`linker.ld`) で `.text` を `0x400000` に配置:

```ld
SECTIONS {
    . = 0x400000;
    .text : { *(.text .text.*) }
    .rodata : { *(.rodata .rodata.*) }
    .data : { *(.data .data.*) }
    .bss : { *(.bss .bss.*) }
}
```

`.cargo/config.toml` でデフォルトターゲットとリンカスクリプトを設定:

```toml
[build]
target = "x86_64-unknown-none"
[target.x86_64-unknown-none]
rustflags = ["-C", "link-arg=-Tlinker.ld", "-C", "relocation-model=static"]
```

ビルド結果を `objdump -d` で確認すると、`_start` が 0x400040 に配置されていて、`sys_write` と `sys_exit` のヘルパー関数がそれより前に配置されていた。

### ELF パーサー (`kernel/src/elf.rs`)

ELF64 のヘッダー構造体を `#[repr(C)]` で定義した。ELF フォーマットはバイナリ構造がシンプルで、ヘッダーの先頭 4 バイトが `\x7fELF` というマジックナンバーで始まる。

パーサーは最小限の検証だけ行う:
- マジックナンバー (`\x7fELF`)
- クラス (64-bit = ELFCLASS64)
- エンディアン (Little Endian)
- マシンタイプ (EM_X86_64 = 0x3E)

プログラムヘッダーから `PT_LOAD` (type=1) のセグメントを抽出して、仮想アドレス (vaddr)、ファイルサイズ (filesz)、メモリサイズ (memsz) を返す。BSS 領域は memsz > filesz の差分で表現される（ファイルにはデータがないがメモリ上はゼロ初期化する必要がある）。

### ELF ローダーとページマッピングの難関

ここが今日最もハマったところ。実装自体は一通り完成したのに、ELF バイナリを実行すると毎回ページフォルトが発生した。

#### 症状

`elf` コマンドを実行すると:

```
Running ELF binary in Ring 3...

Page fault in user mode!
  Accessed address: Ok(VirtAddr(0x1b))
  Error code: PageFaultErrorCode(PROTECTION_VIOLATION | CAUSED_BY_WRITE | USER_MODE)
```

アクセスアドレス 0x1b でページフォルト。0x1b は User Data セグメントセレクタの値で、明らかにおかしい。

#### デバッグ過程

まず `iretq` のスタックフレームが正しいか疑った。割り込みスタックフレームを出力したところ:

```
instruction_pointer: 0x400040   (正しい — _start のアドレス)
stack_pointer: 0x804000          (正しい — ユーザースタックトップ)
code_segment: Ring3, index 4     (正しい — User Code セレクタ)
stack_segment: Ring3, index 3    (正しい — User Data セレクタ)
```

`iretq` 自体は成功していた。RSP も 0x804000 で正しい。ではなぜ 0x1b へのアクセスが発生するのか。

次にプロセスのページテーブルを手動で辿って、0x400040 の物理アドレスを確認した:

```
page 0x400000 -> phys 0x400000
code at 0x400040: 00 00 00 00 00 00 00 00 00 00 00 00 ...
```

**コードが全部ゼロ！** 物理アドレス 0x400000 は UEFI のアイデンティティマッピングのアドレスそのものだった。ELF のコードが確保したフレーム (0x105000 等) にコピーされていたはずなのに、ページテーブルはカーネルの元のマッピング (phys=virt=0x400000) を指していた。

#### 根本原因: カーネルとのページテーブル共有

`map_user_pages_in_process()` が仮想アドレス 0x400000 の新しいフレームをマッピングしようとしたとき、L4 → L3 → L2 → L1 の中間テーブルはカーネルのアイデンティティマッピングから共有されたものだった。共有テーブルの L1 エントリを直接書き換えると、**カーネルのページテーブルも壊れてしまう**。しかも L1 エントリには既にカーネルのマッピング (phys=0x400000) があったので、「既にマッピング済み」と判定されて新しいフレームが設定されなかった。

#### 修正: 分岐コピーパターンの導入

Day 2 の `set_user_accessible_in_process()` で使った「分岐コピー」パターンを `map_user_pages_in_process()` にも導入した。カーネルと共有しているテーブルを検出して、新しいフレームにコピーしてからプロセス固有の変更を行う:

1. プロセスの L4[0] がカーネルの L3 を指している → L3 テーブルを新フレームにコピー
2. コピーした L3 の中で、L2 もカーネルと共有 → L2 テーブルもコピー
3. L2 の中の L1 もカーネルと共有 → L1 テーブルもコピー
4. コピーした L1 のエントリに新しいデータフレームを設定

これでカーネルのテーブルに影響を与えずに、プロセス固有のマッピングを作成できる。

#### もう一つのバグ: 同一ページに複数セグメント

ELF パーサーの出力を見ると:

```
[0] vaddr=0x400000 filesz=0x57 memsz=0x57
[1] vaddr=0x400057 filesz=0x45 memsz=0x45
```

2 つの LOAD セグメントが同じページ (0x400000-0x400FFF) に含まれている。`map_user_pages_in_process()` をセグメントごとに別々に呼ぶと、2回目の呼び出しで同じページに新しいフレームを割り当ててしまい、1回目にコピーしたデータが消える。

これを防ぐため、前回の呼び出しで確保済みのフレームリストを渡し、既にプロセス専用のフレームがマッピングされている場合は再利用するようにした。

#### jump_to_usermode の改善

もう一つの修正として、`jump_to_usermode` アセンブリ関数の 5 番目の引数 (`user_ss`) をスタック経由で渡す方式を廃止した。Microsoft x64 ABI では 5 番目以降の引数はスタックの `[rsp+40]` に置かれるが、コンパイラの最適化によってスタックレイアウトが変わると正しい値を読めない可能性がある。

代わりに、GDT の配置順序 (User Data → User Code) から `user_ss = user_cs - 8` が常に成り立つことを利用して、アセンブリ内で計算するようにした:

```asm
mov rax, rdx      ; rax = user_cs
sub rax, 8        ; rax = user_ss = user_cs - 8
push rax           ; SS
push r9            ; RSP
push r8            ; RFLAGS
push rdx           ; CS
push rcx           ; RIP
iretq
```

### ビルドシステム統合

Makefile に `build-user` ターゲットを追加し、`build` が `build-user` に依存するようにした。`make build` で user → kernel の順にビルドされ、`include_bytes!` が自動的に最新の ELF バイナリを埋め込む。

CI (`.github/workflows/build.yml`) にも `x86_64-unknown-none` ターゲットの追加と user crate のビルドステップを追加した。

## 最終結果

全コマンドが正常に動作:

```
sabos> usermode
Hello from Ring 3!

sabos> usertest
Page fault in user mode!
Protection test passed!

sabos> isolate
Process A: CR3 = 0x104000 ... Hello from Ring 3!
Process B: CR3 = 0x108000 ... Hello from Ring 3!
Frames reclaimed: 8

sabos> elf
Entry point: 0x400040
LOAD segments: 2
Hello from ELF binary!
Frames: before=21976, after=21976, reclaimed=0

sabos> mem
Frames: 21980 total, 4 allocated, 21976 free
```

`elf` コマンドの `reclaimed=0` は「ELF プロセスで確保したフレームが全て正しく解放されてプロセス作成前と同じ状態に戻った」ことを意味する（before == after なので差分がゼロ）。メモリリークなし。

![ELF バイナリ実行](images/elf-hello.png)

## 学んだこと

- **ページテーブルの共有は危険**: プロセスのページテーブルがカーネルと中間テーブルを共有している場合、直接エントリを変更するとカーネルのマッピングが壊れる。変更が必要な場合は必ず分岐コピーしてからプロセス固有のテーブルを操作する
- **ELF のセグメントは同じページに重なることがある**: 小さなバイナリでは .text と .rodata が同一ページに収まる。ページ単位でフレームを管理する場合、セグメントをまたぐ重複に注意が必要
- **ABI の違いは常に意識する**: UEFI カーネル (Microsoft ABI) と ELF ユーザープログラム (System V ABI) では引数レジスタの規約が異なる。アセンブリでの引数渡しはスタック経由を避け、レジスタだけで完結させるのが安全

## 次にやりたいこと

- **ファイルシステム**: FAT32 を実装して、ディスクから ELF バイナリを読み込めるようにする
- **複数ユーザープロセスの同時実行**: タスクスケジューラとユーザーモードプロセスを統合する
- **仮想アドレス空間のレイアウト**: カーネル空間を上位アドレス、ユーザー空間を下位アドレスに配置する正式なレイアウトに移行する
- **mmap / brk**: ユーザープログラムが動的にメモリを確保できるシステムコールを追加する
