# 2026-02-19: ARP キャッシュ実装 — ブロードキャスト MAC からの脱却

## 今日の目標

実機対応ロードマップの Phase 2-1「ARP キャッシュと正しい MAC 解決」を実装したい。これまで SABOS のネットワークスタックは、すべての送信パケットで宛先 MAC アドレスをブロードキャスト（FF:FF:FF:FF:FF:FF）にハードコードしていた。QEMU の SLIRP ネットワークではこれでも動くが、実ネットワークではスイッチが正しく転送してくれないため、ARP（Address Resolution Protocol）による正しい MAC 解決が必要になる。

## やったこと

### ARP とは

ARP は IP アドレスから MAC アドレスを解決するためのプロトコル。Ethernet 上で通信するには宛先の MAC アドレスが必要だが、アプリケーションが知っているのは IP アドレスだけ。ARP Request をブロードキャストで送信し、該当 IP のホストが ARP Reply でユニキャスト応答することで、IP → MAC のマッピングを得る。このマッピングをキャッシュしておくのが ARP キャッシュ（ARP テーブル）。

### ARP キャッシュの設計

`NetState` に `arp_cache: Vec<ArpEntry>` を追加した。`ArpEntry` は `{ ip: [u8; 4], mac: [u8; 6] }` のシンプルな構造体。最大 64 エントリで、溢れたら先頭（最も古いもの）を削除する LRU 風の管理にした。TTL による有効期限管理は今回は見送り。

```rust
struct ArpEntry {
    ip: [u8; 4],
    mac: [u8; 6],
}
```

操作関数は 2 つ:
- `arp_lookup(ip)` — キャッシュから MAC を検索
- `arp_update(ip, mac)` — キャッシュに追加/更新

### ARP 学習の拡張

既存の `handle_arp()` は ARP Request を受信して Reply を返すだけだった。これを拡張して:

1. **すべての ARP パケット**（Request/Reply 両方）から送信元 IP/MAC をキャッシュに学習するようにした。Gratuitous ARP（自分の IP を問い合わせる特殊な ARP）にも対応。
2. **IPv4 パケット受信時**にも、Ethernet ヘッダの送信元 MAC と IPv4 ヘッダの送信元 IP をキャッシュに学習するようにした。これにより、ICMP Echo Reply 等の応答を返す際に ARP Request なしで即座に MAC を解決できる。

### ARP Request 送信

`send_arp_request(target_ip)` を新規実装した。宛先 MAC をブロードキャスト、ターゲット MAC をゼロ（不明）にして ARP Request を送信する。

### resolve_mac — MAC アドレス解決の全フロー

`resolve_mac(dst_ip)` が今回の実装の中核。以下のフローで MAC を解決する:

1. ブロードキャスト IP (255.255.255.255) → そのままブロードキャスト MAC を返す
2. サブネット判定（10.0.2.0/24）。サブネット外ならゲートウェイ IP (10.0.2.2) の MAC を解決対象にする
3. ARP キャッシュを検索 → ヒットすれば返す
4. ミスなら ARP Request を送信し、`wait_net_condition` で応答を待つ
5. 最大 3 回リトライ、各回 1000ms タイムアウト

### net_poller デッドロック問題

ここで一つ面白い問題に遭遇した。`resolve_mac()` は `wait_net_condition()` を使って ARP Reply を待つが、この関数は net_poller タスクがパケットを処理して waiter を起床させることを前提としている。ところが `send_icmp_echo_reply()` や `send_tcp_packet_internal()` は net_poller タスク自身から呼ばれる（handle_packet → handle_ipv4 → handle_icmp → send_icmp_echo_reply の流れ）。もし net_poller 内で `resolve_mac()` を呼んで `wait_net_condition()` でスリープしたら、パケットを処理するタスクがいなくなってデッドロックする。

解決策として、関数の呼び出しコンテキストに応じて使い分けた:

| 関数 | コンテキスト | MAC 解決方法 |
|------|-------------|-------------|
| `send_udp_packet` | ユーザータスク | `resolve_mac()` でブロッキング解決 |
| `tcp_connect` | ユーザータスク | SYN 送信前に `resolve_mac()` でキャッシュを温める |
| `send_tcp_packet_internal` | net_poller / ユーザータスク | `arp_lookup()` で非ブロッキング（ミス時は BROADCAST_MAC フォールバック） |
| `send_icmp_echo_reply` | net_poller | `arp_lookup()` で非ブロッキング（handle_ipv4 で学習済み） |

`send_tcp_packet_internal` が net_poller から呼ばれるケースは、受信したパケットへの応答（SYN-ACK, ACK 等）なので、直前の `handle_ipv4` で送信元 MAC を学習済み。つまり `arp_lookup` はほぼ確実にヒットする。

### selftest

`arp_resolve` テストを追加した。`resolve_mac(&GATEWAY_IP)` でゲートウェイ（10.0.2.2）の MAC が解決できることを確認する。QEMU SLIRP は ARP に正しく応答するので、ARP Request → Reply → キャッシュ → MAC 返却の全フローがテストされる。

## テスト結果

```
=== SELFTEST END: 57/57 PASSED ===
```

新規追加の `arp_resolve` を含む全 57 テストが PASS。

## 気づき

- ARP キャッシュの実装自体はシンプルだが、**どのコンテキストから呼ばれるか**を意識する必要があった。カーネル内のネットワークスタックでは、パケット処理タスク（net_poller）と通常タスクが同じ関数を呼ぶケースがあり、ブロッキング/非ブロッキングの使い分けが重要。
- IPv4 パケット受信時にも送信元 MAC を学習するようにしたのは良い判断だった。ARP パケットだけでなく、通常のデータパケットからも MAC を学べるので、ARP キャッシュの温まりが速くなる。
- TTL 管理は今回見送ったが、実環境では ARP エントリの有効期限管理が必要になる。TODO に残してある。
