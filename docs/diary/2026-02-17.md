# 2026-02-17: ネットワークスタックのカーネル移行

## 今日の目標

ネットワークスタック（TCP/IP/UDP/DNS/ARP/IPv6/NDP/ICMPv6）をユーザー空間の netd デーモンからカーネル内に移行する。これによりIPC のオーバーヘッドを排除し、シンプルなシステムコール直接呼び出しに変更する。

## やったこと

### ネットワークスタックのカーネル移行（全8ステップ）

#### 移行前の通信フロー
```
ユーザープログラム → IPC → netd → netstack.rs → syscall(SEND_FRAME/RECV_FRAME) → virtio_net
```

#### 移行後の通信フロー
```
ユーザープログラム → syscall(TCP_CONNECT等) → kernel/netstack.rs → virtio_net
```

IPC を挟まなくなったので、ネットワーク操作が大幅にシンプルになった。

### ステップ 1: カーネル netstack モジュール作成

`user/src/netstack.rs`（約2400行）を `kernel/src/netstack.rs`（約2050行）に移植した。

主な変更点:
- **排他制御**: `UnsafeCell`（シングルスレッド前提）→ `spin::Mutex<Option<NetState>>`（カーネル用）
- **フレーム送受信**: `syscall::net_send_frame()` → `VIRTIO_NET` Mutex を直接ロック
- **ログ出力**: `syscall::write_str()` → `serial_println!()` マクロ
- **MAC アドレス**: デッドロック回避のため `MY_MAC: Mutex<[u8; 6]>` として分離

デッドロック対策が一番重要なポイント。`NET_STATE` と `VIRTIO_NET` は別の Mutex なので、`poll_and_handle_timeout()` では「VIRTIO_NET ロック → 受信 → ロック解放 → handle_packet()」の順で処理する。handle_packet() 内で ARP 応答などを送信する際に VIRTIO_NET を再ロックするので、先に解放しておかないとデッドロックする。

### ステップ 2: システムコール番号の定義

`libs/sabos-syscall/src/lib.rs` に12個のネットワーク syscall を定義:

| 番号 | 名前 | 説明 |
|------|------|------|
| 40 | SYS_NET_DNS_LOOKUP | DNS 名前解決 |
| 41 | SYS_NET_TCP_CONNECT | TCP 接続確立 |
| 42 | SYS_NET_TCP_SEND | TCP データ送信 |
| 43 | SYS_NET_TCP_RECV | TCP データ受信 |
| 44 | SYS_NET_TCP_CLOSE | TCP 接続クローズ |
| 150 | SYS_NET_TCP_LISTEN | TCP リッスン開始 |
| 151 | SYS_NET_TCP_ACCEPT | TCP 接続受け入れ |
| 152 | SYS_NET_UDP_BIND | UDP ソケットバインド |
| 153 | SYS_NET_UDP_SEND_TO | UDP データ送信 |
| 154 | SYS_NET_UDP_RECV_FROM | UDP データ受信 |
| 155 | SYS_NET_UDP_CLOSE | UDP ソケットクローズ |
| 156 | SYS_NET_PING6 | IPv6 ping |

UDP 系は引数が5つ以上になるため、`#[repr(C)]` の引数構造体（`UdpSendToArgs`, `UdpRecvFromArgs`）をスタック上に作ってポインタで渡す方式を採用した。x86_64 の syscall レジスタ規約（rdi, rsi, rdx, r10, r8, r9 の6つ）の制限を回避するテクニック。

### ステップ 3: カーネル syscall ハンドラ実装

`kernel/src/syscall.rs` に12個のハンドラ関数を追加。各ハンドラは:
1. `UserSlice` でユーザー空間ポインタを検証
2. `crate::netstack::*` の対応する関数を呼び出し
3. 結果をユーザー空間に書き戻す

### ステップ 4: ユーザー空間 syscall ラッパー追加

`user/src/syscall.rs` に12個のラッパー関数を追加。UDP 系はスタック上に引数構造体を構築してポインタを渡す。

### ステップ 5: net.rs を syscall 直接呼び出しに書き換え

`user/src/net.rs` から IPC 関連コードを全て削除:
- `netd_request()`, `init_netd()`, `find_netd()`, OPCODE_* 定数, JSON パーサー
- `TcpStream::connect()` → `syscall::net_tcp_connect()`
- `TcpStream::write()` → `syscall::net_tcp_send()`
- `TcpStream::read()` → `syscall::net_tcp_recv()`
- `Drop for TcpStream` → `syscall::net_tcp_close()`

公開 API（TcpStream, TcpListener, UdpSocket, dns_lookup, ping6）は変更なし。利用側のコードは修正不要。

### ステップ 6: 依存コードの更新

- `telnetd.rs`: `net::init_netd()` ループを削除（もう netd を待つ必要がない）
- `httpd.rs`: 同上
- `shell.rs`: `find_netd()` 関数と呼び出しを削除
- `init.rs`: SERVICES 配列から netd エントリを削除（6→5サービス）
- `selftest_net.rs`: `init_netd` テストを削除

### ステップ 7: カーネル selftest の更新

`kernel/src/shell.rs` の `test_network_netd_dns()` を `test_network_dns()` に改名。IPC 経由の複雑な DNS テスト（50行以上）が、`netstack::dns_lookup()` を直接呼ぶシンプルな5行に置き換わった。

### ステップ 8: クリーンアップ

削除したファイル:
- `user/src/bin/netd.rs` (318行) — netd デーモン本体
- `user/src/netstack.rs` (2365行) — ユーザー空間ネットワークスタック
- `user/src/syscall_netd.rs` (124行) — netd 専用 syscall ラッパー

Makefile から NETD_ELF 関連を全て削除。

## テスト結果

カーネル selftest: **50/50 全 PASS**

```
[PASS] network_dns      ← カーネル内 netstack::dns_lookup() 直接呼び出し
```

telnetd 経由のユーザーランドテストは既存の問題で失敗するが、これは今回の移行とは無関係。

## 差分サマリ

```
19 files changed, 859 insertions(+), 3667 deletions(-)
```

約2800行の純減。IPC プロトコルの定数、JSON パーサー、netd デーモン、ユーザー空間 netstack が不要になり、コードベースが大幅にスリムになった。

## 学んだこと

- **Mutex のロック順序**: カーネル内で複数の Mutex を使う場合、ロック順序を固定しないとデッドロックする。今回は「VIRTIO_NET → 解放 → NET_STATE」の順を徹底した
- **引数構造体パターン**: syscall の引数が5つを超える場合、構造体をスタック上に作ってポインタで渡すのは Linux でも使われるパターン（例: `clone3` の `struct clone_args`）
- **マイクロカーネル vs モノリシック**: netd は「ネットワークをユーザー空間に」というマイクロカーネル的アプローチだったが、IPC のオーバーヘッドと複雑さが大きかった。学習用 OS としてはカーネル内に統合した方がシンプルで理解しやすい

## 振り返り

移行は8ステップに分割して計画的に進めた。特にステップ1（カーネル netstack 作成）が最大の作業量だったが、ユーザー空間版をベースにしたため、ロジックの再実装は不要で、主にロック戦略の変更に集中できた。テストが全 PASS になったのは気持ちいい。
