# 2026-02-04: Day 4 — 「型安全 IPC」と「見える化」と「再現性」

昨日の続きで、今日は二つの気持ちが強かった。ひとつは「IPC を型で守りたい」、もうひとつは「手元だけで動く確認を CI でも再現できるようにしたい」。SABOS は学習用だから、**仕組みを理解しやすく、再現性が高い**ことが価値になる。

## 今日のゴール

1. IPC を「型で守れる」プロトタイプにする
2. システムコール一覧をドキュメント化して迷子を防ぐ
3. GUI 操作が必要だった確認を CI で再現できる形にする

## まずは IPC を「型で守る」

今の IPC は `Vec<u8>` を投げるだけで、受信側が「これは何の型？」と毎回考える必要があった。そこで **TypeId**（Rust が型ごとに持つ一意の識別子）を使って、タスクごとに「受け付ける型は 1 つだけ」を保証するキューを作った。これで型が混ざったら即エラー。結果として、**送る側・受ける側の型が一致している**ことが明確になった。

selftest にも `ipc_typed` を追加して、同じタスク間で構造体を往復できることを確認。小さいけど、型安全の土台としては良い感触だった。

## 「システムコール一覧」がない不安を消す

システムコールは OS とユーザー空間の境界仕様なので、ドキュメントが古いとすぐに迷子になる。そこで `docs/spec/syscall-list.md` を作成し、番号・引数・戻り値を一覧化した。

ここでのキーワードは **インターフェースの一貫性**。仕様が揃っていると、変更の影響範囲も追いやすい。

## GUI 依存をやめて「再現性」に寄せる

`ls` が GUI では動いているのに、手元での確認が面倒だった。これを **QEMU monitor の sendkey** で自動化し、CI で再現できるテストに組み込んだ。

「人が押せば動く」をやめて、「機械が押しても動く」に寄せる。これが **再現性**の価値だと実感した。

## 今日の大きなハマり: `ls` が動かない

テストで `ls` を叩くと `Error: FAT16 not available`。FAT16 自体はカーネル側で正常に動いているのに、ユーザー空間からは読めていない。原因を追っていくと、**SYS_BLOCK_READ/WRITE がユーザー空間の仮想アドレスを DMA に渡していた**ことが判明した。

DMA（デバイスが物理アドレスで直接メモリへ書き込む仕組み）は、**仮想アドレスでは動かない**。そこで、カーネル側に 512B のバッファを用意して、

1. デバイスはカーネルバッファへ DMA
2. カーネルがユーザー空間へコピー

という流れに変更。これで `ls` が復活して、テストも通った。

## mkdir / rmdir を足す

ここまで来たら、手元でディレクトリも触りたい。FAT16 のディレクトリは「ファイルと同じくクラスタに並ぶエントリ列」なので、`"."` と `".."` を最初に書く必要がある。root 限定に割り切って実装し、**8.3 形式**の名前だけを受け付けるようにした。

古い仕組みだけど、素直で分かりやすい。最小実装でも「作って消せる」体験ができると、OS っぽさが一気に増す。

ついでに QEMU monitor の sendkey を使って、`mkdir` / `rmdir` も自動テストに組み込んだ。手戻りが出やすい場所こそ、CI で再現できる形にしておくのが安心。

## 学んだこと

- **TypeId**: 型ごとの一意 ID。型の混在を「実行時に禁止する」ための武器になる。
- **DMA と仮想アドレス**: DMA（Direct Memory Access）は、CPU を介さずデバイスがメモリへ直接読み書きする仕組み。デバイスが理解できるのは **物理アドレス** だけなので、ユーザー空間の仮想アドレスを渡すとデータが壊れる。だからカーネル側で「物理アドレスが保証されるバッファ」を用意して、コピーで橋渡しするのが安全。
- **再現性**: 手動でしか確認できないものは CI で必ず痛む。自動化が正義。
- **8.3 形式**: FAT16 のファイル名規則。名前 8 文字 + 拡張子 3 文字に制限される古い形式で、短いが実装は単純。

今日は「型安全」「仕様の見える化」「再現性」の三本柱が進んだ日。地味だけど、あとで効いてくる土台づくりができたと思う。
