# 2026-02-04: Day 4 — 「型安全 IPC」と「見える化」と「再現性」

昨日の続きで、今日は二つの気持ちが強かった。ひとつは「IPC を型で守りたい」、もうひとつは「手元だけで動く確認を CI でも再現できるようにしたい」。SABOS は学習用だから、**仕組みを理解しやすく、再現性が高い**ことが価値になる。

## 今日のゴール

1. IPC を「型で守れる」プロトタイプにする
2. システムコール一覧をドキュメント化して迷子を防ぐ
3. GUI 操作が必要だった確認を CI で再現できる形にする

## まずは IPC を「型で守る」

今の IPC は `Vec<u8>` を投げるだけで、受信側が「これは何の型？」と毎回考える必要があった。そこで **TypeId**（Rust が型ごとに持つ一意の識別子）を使って、タスクごとに「受け付ける型は 1 つだけ」を保証するキューを作った。これで型が混ざったら即エラー。結果として、**送る側・受ける側の型が一致している**ことが明確になった。

selftest にも `ipc_typed` を追加して、同じタスク間で構造体を往復できることを確認。小さいけど、型安全の土台としては良い感触だった。

## 「システムコール一覧」がない不安を消す

システムコールは OS とユーザー空間の境界仕様なので、ドキュメントが古いとすぐに迷子になる。そこで `docs/spec/syscall-list.md` を作成し、番号・引数・戻り値を一覧化した。

ここでのキーワードは **インターフェースの一貫性**。仕様が揃っていると、変更の影響範囲も追いやすい。

## GUI 依存をやめて「再現性」に寄せる

`ls` が GUI では動いているのに、手元での確認が面倒だった。これを **QEMU monitor の sendkey** で自動化し、CI で再現できるテストに組み込んだ。

「人が押せば動く」をやめて、「機械が押しても動く」に寄せる。これが **再現性**の価値だと実感した。

## 今日の大きなハマり: `ls` が動かない

テストで `ls` を叩くと `Error: FAT16 not available`。FAT16 自体はカーネル側で正常に動いているのに、ユーザー空間からは読めていない。原因を追っていくと、**SYS_BLOCK_READ/WRITE がユーザー空間の仮想アドレスを DMA に渡していた**ことが判明した。

DMA（デバイスが物理アドレスで直接メモリへ書き込む仕組み）は、**仮想アドレスでは動かない**。そこで、カーネル側に 512B のバッファを用意して、

1. デバイスはカーネルバッファへ DMA
2. カーネルがユーザー空間へコピー

という流れに変更。これで `ls` が復活して、テストも通った。

## mkdir / rmdir を足す

ここまで来たら、手元でディレクトリも触りたい。FAT16 のディレクトリは「ファイルと同じくクラスタに並ぶエントリ列」なので、`"."` と `".."` を最初に書く必要がある。root 限定に割り切って実装し、**8.3 形式**の名前だけを受け付けるようにした。

古い仕組みだけど、素直で分かりやすい。最小実装でも「作って消せる」体験ができると、OS っぽさが一気に増す。

ついでに QEMU monitor の sendkey を使って、`mkdir` / `rmdir` も自動テストに組み込んだ。手戻りが出やすい場所こそ、CI で再現できる形にしておくのが安心。

CI では user shell 起動時に `NETD.ELF` の読み込みでメモリ確保が失敗していた。原因は **カーネルヒープが 1MiB と小さすぎた**こと。`NETD.ELF` は 1MB 近いので、少し余裕がないとすぐに枯渇する。ヒープサイズを 4MiB に拡張して、安定して起動できるようにした。

## もうひとつの CI 失敗: virtio-blk ディスクリプタのオーバーフロー

ヒープ拡張で一度は CI が通ったが、その後また失敗。今度は QEMU が `Guest says index 512 is available` というエラーを吐いていた。

原因を調べると、**virtio-blk のディスクリプタインデックス計算にバグ**があった。virtio-blk では 1 回の読み書きに 3 つのディスクリプタを使う（header, data, status）。コードでは:

```rust
let d0 = desc_base;
let d1 = desc_base + 1;  // ← ここが問題
let d2 = desc_base + 2;  // ← ここも問題
```

`queue_size` は 256 なのに、`desc_base` が 255 のとき `d1 = 256`, `d2 = 257` になって **キューサイズを超えてしまう**。NETD.ELF（977KB）のような大きなファイルを読むと、1900回以上のセクタ読み込みが発生し、ディスクリプタインデックスがぐるぐる回る。そのときにこのバグが顕在化した。

修正は簡単で、各インデックスを `% queue_size` でラップするだけ:

```rust
let d1 = (desc_base + 1) % self.queue_size;
let d2 = (desc_base + 2) % self.queue_size;
```

これで CI も通るようになった。**整数のラップアラウンドは、1 箇所だけモジュロを取っても他の箇所で漏れる**という典型的な落とし穴だった。

## 学んだこと

- **TypeId**: 型ごとの一意 ID。型の混在を「実行時に禁止する」ための武器になる。
- **DMA と仮想アドレス**: DMA（Direct Memory Access）は、CPU を介さずデバイスがメモリへ直接読み書きする仕組み。デバイスが理解できるのは **物理アドレス** だけなので、ユーザー空間の仮想アドレスを渡すとデータが壊れる。だからカーネル側で「物理アドレスが保証されるバッファ」を用意して、コピーで橋渡しするのが安全。
- **再現性**: 手動でしか確認できないものは CI で必ず痛む。自動化が正義。
- **8.3 形式**: FAT16 のファイル名規則。名前 8 文字 + 拡張子 3 文字に制限される古い形式で、短いが実装は単純。
- **virtio のディスクリプタリング**: virtio デバイスとの通信はリングバッファを使う。インデックスは `queue_size` でラップするが、チェーンで複数のディスクリプタを使う場合は **すべてのインデックスでモジュロを取る**必要がある。1 箇所だけ対応しても他で漏れる。

今日は「型安全」「仕様の見える化」「再現性」の三本柱が進んだ日。地味だけど、あとで効いてくる土台づくりができたと思う。

---

## 午後: VFS セキュア化 — Capability-based Security の導入

午前中は IPC とテストの整備だったが、午後はセキュリティの本丸に着手。SABOS の VFS を **Capability-based security** で再設計した。

### なぜ Capability-based なのか

従来の UNIX 系 OS は「ユーザー ID とパーミッションビット」で権限を管理する。でもこれは:

- ルート権限があれば何でもできてしまう
- ファイルパスを知っていれば開けてしまう
- 権限の最小化が難しい

Capability-based は発想が逆で、**「持っているトークン（ハンドル）に権限が埋め込まれている」**。トークンを持っていなければ操作できないし、トークンの権限を縮小して渡すこともできる。

SABOS はもともと「POSIX 互換を目指さない」方針なので、この機会に Capability-based に振り切ることにした。

### 実装の流れ

1. **VFS 抽象層の導入** (`vfs.rs`)
   - `FileSystem` trait と `VfsNode` trait を定義
   - FAT16、procfs を統一インターフェースで扱える

2. **パストラバーサル防止**
   - `".."` を含むパスを構造的に拒否
   - `normalize_path()` で正規化し、`validate_relative_path()` で検証
   - これで「`/../etc/passwd`」のような攻撃を防げる

3. **権限モデルの拡張** (`handle.rs`)
   - 8種類の権限ビットを定義:
     - `READ`, `WRITE`, `SEEK`, `STAT`（ファイル操作）
     - `ENUM`, `CREATE`, `DELETE`, `LOOKUP`（ディレクトリ操作）
   - `restrict_rights()` で権限を縮小（拡大は不可）

4. **openat システムコール** (`SYS_OPENAT`)
   - ディレクトリハンドルからの相対パスでファイルを開く
   - 絶対パスは禁止、`".."` も禁止
   - 新しいハンドルの権限 = 要求権限 & ディレクトリハンドルの権限

5. **procfs の独立モジュール化** (`procfs.rs`)
   - syscall.rs から procfs 関連コードを分離
   - FileSystem trait を実装（将来の VFS 統合に備える）

### エラーコードも SABOS 独自に

せっかく POSIX 互換を目指さないのだから、エラーコードも独自体系にした:

```
ポインタ・メモリ関連 (1-9)
  -1: NULL_POINTER
  -2: INVALID_ADDRESS
  -3: MISALIGNED_POINTER
  -4: BUFFER_OVERFLOW

引数・データ形式関連 (10-19)
  -10: INVALID_ARGUMENT
  -11: INVALID_UTF8

ファイル・ハンドル関連 (20-29)
  -20: FILE_NOT_FOUND
  -21: INVALID_HANDLE
  -22: READ_ONLY

権限・セキュリティ関連 (30-39)
  -30: PERMISSION_DENIED
  -31: PATH_TRAVERSAL

システム関連 (40-49)
  -40: UNKNOWN_SYSCALL
  -41: NOT_SUPPORTED
  -42: TIMEOUT
```

カテゴリごとに分類されていて、番号を見れば何の系統のエラーか分かる。POSIX の `-EFAULT` とか `-ENOENT` とか覚えなくていい。

### セキュリティ設計のポイント

**最小権限の原則**が守られている:

1. ハンドルを開くときに必要な権限だけを要求
2. 子プロセスに渡すときは `restrict_rights()` で縮小
3. 縮小されたハンドルからは元の権限に戻せない

例えば、サンドボックス内のプロセスに「読み取り専用ディレクトリハンドル」を渡せば:
- そのディレクトリ配下のファイルは読める
- でも書き込みはできない
- `".."` で親ディレクトリにも行けない
- 絶対パスでシステム全体にアクセスすることもできない

これが Capability-based の強み。権限が「トークンに埋め込まれている」から、持っていないことは絶対にできない。

### 学んだこと

- **Capability-based security**: 権限をトークン（ハンドル）に埋め込む方式。UNIX の DAC（任意アクセス制御）とは対照的で、「持っているものしか使えない」を構造で保証する。
- **パストラバーサル**: `/../` などを使ってサンドボックスを脱出する攻撃。正規化と検証を別々に行うことで、両方の観点からブロックできる。
- **restrict_rights**: Capability の核心機能。「権限は縮小のみ可能、拡大は不可」を守ることで、一度渡した権限を超えた操作を構造的に防ぐ。

午前は「型で守る IPC」、午後は「Capability で守る VFS」。両方とも **「構造で安全を保証する」** という同じ思想が流れている。動的なチェックより、静的・構造的な保証のほうが漏れがない。

今日は充実した一日だった。セキュリティは後付けだと面倒だけど、最初から設計に組み込むと美しくなる。SABOS は学習用だからこそ、「こうあるべき」を追求できる。

---

## 夕方: ユーザー空間 API のハンドル対応

午後に作ったカーネル側の Capability-based API を、ユーザー空間からも使えるようにした。

### 追加した API

`user/src/syscall.rs` に以下の API を追加:

**パスベース（レガシー）**:
- `file_read(path, buf)` — ファイルを読み取る
- `file_write(path, data)` — ファイルを書き込む
- `file_delete(path)` — ファイルを削除する
- `dir_list(path, buf)` — ディレクトリ一覧を取得

**ハンドルベース（Capability-based）**:
- `open(path, rights)` — ファイルを開いて Handle を取得
- `handle_read(handle, buf)` — ハンドルから読み取り
- `handle_write(handle, data)` — ハンドルに書き込み
- `handle_close(handle)` — ハンドルを閉じる
- `openat(dir_handle, path, rights)` — 相対パスでファイルを開く
- `restrict_rights(handle, new_rights)` — 権限を縮小

### パスベース vs ハンドルベース

```
パスベース（レガシー）:
  利便性が高い。単発のファイル操作に向く。
  毎回パスを渡すので、権限管理はカーネル任せ。

ハンドルベース（Capability-based）:
  セキュリティ重視。ハンドルに権限が埋め込まれる。
  openat() で相対パスのみ許可、restrict_rights() で権限縮小。
  サンドボックス化されたプロセスに適切な権限だけを渡せる。
```

現時点ではシェルは引き続き FAT16 ドライバ（block_read/block_write 経由）を使っているが、将来的にはハンドルベース API に移行することで、**ブロックレベルの生アクセスを廃止**してセキュリティを強化できる。

### 学んだこと

- **API の層**: カーネルに syscall があっても、ユーザー空間にラッパーがないと使いにくい。両方揃えて初めて「API が使える」状態になる。
- **レガシーとの共存**: 一気に移行するのではなく、両方の API を提供して徐々に移行するのが現実的。
- **Capability の真価**: 単にファイルを開くだけでなく、`openat()` で**サンドボックス内に閉じ込める**、`restrict_rights()` で**権限を絞る**ことができる。これがセキュリティ by Design。
