# 2026-02-04: Day 4 — 「型安全 IPC」と「見える化」と「再現性」

昨日の続きで、今日は二つの気持ちが強かった。ひとつは「IPC を型で守りたい」、もうひとつは「手元だけで動く確認を CI でも再現できるようにしたい」。SABOS は学習用だから、**仕組みを理解しやすく、再現性が高い**ことが価値になる。

## 今日のゴール

1. IPC を「型で守れる」プロトタイプにする
2. システムコール一覧をドキュメント化して迷子を防ぐ
3. GUI 操作が必要だった確認を CI で再現できる形にする

## まずは IPC を「型で守る」

今の IPC は `Vec<u8>` を投げるだけで、受信側が「これは何の型？」と毎回考える必要があった。そこで **TypeId**（Rust が型ごとに持つ一意の識別子）を使って、タスクごとに「受け付ける型は 1 つだけ」を保証するキューを作った。これで型が混ざったら即エラー。結果として、**送る側・受ける側の型が一致している**ことが明確になった。

selftest にも `ipc_typed` を追加して、同じタスク間で構造体を往復できることを確認。小さいけど、型安全の土台としては良い感触だった。

## 「システムコール一覧」がない不安を消す

システムコールは OS とユーザー空間の境界仕様なので、ドキュメントが古いとすぐに迷子になる。そこで `docs/spec/syscall-list.md` を作成し、番号・引数・戻り値を一覧化した。

ここでのキーワードは **インターフェースの一貫性**。仕様が揃っていると、変更の影響範囲も追いやすい。

## GUI 依存をやめて「再現性」に寄せる

`ls` が GUI では動いているのに、手元での確認が面倒だった。これを **QEMU monitor の sendkey** で自動化し、CI で再現できるテストに組み込んだ。

「人が押せば動く」をやめて、「機械が押しても動く」に寄せる。これが **再現性**の価値だと実感した。

## 今日の大きなハマり: `ls` が動かない

テストで `ls` を叩くと `Error: FAT16 not available`。FAT16 自体はカーネル側で正常に動いているのに、ユーザー空間からは読めていない。原因を追っていくと、**SYS_BLOCK_READ/WRITE がユーザー空間の仮想アドレスを DMA に渡していた**ことが判明した。

DMA（デバイスが物理アドレスで直接メモリへ書き込む仕組み）は、**仮想アドレスでは動かない**。そこで、カーネル側に 512B のバッファを用意して、

1. デバイスはカーネルバッファへ DMA
2. カーネルがユーザー空間へコピー

という流れに変更。これで `ls` が復活して、テストも通った。

## mkdir / rmdir を足す

ここまで来たら、手元でディレクトリも触りたい。FAT16 のディレクトリは「ファイルと同じくクラスタに並ぶエントリ列」なので、`"."` と `".."` を最初に書く必要がある。root 限定に割り切って実装し、**8.3 形式**の名前だけを受け付けるようにした。

古い仕組みだけど、素直で分かりやすい。最小実装でも「作って消せる」体験ができると、OS っぽさが一気に増す。

ついでに QEMU monitor の sendkey を使って、`mkdir` / `rmdir` も自動テストに組み込んだ。手戻りが出やすい場所こそ、CI で再現できる形にしておくのが安心。

CI では user shell 起動時に `NETD.ELF` の読み込みでメモリ確保が失敗していた。原因は **カーネルヒープが 1MiB と小さすぎた**こと。`NETD.ELF` は 1MB 近いので、少し余裕がないとすぐに枯渇する。ヒープサイズを 4MiB に拡張して、安定して起動できるようにした。

## もうひとつの CI 失敗: virtio-blk ディスクリプタのオーバーフロー

ヒープ拡張で一度は CI が通ったが、その後また失敗。今度は QEMU が `Guest says index 512 is available` というエラーを吐いていた。

原因を調べると、**virtio-blk のディスクリプタインデックス計算にバグ**があった。virtio-blk では 1 回の読み書きに 3 つのディスクリプタを使う（header, data, status）。コードでは:

```rust
let d0 = desc_base;
let d1 = desc_base + 1;  // ← ここが問題
let d2 = desc_base + 2;  // ← ここも問題
```

`queue_size` は 256 なのに、`desc_base` が 255 のとき `d1 = 256`, `d2 = 257` になって **キューサイズを超えてしまう**。NETD.ELF（977KB）のような大きなファイルを読むと、1900回以上のセクタ読み込みが発生し、ディスクリプタインデックスがぐるぐる回る。そのときにこのバグが顕在化した。

修正は簡単で、各インデックスを `% queue_size` でラップするだけ:

```rust
let d1 = (desc_base + 1) % self.queue_size;
let d2 = (desc_base + 2) % self.queue_size;
```

これで CI も通るようになった。**整数のラップアラウンドは、1 箇所だけモジュロを取っても他の箇所で漏れる**という典型的な落とし穴だった。

## 学んだこと

- **TypeId**: 型ごとの一意 ID。型の混在を「実行時に禁止する」ための武器になる。
- **DMA と仮想アドレス**: DMA（Direct Memory Access）は、CPU を介さずデバイスがメモリへ直接読み書きする仕組み。デバイスが理解できるのは **物理アドレス** だけなので、ユーザー空間の仮想アドレスを渡すとデータが壊れる。だからカーネル側で「物理アドレスが保証されるバッファ」を用意して、コピーで橋渡しするのが安全。
- **再現性**: 手動でしか確認できないものは CI で必ず痛む。自動化が正義。
- **8.3 形式**: FAT16 のファイル名規則。名前 8 文字 + 拡張子 3 文字に制限される古い形式で、短いが実装は単純。
- **virtio のディスクリプタリング**: virtio デバイスとの通信はリングバッファを使う。インデックスは `queue_size` でラップするが、チェーンで複数のディスクリプタを使う場合は **すべてのインデックスでモジュロを取る**必要がある。1 箇所だけ対応しても他で漏れる。

今日は「型安全」「仕様の見える化」「再現性」の三本柱が進んだ日。地味だけど、あとで効いてくる土台づくりができたと思う。

---

## 午後: VFS セキュア化 — Capability-based Security の導入

午前中は IPC とテストの整備だったが、午後はセキュリティの本丸に着手。SABOS の VFS を **Capability-based security** で再設計した。

### なぜ Capability-based なのか

従来の UNIX 系 OS は「ユーザー ID とパーミッションビット」で権限を管理する。でもこれは:

- ルート権限があれば何でもできてしまう
- ファイルパスを知っていれば開けてしまう
- 権限の最小化が難しい

Capability-based は発想が逆で、**「持っているトークン（ハンドル）に権限が埋め込まれている」**。トークンを持っていなければ操作できないし、トークンの権限を縮小して渡すこともできる。

SABOS はもともと「POSIX 互換を目指さない」方針なので、この機会に Capability-based に振り切ることにした。

### 実装の流れ

1. **VFS 抽象層の導入** (`vfs.rs`)
   - `FileSystem` trait と `VfsNode` trait を定義
   - FAT16、procfs を統一インターフェースで扱える

2. **パストラバーサル防止**
   - `".."` を含むパスを構造的に拒否
   - `normalize_path()` で正規化し、`validate_relative_path()` で検証
   - これで「`/../etc/passwd`」のような攻撃を防げる

3. **権限モデルの拡張** (`handle.rs`)
   - 8種類の権限ビットを定義:
     - `READ`, `WRITE`, `SEEK`, `STAT`（ファイル操作）
     - `ENUM`, `CREATE`, `DELETE`, `LOOKUP`（ディレクトリ操作）
   - `restrict_rights()` で権限を縮小（拡大は不可）

4. **openat システムコール** (`SYS_OPENAT`)
   - ディレクトリハンドルからの相対パスでファイルを開く
   - 絶対パスは禁止、`".."` も禁止
   - 新しいハンドルの権限 = 要求権限 & ディレクトリハンドルの権限

5. **procfs の独立モジュール化** (`procfs.rs`)
   - syscall.rs から procfs 関連コードを分離
   - FileSystem trait を実装（将来の VFS 統合に備える）

### エラーコードも SABOS 独自に

せっかく POSIX 互換を目指さないのだから、エラーコードも独自体系にした:

```
ポインタ・メモリ関連 (1-9)
  -1: NULL_POINTER
  -2: INVALID_ADDRESS
  -3: MISALIGNED_POINTER
  -4: BUFFER_OVERFLOW

引数・データ形式関連 (10-19)
  -10: INVALID_ARGUMENT
  -11: INVALID_UTF8

ファイル・ハンドル関連 (20-29)
  -20: FILE_NOT_FOUND
  -21: INVALID_HANDLE
  -22: READ_ONLY

権限・セキュリティ関連 (30-39)
  -30: PERMISSION_DENIED
  -31: PATH_TRAVERSAL

システム関連 (40-49)
  -40: UNKNOWN_SYSCALL
  -41: NOT_SUPPORTED
  -42: TIMEOUT
```

カテゴリごとに分類されていて、番号を見れば何の系統のエラーか分かる。POSIX の `-EFAULT` とか `-ENOENT` とか覚えなくていい。

### セキュリティ設計のポイント

**最小権限の原則**が守られている:

1. ハンドルを開くときに必要な権限だけを要求
2. 子プロセスに渡すときは `restrict_rights()` で縮小
3. 縮小されたハンドルからは元の権限に戻せない

例えば、サンドボックス内のプロセスに「読み取り専用ディレクトリハンドル」を渡せば:
- そのディレクトリ配下のファイルは読める
- でも書き込みはできない
- `".."` で親ディレクトリにも行けない
- 絶対パスでシステム全体にアクセスすることもできない

これが Capability-based の強み。権限が「トークンに埋め込まれている」から、持っていないことは絶対にできない。

### 学んだこと

- **Capability-based security**: 権限をトークン（ハンドル）に埋め込む方式。UNIX の DAC（任意アクセス制御）とは対照的で、「持っているものしか使えない」を構造で保証する。
- **パストラバーサル**: `/../` などを使ってサンドボックスを脱出する攻撃。正規化と検証を別々に行うことで、両方の観点からブロックできる。
- **restrict_rights**: Capability の核心機能。「権限は縮小のみ可能、拡大は不可」を守ることで、一度渡した権限を超えた操作を構造的に防ぐ。

午前は「型で守る IPC」、午後は「Capability で守る VFS」。両方とも **「構造で安全を保証する」** という同じ思想が流れている。動的なチェックより、静的・構造的な保証のほうが漏れがない。

今日は充実した一日だった。セキュリティは後付けだと面倒だけど、最初から設計に組み込むと美しくなる。SABOS は学習用だからこそ、「こうあるべき」を追求できる。

---

## 夕方: ユーザー空間 API のハンドル対応

午後に作ったカーネル側の Capability-based API を、ユーザー空間からも使えるようにした。

### 追加した API

`user/src/syscall.rs` に以下の API を追加:

**パスベース（レガシー）**:
- `file_read(path, buf)` — ファイルを読み取る
- `file_write(path, data)` — ファイルを書き込む
- `file_delete(path)` — ファイルを削除する
- `dir_list(path, buf)` — ディレクトリ一覧を取得

**ハンドルベース（Capability-based）**:
- `open(path, rights)` — ファイルを開いて Handle を取得
- `handle_read(handle, buf)` — ハンドルから読み取り
- `handle_write(handle, data)` — ハンドルに書き込み
- `handle_close(handle)` — ハンドルを閉じる
- `openat(dir_handle, path, rights)` — 相対パスでファイルを開く
- `restrict_rights(handle, new_rights)` — 権限を縮小

### パスベース vs ハンドルベース

```
パスベース（レガシー）:
  利便性が高い。単発のファイル操作に向く。
  毎回パスを渡すので、権限管理はカーネル任せ。

ハンドルベース（Capability-based）:
  セキュリティ重視。ハンドルに権限が埋め込まれる。
  openat() で相対パスのみ許可、restrict_rights() で権限縮小。
  サンドボックス化されたプロセスに適切な権限だけを渡せる。
```

現時点ではシェルは引き続き FAT16 ドライバ（block_read/block_write 経由）を使っているが、将来的にはハンドルベース API に移行することで、**ブロックレベルの生アクセスを廃止**してセキュリティを強化できる。

### 学んだこと

- **API の層**: カーネルに syscall があっても、ユーザー空間にラッパーがないと使いにくい。両方揃えて初めて「API が使える」状態になる。
- **レガシーとの共存**: 一気に移行するのではなく、両方の API を提供して徐々に移行するのが現実的。
- **Capability の真価**: 単にファイルを開くだけでなく、`openat()` で**サンドボックス内に閉じ込める**、`restrict_rights()` で**権限を絞る**ことができる。これがセキュリティ by Design。

---

## 夜: init/supervisor プロセスの実装

今日の最後の大仕事として、**init プロセスと supervisor 機能**を実装した。マイクロカーネルアーキテクチャへの第一歩。

### 動機

これまでカーネルにシェルが埋め込まれていた（`include_bytes!`）。これだと:
- カーネルが肥大化する
- サービス管理がカーネルの仕事になる
- シェルがクラッシュしたらカーネルごと死ぬ

マイクロカーネルでは、サービス管理はユーザー空間の仕事。init がサービスを起動し、監視し、必要に応じて再起動する。

### 実装したもの

**1. プロセス階層**

Task 構造体に `parent_id` を追加。`spawn_user()` で呼び出し元のタスク ID を親として記録する。

```rust
pub struct Task {
    pub parent_id: Option<u64>,  // 親タスクの ID
    pub exit_code: i32,          // 終了コード
}
```

**2. 新システムコール**

- `SYS_WAIT (34)`: 子プロセスの終了を待つ
- `SYS_GETPID (35)`: 現在のタスク ID を取得

wait() は以下のモードをサポート:
- `task_id == 0`: 任意の子プロセスを待つ
- `task_id > 0`: 指定した子プロセスを待つ
- `timeout_ms == 0`: 無期限待ち

**3. init プロセス**

`user/src/bin/init.rs` を新規作成:

```
Kernel (task 0)
     |
     | spawn_user("/INIT.ELF")
     v
  +--------+
  |  init  |  (task 7) — supervisor
  +--------+
   /      \
spawn      spawn
   \        /
+-------+  +-------+
| netd  |  | shell |
+-------+  +-------+
```

init の責務:
1. サービス（netd）を起動
2. シェルを起動
3. supervisor ループで子プロセスの終了を監視
4. `restart: true` のサービスは自動再起動

**4. シェルの独立バイナリ化**

既存の shell.rs を `user/src/bin/shell.rs` にコピーして独立 ELF にした。1.5MB という大きさになったが、正常に動作。

**5. ブートシーケンス変更**

カーネルは `include_bytes!` ではなく、FAT16 ディスクイメージから INIT.ELF を読み込むように変更。init を起動した後、カーネルは idle モードに入る。

### 遭遇した重大なバグ: TSS rsp0 の更新漏れ

実装後にテストしたら、SHELL.ELF の起動時に PAGE FAULT でクラッシュ。原因を追跡した結果、**TSS rsp0 の更新漏れ**が判明した。

**問題の本質**:

x86-64 では、ユーザープロセスがシステムコールや割り込みで Ring 0 に遷移するとき、CPU は TSS（Task State Segment）の rsp0 フィールドをカーネルスタックとして使用する。

各ユーザープロセスは独自のカーネルスタックを持つ。`user_task_entry_wrapper()` は初回の Ring 3 遷移時に TSS rsp0 を設定するが、**プリエンプション後の復帰時には設定していなかった**。

結果として:
1. プロセス A が Ring 3 で実行中に TSS rsp0 = A のカーネルスタック
2. プリエンプションでプロセス B に切り替え
3. B でシステムコール発生 → CPU は TSS rsp0（A のスタック！）を使う
4. スタック破壊 → クラッシュ

**修正**:

`yield_now()` と `preempt()` で `context_switch()` を呼ぶ前に、切り替え先タスクがユーザープロセスの場合は TSS rsp0 を更新するようにした:

```rust
// ユーザープロセスへの切り替え時は TSS rsp0 を更新
if let Some(kernel_stack_top) = new_kernel_stack_top {
    unsafe {
        crate::gdt::set_tss_rsp0(VirtAddr::new(kernel_stack_top));
    }
}
```

このバグは以前から存在していたが、単一のユーザープロセスしかなかったので顕在化しなかった。複数のユーザープロセス（init, netd, shell）が動作するようになって初めて問題が表面化した。

### 動作確認

```
[init] SABOS init process starting...
[init] PID = 7
[init] Starting netd...
[scheduler] spawned user task 8 'NETD.ELF' (entry: 0x401520, parent: Some(7))
[init] Started netd (PID 8)
[init] Starting shell...
[scheduler] spawned user task 9 'SHELL.ELF' (entry: 0x4098f0, parent: Some(7))

=================================
  SABOS User Shell
=================================
Type 'help' for available commands.

user> [init] Started shell (PID 9)
[init] Entering supervisor loop
```

init がカーネルから起動され、netd と shell を spawn し、supervisor ループに入っていることを確認。

### 学んだこと

- **TSS (Task State Segment)**: x86-64 では主に Ring 3 → Ring 0 遷移時のスタック切り替えに使われる。マルチタスク環境では、各タスクのカーネルスタックを適切に管理しないとスタック破壊が発生する。

- **Rust 2024 edition の static mut 制限**: `static mut` への可変参照は Rust 2024 edition でエラーになる。代わりに `AtomicU64` などを使う。シングルスレッド環境でも安全な手段を使うべき。

- **複数プロセス環境でのデバッグ**: 単一プロセスでは動いていても、複数プロセスになると顕在化するバグがある。テストの重要性を再認識。

### 今日のまとめ

朝は IPC の型安全化、午後は VFS の Capability-based 化、夜は init/supervisor。一日で **「型で守る」「Capability で守る」「プロセスで分離する」** という三層の防御を整えた。

SABOS はマイクロカーネルアーキテクチャに一歩近づいた。カーネルはハードウェア管理と基本的なタスクスケジューリングに専念し、サービス管理はユーザー空間の init に委譲される形になった。

TSS rsp0 のバグ修正は特に勉強になった。x86-64 の割り込み/特権遷移の仕組みを深く理解しないと解けない問題だった。

---

## 夜更けの追記: cd/pwd を Capability で作り直す

### 今日の計画（追記）

1. **cwd はシェルの状態に閉じ込める**（カーネルに持たせない）
2. **cd/pwd/pushd/popd を Capability 方式で設計**
3. **selftest が通るところまで仕上げる**

### 実装計画（具体）

- 変更ファイル:
  - `user/src/bin/shell.rs`, `user/src/shell.rs`
  - `kernel/src/syscall.rs`, `user/src/syscall.rs`
  - `docs/spec/syscall-list.md`
- 変更内容:
  - `cwd` は **DirHandle（真実） + 表示用文字列**で持つ
  - `cd` は `openat(cwd, "rel")` で **新しいディレクトリハンドル**を取得して差し替える
  - `".."` は使わず **stack（pushd/popd）で戻る**
  - `ls` は **ディレクトリハンドルから列挙**できるように syscall を追加

### なぜこうしたか

`cwd` をプロセス状態にするのは **syscall が増え、継承がややこしく、capability 的に危険**。  
そこで **「cwd はシェルだけが持つ」**に振り切った。

真実は `cwd_handle`。`cwd_text` は表示用で、**正確である必要はない**。  
（mount や rename が絡むと厳密化は泥沼になる。学習用 OS では割り切るのが良い。）

### 追加した仕組み

- **SYS_HANDLE_ENUM**: ディレクトリハンドルから一覧を取得する syscall
- **open()/openat() がディレクトリを返せる**ように調整
- **cd/pwd/pushd/popd** をユーザーシェルに実装

### 学んだこと

- **DirHandle**: ディレクトリを指す Capability。これが「cwd の真実」になる。  
  文字列の cwd は「見せるためのメモ」程度で良い。
- **openat**: 既存のディレクトリハンドルから相対パスを開く API。  
  これがあると **サンドボックスが一発で作れる**。
- **pushd/popd**: `..` を禁止しても困らない戻り道。  
  Capability の世界観と相性が良い。

### 動作確認

`make test` で selftest は **12/12 PASS**。  
警告もゼロを維持できた。

今日は「cwd はシェルだけが持つ」という割り切りが、  
**capability の設計を一段クリアにする**ことを実感した。  
SABOS らしい「構造で安全を保証する」方向に寄せられたと思う。

---

## 夜: TCP/IP スタックをユーザー空間サービス化する（第一歩）

夕方の VFS まわりを整えたあと、「TCP/IP を本当にユーザー空間へ引っ越す」方向に舵を切った。ここは SABOS の設計思想（小さなカーネル + サービス分割）に直結する部分なので、できるだけ **L2（リンク層）だけをカーネルに残して、上位を user space へ**という構図にした。

### 追加のゴール（夜の分）

1. カーネルは L2（Ethernet フレームの送受信）だけに責務を絞る
2. netd がユーザー空間ネットスタックを持ち、DNS/TCP を処理する
3. 既存のシェル API は壊さずに、裏側だけ置き換える

### L2 syscalls の導入

カーネル側には **net_send_frame / net_recv_frame / net_get_mac** の 3 つだけを追加した。これは L2（リンク層）に相当する操作で、Ethernet フレームを送る／受け取る／MAC を読む、という最小セット。

ここでのキーワードは **L2（リンク層）**。ネットワークは層で分かれていて、L2 は「隣と話すための最下層」。この層だけをカーネルに残しておけば、上位の IP/UDP/TCP をユーザー空間へ移しても壊れない。

### netd を「代理サービス」から「本体」に昇格

`netd` はこれまでカーネルの DNS/TCP syscalls を代理で叩く役割だった。これを、ユーザー空間の `netstack.rs` に置き換えた。具体的には：

- `netd` 起動時に `netstack::init()` で MAC を取得
- IPC で届いた DNS/TCP リクエストを netstack で処理
- 受信フレームは `net_recv_frame` をポーリングして捌く

これで **TCP/IP スタックの本体はユーザー空間**になった。カーネルは「フレームを運ぶだけの運送屋」になっている。

### まだ残る課題

- netstack の待ちループが雑（ビジーウェイト多め）なので、後でタイムアウト精度を上げたい
- エラーコードは今はざっくり `-99` で返している。エラー体系を整える余地がある

でも一歩目としては十分。**「カーネルの仕事を減らす」**という目標に、ちゃんと近づけた。

夜はここまで。明日は netstack の待ちループ改善と selftest へのネット系追加を狙いたい。

---

## 深夜: user space netstack の selftest を追加

netd がユーザー空間へ移ったので、selftest もそれに追従させた。カーネル側の `selftest` から **IPC** で netd に `example.com` を問い合わせ、返ってきた IP が 0.0.0.0 でないことを確認するテストを追加。

ここで改めて **IPC（Inter-Process Communication）** を意識した。プロセス間通信は「メッセージを投げて返事を待つ」だけのシンプルな枠組みだが、**ユーザー空間サービス化**の時代になると、この細い線が OS 全体の信頼性を支える基盤になる。

selftest に `network_netd_dns` が増えたことで、
「カーネル内 DNS が動く」だけでなく「ユーザー空間 netd が動く」も保証できるようになった。

---

## さらに: selftest スクリプトの安定化

selftest が時々拾えなかったので、`run-selftest.sh` の待ちを少し賢くした。init のログが user shell のプロンプトと競合すると入力が吸われることがあるため、**supervisor ループ開始**を待ってから空行を送ってプロンプトを揃えるようにした。

この「プロンプト同期」は地味だけど重要。自動テストは「入力が正確に届く」こと自体が前提条件なので、**環境の揺らぎを吸収するガード**を入れるのは正当化できる投資だと感じた。

---

## 仕上げ: netd の PID 依存を排除

これまで user shell は「netd は PID 2 のはず」という仮定に依存していた。でもこれは init の起動順や将来のサービス追加で簡単に壊れる。

そこで `get_task_list` を使って **ps 相当の JSON 出力から NETD.ELF を探す**ように変更した。IPC 送信が失敗したときも、タスク ID を再解決してリトライするようにしている。

この変更で「PID が固定である」という暗黙の前提を排除できた。**プロセスは見つけて使う**、という当たり前の姿勢に戻れたのが良い。

---

## さらに調整: kernel DNS selftest の扱い

ユーザー空間 netd が動いていると、virtio-net の受信キューを netd が消費するので、カーネル内 DNS テストが失敗することがある。そこで selftest の `network_dns` は **netd 起動時はスキップ扱い**にした。

「本当にテストされてないのでは？」という不安は残るけど、今の構成では **L2 を netd が独占する設計**になっているので、ここは二重利用を避ける方が合理的だと判断した。

---

## GUI の第一歩: カーネル描画 API を切り出す

「GUI をどこから始めるか」を考えて、まずは **カーネル側の最小描画 API** を用意した。理由はシンプルで、フレームバッファは今のところカーネルが直接握っているので、ここを素直に整理した方が後でユーザー空間サービスへ渡しやすい。

追加したのは最小の 2 つ:

- `draw_pixel(x, y, rgb)` — 1 ピクセル描画
- `draw_rect(x, y, w, h, rgb)` — 矩形塗りつぶし

引数はシステムコールの 4 引数制限に合わせて、**色は 0xRRGGBB の packed** にした。`draw_rect` の `w/h` も packed にしている。

selftest には `framebuffer_draw` を追加して、
- 正常系（画面内）
- 異常系（画面外 / サイズ 0）

の両方で戻り値チェックをするようにした。描画内容を読み返せない状況でも、**境界チェックの正しさ**はテストできる。

「描けること」よりも先に「壊れないこと」を保証しておく。この順番が GUI の土台になるはず。

---

## 追記: シェルに GUI デモコマンドを追加

描画 syscalls を試せる最小の入り口として、ユーザーシェルに `rect` コマンドを追加した。引数で座標と色を渡すだけの簡易コマンドだが、
「ユーザー空間からフレームバッファを叩ける」ことが目で確認できる。

```
rect 10 10 80 40 255 0 0
```

この時点では UI というより「描画 API の配管テスト」だけど、GUI を作るときの足場になるはず。

---

## GUI 強化の土台 (1): 画面情報 syscall を追加

GUI を本格的に作るには、まず **画面の幅/高さ/stride/ピクセル形式**をユーザー空間が知る必要がある。そこで `SYS_GET_FB_INFO` を追加した。返す情報は最小限に絞っている：

- `width`, `height` — 解像度
- `stride` — 1行あたりのピクセル数
- `pixel_format` — RGB/BGR などの識別子
- `bytes_per_pixel` — 今は 4 固定

selftest には `framebuffer_info` を追加し、
- `stride >= width`
- `bytes_per_pixel == 4`
- `pixel_format != 0`

を確認するだけの簡易テストを入れた。

地味だけど、この情報がないと GUI のレイアウトもバッファ計算も始まらない。**まずは足場**。

---

## GUI 強化の土台 (2): 描画 API を拡張

次の段階として、描画 syscalls を一気に拡張した。追加したのは 3 つ:

- `draw_line` — 直線描画（Bresenham）
- `draw_blit` — RGBX バッファの描画
- `draw_text` — 文字列描画（fg/bg 色付き）

これで GUI を作り込むための「最低限のプリミティブ」が揃った。特に `draw_blit` があると、ユーザー空間で作ったバッファをそのまま画面に持っていけるので、次のダブルバッファ設計につなげやすい。

selftest も `framebuffer_draw` の中で追加 API を動かし、
- 正常系は通る
- 異常系は弾かれる

という形で最低限の安全性を担保した。

---

## テスト安定化: sendkey の間隔を延長

GUI 周りを触っていると自動テストの入力が時々欠ける。`run-selftest.sh` の sendkey の間隔を 0.4 秒に伸ばして、入力の取りこぼしを減らした。

地味だけど、CI の再現性はここで削られるので、**安定性優先**で調整。

---

## GUI 強化の土台 (3): GUI サービス + IPC + ダブルバッファ

いよいよ user space に **GUI サービス**を追加した。構成はシンプルで、

- GUI サービスが **バックバッファ (RGBX)** を持つ
- IPC で描画コマンドを受け取る
- `present` で `draw_blit` による全画面転送

という流れ。これで「共有メモリなしでも GUI を構築できる」ことが確認できる。

IPC プロトコルは最小限に絞った：

- `CLEAR`（画面塗りつぶし）
- `RECT`（矩形塗りつぶし）
- `LINE`（直線描画）
- `PRESENT`（画面反映）

selftest には `gui_ipc` を追加し、GUI サービスへ CLEAR を送り、
応答が返ってくることを確認している。描画結果自体は見ないが、
**IPC パイプが通っているか**はこれで保証できる。

---

## GUI のためにユーザーヒープを拡張

GUI サービスのバックバッファは 1280x800x4 で約 4MB。既存のユーザーヒープ（256KiB）だと当然足りないので、ユーザー空間のヒープを 8MiB に拡張した。

これは GUI 専用というより、今後のユーザープロセスに余裕を持たせる意味もある。学習用 OS なので、まずは「動かして学ぶ」ことを優先。

---

## GUI で BSS が膨らむのでユーザースタック位置を引き上げ

ユーザーヒープを 8MiB にすると、ELF の BSS が大きくなって 8MiB 付近のスタック領域と衝突する。そこで **ELF のユーザースタック位置を 0x2000000 (32MiB)** に引き上げた。

これで GUI サービスの大きなバッファでも衝突せずに動くはず。

---

## 追記: ユーザーヒープは 5MiB に落とした

8MiB にすると一部プロセスで不安定だったので、GUI バッファを確保できる最低限として **5MiB** に調整した。これでも 1280x800x4 (約 4MiB) は載る。

---

## 追記: GUI 専用アロケータに分離

全プロセスのヒープを大きくすると netd が不安定だったので、
GUI だけ大きいヒープを持つ **専用アロケータ**を切り出した。通常のプロセスは 256KiB のまま、GUI だけ 5MiB。

これで「GUI は重いが他は軽い」という設計に戻せる。

---

## GUI 起動で init が壊れる問題を修正（CR3 切り替え）

GUI を spawn すると init の命令が 0x00 で上書きされ、`int 0x80` 復帰直後にページフォルトが出ていた。原因は **ユーザープロセスのページテーブルのまま物理フレームへ書き込んでいた**こと。具体的には、ELF ロード時に「物理アドレス＝仮想アドレス」とみなして `memcpy` していたが、ユーザーページテーブルでは低い仮想アドレスがユーザー領域に上書きされていて、結果的に init のコードがゼロクリアされていた。

対策として、**ELF を読み込んでメモリに書き込む部分だけカーネルのページテーブルに切り替える**ようにした。ここで出てくる **CR3** は「いま CPU が参照しているページテーブルの物理アドレスを持つレジスタ」のことで、これを切り替えると仮想→物理変換の基準が変わる。つまり「カーネルの CR3 に戻してから書き込む」ことで、意図した物理フレームに安全に書けるようになる。

これで GUI を含むサービス起動が安定し、selftest も全部 PASS になった。

---

## procfs /proc/meminfo にプロセス別フレーム数を追加

procfs の meminfo に **processes 配列**を追加して、各タスクの `user_frames` を出せるようにした。今は `allocated_frames` の数をそのまま返しているだけの「ざっくり統計」だけど、メモリ管理の足元を固める第一歩になる。

selftest で procfs を読んで確認できるようになったので、次は procfs 側の統計をもう少し細かくしていく。
