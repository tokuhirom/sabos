# 2026-02-06: Day 6 — 意気込み

## 今日の意気込み

昨日は GUI アプリ（電卓・テトリス・PAD）、FAT32 完全実装、telnetd 複数接続、httpd、簡易エディタ、sed + パイプと盛りだくさんだった。今日は「昨日作った土台をもっと使いやすく・堅くする」方向に進めたい。

今日一日、こんなことが出来たらいいな:

1. **grep コマンドの追加** — sed + パイプがあるのに grep がないのは寂しい。`cat FILE | grep PATTERN` や `grep PATTERN FILE` が使えると、ファイル操作の幅がぐっと広がる
2. **httpd のディレクトリリスティング** — `GET /` でルート直下のファイル一覧を返せると、ブラウザから SABOS のファイルシステムが見える。自作 OS がブラウザから見えるのは楽しいはず
3. **プロセス管理の改善（kill コマンド）** — spawn したプロセスを止める手段がまだない。`kill <pid>` でタスクを終了させられるようにする
4. **W^X（Write XOR Execute）の実装** — セキュリティ強化の第一歩。メモリページを「書き込み可能」か「実行可能」のどちらか一方だけにする

## 今日の計画

### タスク 1: grep コマンド追加

sed のときに作った `sabos-textutil` クレートを活用して、リテラル検索の grep を実装する。

- 変更ファイル:
  - `user/src/bin/shell.rs`: grep コマンドの追加
  - `libs/sabos-textutil/src/lib.rs`: 行内マッチ関数の追加（必要なら）
  - `kernel/src/shell.rs`: selftest に grep のテスト追加
- 機能:
  - `grep PATTERN FILE` — ファイルからパターンを含む行を出力
  - `grep -i PATTERN FILE` — 大文字小文字を無視
  - `grep -v PATTERN FILE` — マッチしない行を出力
  - `grep -c PATTERN FILE` — マッチした行数を出力
  - パイプ対応: `cat FILE | grep PATTERN`

### タスク 2: httpd のディレクトリリスティング

GET リクエストのパスがディレクトリだった場合に、HTML でファイル一覧を返す。

- 変更ファイル:
  - `user/src/bin/httpd.rs`: ディレクトリ判定とHTML生成
- 機能:
  - `GET /` でルートディレクトリのファイル一覧を HTML で返す
  - `GET /SUBDIR/` でサブディレクトリの一覧を返す
  - 各ファイルにリンクを付けて、クリックでダウンロードできる

### 完了: タスク 1 — grep コマンド追加

`sabos-textutil` に `contains_literal()` を追加し、ユーザーシェルに `grep [-i] [-v] [-c] PATTERN [FILE]` を実装した。パイプにも対応。selftest に `textutil_contains` を追加して **27/27 PASS**。

### 完了: タスク 2 — httpd のディレクトリリスティング

`GET /` でルートディレクトリの HTML ファイル一覧を返すようにした。各エントリはクリック可能なリンク付き。selftest に `httpd_dirlist` を追加。

### 追加: ループバック対応 + http ポート指定

netstack にソフトウェアループバックを実装した。ローカル宛（MY_IP / 127.0.0.1）の TCP パケットをネットワークに出さず内部で折り返す方式。ここでいう **ソフトウェアループバック** は「パケットを NIC に送らずに、送信関数の中で直接受信ハンドラに渡す」こと。

http コマンドに `host:port` 形式と `localhost` 対応を追加し、`http localhost:8080 /` で自身の httpd にアクセスできるようにした。

### TODO（後日）: nc コマンド

TCP の raw な送受信ができる nc (netcat) コマンドがあるとデバッグに便利。ループバック対応したので内部テストにも使える。

### 完了: タスク 3 — kill コマンド + SYS_KILL

`kernel/src/scheduler.rs` に `kill_task()` を追加し、SYS_KILL（番号 36）として公開。ユーザーシェルで `kill <pid>` が使えるようになった。自分自身の kill はエラーにしている。selftest に `kill_self_reject` を追加。**28/28 PASS**。

### 完了: タスク 4 — W^X（Write XOR Execute）

x86_64 の NX ビット（No-Execute: ページテーブルエントリの 63 ビット目）を活用して、ユーザー空間に W^X を適用した。

- `.text`（実行コード）→ 実行可・書き込み不可
- `.rodata`（読み取り専用データ）→ 実行不可・書き込み不可
- `.data` / `.got` / `.bss` / スタック → 書き込み可・実行不可

実装のポイントは `elf_flags_to_page_flags()` で ELF セグメントの PF_X/PF_W フラグを x86_64 ページテーブルフラグに変換すること。中間テーブル（L4/L3/L2）は「通過する」だけなので常に WRITABLE + USER_ACCESSIBLE にし、リーフ（L1）エントリにだけ W^X 制限を適用する。

一つ厄介だったのが **ページ共有問題**。リンカが `.rodata`（R のみ）と `.data`（RW）を同一 4KiB ページ内に配置することがある。最初に R のみでマッピングしたページを後のセグメントが再利用するとき、WRITABLE が付かず書き込み保護違反（ページフォルト）になった。`merge_page_flags()` を作って、同一ページに複数セグメントがまたがる場合は権限の和集合（union）を取るようにして解決。

### 完了: タスク 5 — GUI タスクバーとキーボードフォーカス機構

GUI サービスにタスクバーを追加した。画面最上部に常時表示され、キーボードで ELF パスを入力して spawn したり、`:shutdown` でシステム停止したり、`:exit` で dormant モードに戻ったりできる。

#### キーボードフォーカス機構

これが今回の肝。今まで全ユーザープロセスが単一の `INPUT_BUFFER` を共有していたので、GUI がキーボードを読むとシェルと競合してしまう問題があった。**キーボードフォーカス**という仕組みをカーネルに追加して解決した。

- `KEYBOARD_FOCUS_TASK: AtomicU64` — フォーカスを持つタスク ID（0 = フォーカスなし）
- フォーカスが設定されている間は、そのタスクだけが入力バッファから文字を読み取れる
- フォーカス外のタスクが `SYS_READ` を呼ぶとブロッキングで待機し続ける（`SYS_KEY_READ` なら 0 を返す）
- タスク終了時（正常終了、kill、例外）にフォーカスが自動解放される

新しいシステムコールを 2 つ追加:
- `SYS_KEY_READ(3)`: ノンブロッキングでキーを読む（`SYS_MOUSE_READ` と同じパターン）
- `SYS_CONSOLE_GRAB(4)`: キーボードフォーカスの取得 (1) / 解放 (0)

#### dormant モードの工夫

最初は GUI 起動時にすぐキーボードフォーカスを取る設計だったが、自動テスト（QEMU の `sendkey` でシェルにコマンドを送る）がフォーカスの影響でシェルにキーが届かず失敗した。そこで GUI は **dormant モード**（IPC サービスとしてのみ動作）で起動し、ウィンドウ作成 IPC（`OPCODE_WINDOW_CREATE`）を受信したときに初めてアクティブ化してフォーカスを取得するように変更した。

さらに、dormant モードでも全 IPC オペコードを処理する必要があることが分かった（`gui_ipc` テストが `OPCODE_CLEAR` を送るため）。最初は dormant 用の別処理関数を作っていたが、結局メインループの IPC 処理を dormant/active 共通にして、キーボードとマウスの処理だけを `if taskbar.active { ... }` で囲む設計に落ち着いた。

#### 変更ファイル

| ファイル | 変更内容 |
|---------|---------|
| `kernel/src/console.rs` | フォーカス機構 + フォーカス対応 read 関数 |
| `kernel/src/syscall.rs` | SYS_KEY_READ(3), SYS_CONSOLE_GRAB(4), sys_read 修正 |
| `kernel/src/scheduler.rs` | タスク終了時のフォーカス自動解放（4 箇所） |
| `user/src/syscall.rs` | key_read(), console_grab() ラッパー |
| `user/src/bin/gui.rs` | Taskbar 構造体、描画、キーボード処理、dormant モード |
| `docs/spec/syscall-list.md` | 新システムコールの記載 |

## 今日のまとめ

今日は計画した 4 タスク + タスクバー実装をすべて完了できた。grep・httpd ディレクトリリスティング・kill コマンド・W^X と、堅さと使い勝手の両方を進められた。ループバック対応はおまけで付いてきた嬉しい成果。W^X のページ共有問題は ELF のメモリレイアウトを理解する良い勉強になった。

タスクバーの実装は思ったより奥が深かった。キーボード入力の排他制御という一見シンプルな問題が、テスト環境との両立やIPC処理の設計まで波及する。dormant/active の切り替えを OPCODE_WINDOW_CREATE にトリガーさせる設計は、テスト互換性と使い勝手のバランスが良い落とし所になったと思う。
