# 2026-02-06: Day 6 — 意気込み

## 今日の意気込み

昨日は GUI アプリ（電卓・テトリス・PAD）、FAT32 完全実装、telnetd 複数接続、httpd、簡易エディタ、sed + パイプと盛りだくさんだった。今日は「昨日作った土台をもっと使いやすく・堅くする」方向に進めたい。

今日一日、こんなことが出来たらいいな:

1. **grep コマンドの追加** — sed + パイプがあるのに grep がないのは寂しい。`cat FILE | grep PATTERN` や `grep PATTERN FILE` が使えると、ファイル操作の幅がぐっと広がる
2. **httpd のディレクトリリスティング** — `GET /` でルート直下のファイル一覧を返せると、ブラウザから SABOS のファイルシステムが見える。自作 OS がブラウザから見えるのは楽しいはず
3. **プロセス管理の改善（kill コマンド）** — spawn したプロセスを止める手段がまだない。`kill <pid>` でタスクを終了させられるようにする
4. **W^X（Write XOR Execute）の実装** — セキュリティ強化の第一歩。メモリページを「書き込み可能」か「実行可能」のどちらか一方だけにする

## 今日の計画

### タスク 1: grep コマンド追加

sed のときに作った `sabos-textutil` クレートを活用して、リテラル検索の grep を実装する。

- 変更ファイル:
  - `user/src/bin/shell.rs`: grep コマンドの追加
  - `libs/sabos-textutil/src/lib.rs`: 行内マッチ関数の追加（必要なら）
  - `kernel/src/shell.rs`: selftest に grep のテスト追加
- 機能:
  - `grep PATTERN FILE` — ファイルからパターンを含む行を出力
  - `grep -i PATTERN FILE` — 大文字小文字を無視
  - `grep -v PATTERN FILE` — マッチしない行を出力
  - `grep -c PATTERN FILE` — マッチした行数を出力
  - パイプ対応: `cat FILE | grep PATTERN`

### タスク 2: httpd のディレクトリリスティング

GET リクエストのパスがディレクトリだった場合に、HTML でファイル一覧を返す。

- 変更ファイル:
  - `user/src/bin/httpd.rs`: ディレクトリ判定とHTML生成
- 機能:
  - `GET /` でルートディレクトリのファイル一覧を HTML で返す
  - `GET /SUBDIR/` でサブディレクトリの一覧を返す
  - 各ファイルにリンクを付けて、クリックでダウンロードできる

### 完了: タスク 1 — grep コマンド追加

`sabos-textutil` に `contains_literal()` を追加し、ユーザーシェルに `grep [-i] [-v] [-c] PATTERN [FILE]` を実装した。パイプにも対応。selftest に `textutil_contains` を追加して **27/27 PASS**。

### 完了: タスク 2 — httpd のディレクトリリスティング

`GET /` でルートディレクトリの HTML ファイル一覧を返すようにした。各エントリはクリック可能なリンク付き。selftest に `httpd_dirlist` を追加。

### 追加: ループバック対応 + http ポート指定

netstack にソフトウェアループバックを実装した。ローカル宛（MY_IP / 127.0.0.1）の TCP パケットをネットワークに出さず内部で折り返す方式。ここでいう **ソフトウェアループバック** は「パケットを NIC に送らずに、送信関数の中で直接受信ハンドラに渡す」こと。

http コマンドに `host:port` 形式と `localhost` 対応を追加し、`http localhost:8080 /` で自身の httpd にアクセスできるようにした。

### TODO（後日）: nc コマンド

TCP の raw な送受信ができる nc (netcat) コマンドがあるとデバッグに便利。ループバック対応したので内部テストにも使える。

### 完了: タスク 3 — kill コマンド + SYS_KILL

`kernel/src/scheduler.rs` に `kill_task()` を追加し、SYS_KILL（番号 36）として公開。ユーザーシェルで `kill <pid>` が使えるようになった。自分自身の kill はエラーにしている。selftest に `kill_self_reject` を追加。**28/28 PASS**。

### 完了: タスク 4 — W^X（Write XOR Execute）

x86_64 の NX ビット（No-Execute: ページテーブルエントリの 63 ビット目）を活用して、ユーザー空間に W^X を適用した。

- `.text`（実行コード）→ 実行可・書き込み不可
- `.rodata`（読み取り専用データ）→ 実行不可・書き込み不可
- `.data` / `.got` / `.bss` / スタック → 書き込み可・実行不可

実装のポイントは `elf_flags_to_page_flags()` で ELF セグメントの PF_X/PF_W フラグを x86_64 ページテーブルフラグに変換すること。中間テーブル（L4/L3/L2）は「通過する」だけなので常に WRITABLE + USER_ACCESSIBLE にし、リーフ（L1）エントリにだけ W^X 制限を適用する。

一つ厄介だったのが **ページ共有問題**。リンカが `.rodata`（R のみ）と `.data`（RW）を同一 4KiB ページ内に配置することがある。最初に R のみでマッピングしたページを後のセグメントが再利用するとき、WRITABLE が付かず書き込み保護違反（ページフォルト）になった。`merge_page_flags()` を作って、同一ページに複数セグメントがまたがる場合は権限の和集合（union）を取るようにして解決。

## 今日のまとめ

今日は計画した 4 タスクをすべて完了できた。grep・httpd ディレクトリリスティング・kill コマンド・W^X と、堅さと使い勝手の両方を進められた。ループバック対応はおまけで付いてきた嬉しい成果。W^X のページ共有問題は ELF のメモリレイアウトを理解する良い勉強になった。
