# 2026-02-06: Day 6 — 意気込み

## 今日の意気込み

昨日は GUI アプリ（電卓・テトリス・PAD）、FAT32 完全実装、telnetd 複数接続、httpd、簡易エディタ、sed + パイプと盛りだくさんだった。今日は「昨日作った土台をもっと使いやすく・堅くする」方向に進めたい。

今日一日、こんなことが出来たらいいな:

1. **grep コマンドの追加** — sed + パイプがあるのに grep がないのは寂しい。`cat FILE | grep PATTERN` や `grep PATTERN FILE` が使えると、ファイル操作の幅がぐっと広がる
2. **httpd のディレクトリリスティング** — `GET /` でルート直下のファイル一覧を返せると、ブラウザから SABOS のファイルシステムが見える。自作 OS がブラウザから見えるのは楽しいはず
3. **プロセス管理の改善（kill コマンド）** — spawn したプロセスを止める手段がまだない。`kill <pid>` でタスクを終了させられるようにする
4. **W^X（Write XOR Execute）の実装** — セキュリティ強化の第一歩。メモリページを「書き込み可能」か「実行可能」のどちらか一方だけにする

## 今日の計画

### タスク 1: grep コマンド追加

sed のときに作った `sabos-textutil` クレートを活用して、リテラル検索の grep を実装する。

- 変更ファイル:
  - `user/src/bin/shell.rs`: grep コマンドの追加
  - `libs/sabos-textutil/src/lib.rs`: 行内マッチ関数の追加（必要なら）
  - `kernel/src/shell.rs`: selftest に grep のテスト追加
- 機能:
  - `grep PATTERN FILE` — ファイルからパターンを含む行を出力
  - `grep -i PATTERN FILE` — 大文字小文字を無視
  - `grep -v PATTERN FILE` — マッチしない行を出力
  - `grep -c PATTERN FILE` — マッチした行数を出力
  - パイプ対応: `cat FILE | grep PATTERN`

### タスク 2: httpd のディレクトリリスティング

GET リクエストのパスがディレクトリだった場合に、HTML でファイル一覧を返す。

- 変更ファイル:
  - `user/src/bin/httpd.rs`: ディレクトリ判定とHTML生成
- 機能:
  - `GET /` でルートディレクトリのファイル一覧を HTML で返す
  - `GET /SUBDIR/` でサブディレクトリの一覧を返す
  - 各ファイルにリンクを付けて、クリックでダウンロードできる

### 完了: タスク 1 — grep コマンド追加

`sabos-textutil` に `contains_literal()` を追加し、ユーザーシェルに `grep [-i] [-v] [-c] PATTERN [FILE]` を実装した。パイプにも対応。selftest に `textutil_contains` を追加して **27/27 PASS**。

### 完了: タスク 2 — httpd のディレクトリリスティング

`GET /` でルートディレクトリの HTML ファイル一覧を返すようにした。各エントリはクリック可能なリンク付き。selftest に `httpd_dirlist` を追加。

### 追加: ループバック対応 + http ポート指定

netstack にソフトウェアループバックを実装した。ローカル宛（MY_IP / 127.0.0.1）の TCP パケットをネットワークに出さず内部で折り返す方式。ここでいう **ソフトウェアループバック** は「パケットを NIC に送らずに、送信関数の中で直接受信ハンドラに渡す」こと。

http コマンドに `host:port` 形式と `localhost` 対応を追加し、`http localhost:8080 /` で自身の httpd にアクセスできるようにした。

### TODO（後日）: nc コマンド

TCP の raw な送受信ができる nc (netcat) コマンドがあるとデバッグに便利。ループバック対応したので内部テストにも使える。

### 完了: タスク 3 — kill コマンド + SYS_KILL

`kernel/src/scheduler.rs` に `kill_task()` を追加し、SYS_KILL（番号 36）として公開。ユーザーシェルで `kill <pid>` が使えるようになった。自分自身の kill はエラーにしている。selftest に `kill_self_reject` を追加。**28/28 PASS**。

### 完了: タスク 4 — W^X（Write XOR Execute）

x86_64 の NX ビット（No-Execute: ページテーブルエントリの 63 ビット目）を活用して、ユーザー空間に W^X を適用した。

- `.text`（実行コード）→ 実行可・書き込み不可
- `.rodata`（読み取り専用データ）→ 実行不可・書き込み不可
- `.data` / `.got` / `.bss` / スタック → 書き込み可・実行不可

実装のポイントは `elf_flags_to_page_flags()` で ELF セグメントの PF_X/PF_W フラグを x86_64 ページテーブルフラグに変換すること。中間テーブル（L4/L3/L2）は「通過する」だけなので常に WRITABLE + USER_ACCESSIBLE にし、リーフ（L1）エントリにだけ W^X 制限を適用する。

一つ厄介だったのが **ページ共有問題**。リンカが `.rodata`（R のみ）と `.data`（RW）を同一 4KiB ページ内に配置することがある。最初に R のみでマッピングしたページを後のセグメントが再利用するとき、WRITABLE が付かず書き込み保護違反（ページフォルト）になった。`merge_page_flags()` を作って、同一ページに複数セグメントがまたがる場合は権限の和集合（union）を取るようにして解決。

### 完了: タスク 5 — GUI タスクバーとキーボードフォーカス機構

GUI サービスにタスクバーを追加した。画面最上部に常時表示され、キーボードで ELF パスを入力して spawn したり、`:shutdown` でシステム停止したり、`:exit` で dormant モードに戻ったりできる。

#### キーボードフォーカス機構

これが今回の肝。今まで全ユーザープロセスが単一の `INPUT_BUFFER` を共有していたので、GUI がキーボードを読むとシェルと競合してしまう問題があった。**キーボードフォーカス**という仕組みをカーネルに追加して解決した。

- `KEYBOARD_FOCUS_TASK: AtomicU64` — フォーカスを持つタスク ID（0 = フォーカスなし）
- フォーカスが設定されている間は、そのタスクだけが入力バッファから文字を読み取れる
- フォーカス外のタスクが `SYS_READ` を呼ぶとブロッキングで待機し続ける（`SYS_KEY_READ` なら 0 を返す）
- タスク終了時（正常終了、kill、例外）にフォーカスが自動解放される

新しいシステムコールを 2 つ追加:
- `SYS_KEY_READ(3)`: ノンブロッキングでキーを読む（`SYS_MOUSE_READ` と同じパターン）
- `SYS_CONSOLE_GRAB(4)`: キーボードフォーカスの取得 (1) / 解放 (0)

#### dormant モードの工夫

最初は GUI 起動時にすぐキーボードフォーカスを取る設計だったが、自動テスト（QEMU の `sendkey` でシェルにコマンドを送る）がフォーカスの影響でシェルにキーが届かず失敗した。そこで GUI は **dormant モード**（IPC サービスとしてのみ動作）で起動し、ウィンドウ作成 IPC（`OPCODE_WINDOW_CREATE`）を受信したときに初めてアクティブ化してフォーカスを取得するように変更した。

さらに、dormant モードでも全 IPC オペコードを処理する必要があることが分かった（`gui_ipc` テストが `OPCODE_CLEAR` を送るため）。最初は dormant 用の別処理関数を作っていたが、結局メインループの IPC 処理を dormant/active 共通にして、キーボードとマウスの処理だけを `if taskbar.active { ... }` で囲む設計に落ち着いた。

#### 変更ファイル

| ファイル | 変更内容 |
|---------|---------|
| `kernel/src/console.rs` | フォーカス機構 + フォーカス対応 read 関数 |
| `kernel/src/syscall.rs` | SYS_KEY_READ(3), SYS_CONSOLE_GRAB(4), sys_read 修正 |
| `kernel/src/scheduler.rs` | タスク終了時のフォーカス自動解放（4 箇所） |
| `user/src/syscall.rs` | key_read(), console_grab() ラッパー |
| `user/src/bin/gui.rs` | Taskbar 構造体、描画、キーボード処理、dormant モード |
| `docs/spec/syscall-list.md` | 新システムコールの記載 |

### 完了: nc (netcat) コマンド

TCP の raw な送受信ができる **nc (netcat) コマンド**をユーザーシェルに追加した。ここでいう netcat は「TCP 接続を張って、キーボード入力をそのまま送信し、受信データをそのまま表示する」最小ツール。

- クライアントモード: `nc <host> <port>` で指定先に接続
- サーバーモード: `nc -l <port>` で待ち受け
- ループバック対応済みなので `nc localhost 8080` で自身の httpd にも繋がる
- `console_grab` + `key_read` のノンブロッキングポーリングで、送受信を同時に処理

nc はデバッグツールとして超便利。httpd や telnetd の動作確認がシェルからすぐできるようになった。

### 完了: top コマンド（リアルタイムシステムモニター）

`ps` + `mem` を 1 秒間隔で定期リフレッシュ表示する対話型コマンド **`top`** を実装した。'q' / 'Q' / ESC キーで終了。nc コマンドと同じ `console_grab` + `key_read` のノンブロッキングポーリングパターンを再利用した。

OS を動かしているとプロセスやメモリの変化をリアルタイムで見たくなるので、top があると観察が捗る。

### std 対応への挑戦（ロードマップ作成 → Phase 2 まで実装）

ここからが今日の後半戦。SABOS のユーザープログラムで将来的に **Rust の `std` ライブラリ**を使えるようにしたいと考え、ロードマップを `TODO_std.md` にまとめた。std が使えれば外部クレート（Boa JS エンジンなど）が動くようになる。

ロードマップを書いた後、Phase 1〜2 を一気に進めた。

#### Phase 1: println! / print! マクロと log クレート

まず **`println!` / `print!` マクロ**を `user/src/print.rs` に実装した。`core::fmt::Write` トレイトを `SYS_WRITE` syscall で実装し、`write!` マクロ経由でフォーマット付き出力ができる仕組みだ。

```rust
// no_std でも std と同じ書き味で出力できる
println!("Hello, {}!", name);
println!("count = {}", 42);
```

今までは `syscall::write(msg.as_bytes())` を直接呼ぶか、`alloc::format!` で文字列を組み立てていた。`println!` があるとコードがぐっと読みやすくなる。全ユーザーバイナリに `#[macro_use] extern crate user;` を追加して、どこからでも使えるようにした。

次に **`log` クレート**（no_std 対応の定番ログライブラリ）を導入した。`print.rs` に `ConsoleLogger` を実装し、`log::info!()` 等で `[INFO] message` 形式のレベル付きログが出るようにした。これで「デバッグ時だけ出したい情報」と「常に出す情報」を使い分けられる。

#### Phase 1.5: ユーザー空間アロケータを linked_list_allocator に置き換え

std 対応の前提として、**dealloc ができるアロケータ**が必要だった。今までの **バンプアロケータ**（bump allocator）はアドレスを前に進めるだけで一切メモリを返せない方式だった。ここでいう「バンプ」は「ポインタをバンプ（ぶつけて進める）」という意味。

これを **`linked_list_allocator`** の `LockedHeap` に置き換えた。フリーリスト方式で alloc/dealloc 両方に対応する。カーネル側も同じクレートを使っているので、パターンが統一される。

- `allocator.rs`: `BumpAllocator` → `LockedHeap` (1 MiB)
- `allocator_gui.rs`: `BumpAllocator` → `LockedHeap` (5 MiB)
- `LockedHeap::empty()` は `init()` で初期化するまでアロケーション不可なので、全バイナリの `_start()` 冒頭に `allocator::init()` を追加

これで Boa JS エンジンの GC（ガベージコレクション）のように頻繁に alloc/dealloc を繰り返すプログラムが動く土台ができた。

#### Phase 2: SYS_CLOCK_MONOTONIC と SYS_GETRANDOM

std の `time` モジュールと `HashMap` の `RandomState` に必要なシステムコールを 2 つ追加した。

**SYS_CLOCK_MONOTONIC (26)**: PIT（Programmable Interval Timer）のティックカウンタをミリ秒に変換して返す。ここでいう **モノトニック時計** は「巻き戻らない、単調増加する時計」のことで、経過時間の計測に使う。変換式は `ticks * 10000 / 182`（PIT は約 18.2Hz で割り込む）。

**SYS_GETRANDOM (27)**: x86_64 の **RDRAND 命令**でハードウェア乱数を生成してユーザーバッファに書き込む。RDRAND は CPU 内蔵の乱数生成器で、OS が別途乱数プールを持つ必要がない。ただし QEMU のデフォルト CPU モデル（qemu64）は RDRAND を持たないので、`Makefile` に **`-cpu max`** オプションを追加して対応した。

selftest に `clock_monotonic` / `getrandom` テストを追加し、**30/30 PASS** を確認。

## 今日のまとめ

今日は盛りだくさんの一日だった。朝の計画（grep, httpd, kill, W^X）を全部終わらせた上に、タスクバー、nc、top と実用的なコマンドを量産し、さらに std 対応という大きなテーマに着手して Phase 2 まで到達した。

特に嬉しかったのは **println! マクロ**。今まで `syscall::write()` を直接呼んでいた不格好なコードが、`println!("value = {}", x)` の一行で書けるようになった。これだけで「自分の OS がちゃんと使える」感覚がぐっと上がる。

linked_list_allocator への置き換えも地味だけど大きな一歩。バンプアロケータでは dealloc ができなかったので、長時間動かすとメモリが枯渇する問題があった。フリーリスト方式になったことで、プロセスが動的にメモリを使い回せるようになった。

W^X のページ共有問題は ELF のメモリレイアウトを理解する良い勉強になったし、タスクバーのキーボードフォーカス設計はテスト環境との両立という現実的な課題を解決できた。

### 完了: Phase 3 — SYS_MMAP / SYS_MUNMAP（動的メモリマッピング）

std 対応の次のステップとして、ユーザー空間から動的にメモリを確保/解放できる **SYS_MMAP (28)** と **SYS_MUNMAP (29)** を実装した。POSIX の `mmap(MAP_ANONYMOUS)` に相当する機能。

**SYS_MMAP**: アドレスのヒント（0 ならカーネルが自動選択）とサイズを渡すと、ゼロ初期化されたページがマッピングされる。mmap 領域は `0x4000_0000`（1GiB）以降に配置し、カーネルのアイデンティティマッピング（物理 RAM の範囲）と重ならないようにした。

**SYS_MUNMAP**: mmap で確保した領域を解放する。物理フレームは即座にフレームアロケータに返却され、プロセスの `allocated_frames` からも除去される。プロセス終了時にも自動で解放されるので、munmap を呼び忘れてもリークしない。

#### 1GiB 巨大ページの分割

ここで一番の壁になったのが **UEFI/OVMF の 1GiB 巨大ページ**。UEFI は物理メモリを L3 レベルの 1GiB ページ（HUGE_PAGE フラグ付き）でマッピングすることがあり、mmap のアドレス（1GiB 以降）がこの巨大ページの範囲に入ってしまう。

巨大ページは「テーブルへのポインタ」ではなく「1GiB 領域への直接マッピング」なので、L2 テーブルとして辿ることができない。そこで `split_1gib_huge_page_for_process()` を実装し、1GiB → 512 個の 2MiB 巨大ページ（L2 テーブル）に分割する処理を追加した。さらにその中の特定の 2MiB ページは既存の `split_huge_page_for_process()` で 4KiB に分割される。

以前 W^X で実装した 2MiB → 4KiB の分割（`split_huge_page_for_process`）と同じパターンで、一段上のレベルに適用した形。x86_64 のページテーブルは 4 階層あるので、各レベルの巨大ページに対応できるようになった。

#### 変更ファイル

| ファイル | 変更内容 |
|---------|---------|
| `kernel/src/paging.rs` | `map_anonymous_pages_in_process()`, `unmap_pages_in_process()`, `split_1gib_huge_page_for_process()` |
| `kernel/src/syscall.rs` | SYS_MMAP(28), SYS_MUNMAP(29), `find_free_mmap_region()`, `is_page_mapped()` |
| `kernel/src/scheduler.rs` | `add_mmap_frames_to_current()`, `remove_mmap_frames_from_current()`, `current_task_page_table_frame()` |
| `kernel/src/shell.rs` | selftest に `mmap` テスト追加 |
| `user/src/syscall.rs` | `mmap()`, `munmap()` ラッパー |
| `docs/spec/syscall-list.md` | 新システムコールの記載 |

selftest **31/31 PASS**。

### 完了: cal コマンド（カレンダー表示）

`cal <月> <年>` でカレンダーを表示するコマンドを追加した。月初の曜日は **ツェラーの公式**（Zeller's congruence）で計算する。ツェラーの公式は「年月日から曜日を数学的に求める公式」で、グレゴリオ暦に対応している。1月・2月は前年の13月・14月として扱うのがポイント。うるう年の判定（4で割り切れるが100では割り切れない、ただし400で割り切れればうるう年）も組み込んだ。

RTC（リアルタイムクロック）がまだないので年月は引数指定式。将来 RTC を実装したら `cal` だけで今月のカレンダーを出せるようにしたい。
