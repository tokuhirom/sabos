# 2026-02-18: net_poller カーネルタスク導入 — TCP accept 競合の根本解決

## 今日の目標

昨日発見した httpd と telnetd の TCP accept 競合問題を根本的に解決したい。両方のサービスが `tcp_accept` を呼ぶと、それぞれが `poll_and_handle_timeout()` でパケットを取り合い、telnetd が接続を accept できなくなるという問題だった。今日は専用カーネルタスク `net_poller` を導入して、パケット処理を1箇所に集約する。

## やったこと

### 問題の根本原因

各 syscall（`tcp_accept`, `tcp_recv`, `dns_lookup` 等）が個別にパケット受信・処理を行う設計が問題だった。httpd と telnetd が同時にポーリングすると、SYN パケットを httpd が食べてしまい telnetd に届かない、といった競合が発生する。

```
【Before: 各 syscall が個別にポーリング】
httpd:    tcp_accept → poll_and_handle_timeout → recv_frame → handle_packet
telnetd:  tcp_accept → poll_and_handle_timeout → recv_frame → handle_packet
  → パケットの取り合いが発生！

【After: net_poller が一括処理、syscall は結果を待つだけ】
net_poller:  recv_frame → handle_packet → wake_all_net_waiters (ループ)
httpd:       tcp_accept → wait_net_condition(check: pending_accept?)
telnetd:     tcp_accept → wait_net_condition(check: pending_accept?)
  → パケット処理は net_poller だけ。syscall はイベント通知を待つ
```

### net_poller カーネルタスクの実装

`kernel/src/netstack.rs` に以下を追加した。

#### NetState に waiter リストを追加

```rust
net_waiters: Vec<u64>,  // ネットワークイベントを待つタスク ID のリスト
```

ネットワークイベントを待っているタスクを管理するためのリスト。`register_net_waiter()` で登録、`unregister_net_waiter()` で解除する。

#### wait_net_condition — 汎用ネットワークイベント待機関数

```rust
fn wait_net_condition<T, F>(timeout_ms: u64, check_fn: F) -> Option<T>
where F: Fn() -> Option<T>
```

これが今回の実装の中核。ジェネリックな条件チェック関数 `check_fn` を受け取り、条件が満たされるかタイムアウトするまで sleep/wake ループで待機する。

動作フロー:
1. 即座チェック → 成立なら即 return
2. `timeout_ms == 0` なら None を返す（非ブロッキング）
3. waiter 登録 → sleep → wake → チェック → のループ
4. タイムアウトで None、条件成立で Some(T)

#### net_poller_task — パケット処理の中央集権化

```rust
pub fn net_poller_task() {
    loop {
        while let Some(frame) = recv_frame_nonblocking() {
            handle_packet(&frame);
            received = true;
        }
        if received { wake_all_net_waiters(); }
        kick_virtio_net();
        enable_and_hlt();  // QEMU SLIRP に処理時間を与える
    }
}
```

`enable_and_hlt()` は CPU を停止して次の割り込み（タイマー、ネットワーク等）を待つ命令。QEMU の SLIRP ネットワークバックエンドにパケット処理の時間を与えるために重要。

#### 7つの syscall を置き換え

| 関数 | timeout | 確認内容 |
|------|---------|---------|
| `dns_lookup` | 5000ms | UDP レスポンスにマッチする query_id |
| `tcp_connect` | 5000ms | connection が Established or Closed |
| `tcp_accept` | 引数 | `tcp_pending_accept` にポートが一致するエントリ |
| `tcp_recv` | 引数 | `recv_buffer` が非空 or CloseWait/Closed |
| `tcp_close` | 5000ms | connection が TimeWait or Closed |
| `udp_recv_from` | 引数 | socket の `recv_queue.pop_front()` |
| `wait_icmpv6_echo_reply` | 引数 | `icmpv6_echo_reply.take()` |

全て `wait_net_condition` に統一され、`poll_and_handle_timeout` と `drain_frames` は削除した。

### timeout=0 の非ブロッキング動作が重要だった

最初の実装では `timeout=0` に対してフォールバックタイムアウト（tcp_accept→100ms、tcp_recv→5000ms）を設定していた。これが大きなバグだった。

telnetd は以下のようなポーリングイベントループを持っている:

```rust
loop {
    // 新規接続チェック（非ブロッキング、timeout=0）
    if let Ok(conn_id) = tcp_accept(port, 0) { ... }
    // 既存接続のデータチェック（非ブロッキング、timeout=0）
    if let Ok(data) = tcp_recv(conn_id, 0) { ... }
    sleep(10);  // 少し待って再ループ
}
```

`timeout=0` が 100ms ブロッキングになると、このイベントループが詰まってしまい、新規接続も既存接続のデータ読み取りもできなくなる。修正後は `timeout_ms == 0` のとき即座にチェック＆復帰するようにした。

### httpd の復帰

パケット競合が解消されたので、`user/src/bin/init.rs` の SERVICES に httpd を追加してデフォルト起動に復帰させた。また `kernel/src/shell.rs` の selftest に `httpd_service` テストを有効化した。

### テスト結果

- カーネル selftest: **47/47 PASSED**（httpd_service, telnetd_service 含む）
- telnet テスト: **5/5 PASSED**（mkdir, ls, selftest_net, hellostd, cat）

httpd と telnetd が同時に動作し、両方のサービステストが通るようになった！

## 学び

### イベント駆動 vs ポーリングの設計

今回の問題は「各 syscall が個別にポーリングする」というアーキテクチャの限界だった。サービスが1つしかない間は動くが、複数サービスが同じリソース（NIC）を共有すると破綻する。

解決策は「受信処理を1箇所に集約し、関心のあるタスクにイベント通知する」というイベント駆動パターン。Linux の NAPI（New API）も同じ発想で、ネットワークドライバがパケットを受信して上位レイヤーに配送する構造になっている。

### 非ブロッキング API の重要性

`timeout=0` は「今すぐチェックして結果がなければ即座に返る」という意味。これをブロッキングにしてしまうと、イベントループベースのサーバー（telnetd, httpd）が正常動作しなくなる。API の契約（timeout=0 → 非ブロッキング）を厳密に守ることが大事。

### wake/sleep パターン

`wait_net_condition` は Linux の `wait_event_timeout` に似た仕組み。条件関数を渡して、条件成立かタイムアウトまで寝て待つ。waiter リストへの登録・解除を確実に行わないとリークする（unregister を忘れると永遠に起床通知が飛ぶ）。

## 変更ファイル

- `kernel/src/netstack.rs` — net_poller, wait_net_condition, waiter 管理、7 syscall の置き換え
- `kernel/src/main.rs` — net_poller タスクの spawn
- `kernel/src/shell.rs` — httpd_service テストの有効化
- `user/src/bin/init.rs` — httpd をデフォルトサービスに追加
