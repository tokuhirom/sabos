# 2026-02-12 開発日記

## 今日の目標

昨日実装したパイプ対応のあと、`make test` でテストスクリプト自体がハングする問題が見つかっていたので、それを調査・修正したい。

## やったこと

### selftest スクリプトのハング修正

`make test` を実行すると `scripts/run-selftest.sh` が永遠に終了しない問題を修正した。原因は複数あった。

#### 原因 1: `NET SELFTEST END` との誤マッチ

selftest 完了を検出するために `grep -q "SELFTEST END"` を使っていたが、これだとネットワーク selftest の出力 `=== NET SELFTEST END: 5/6 PASSED ===` にもマッチしてしまう。selftest がまだ 9 テスト目（全 47 テスト中）なのに QEMU を kill してしまっていた。

修正: パターンを `^=== SELFTEST END:` に変更。行頭が `=== SELFTEST` で始まるもののみマッチするので、`=== NET SELFTEST` にはマッチしない。

#### 原因 2: タイムアウトなしの `wait`

以前の実装は `wait "$QEMU_PID"` で QEMU の終了を無制限に待っていた。selftest --exit の `--exit` フラグが sendkey で欠落した場合（QEMU の PS/2 キーボードエミュレーションがキーを取りこぼす）、QEMU は自動終了せず永遠にハングする。

修正: 180 秒のタイムアウトループに変更。10 秒ごとに `SELFTEST END` の出力をチェックし、見つかれば QEMU を kill。タイムアウト後も QEMU が生きていれば強制終了。

#### 原因 3: sendkey のキー欠落

QEMU の sendkey コマンドは PS/2 キーボードのスキャンコードをエミュレートするが、短い間隔で送ると取りこぼすことがある。`selftest --exit` の `--exit` 部分が欠落すると、selftest は実行されるが完了後に ISA debug exit が呼ばれず QEMU が終了しない。

修正: selftest コマンド送信前に安定化ディレイ（sleep 2 + 改行 + sleep 1）を追加。さらに、selftest 開始（`SELFTEST START` 出力）を 15 秒間監視し、反応がなければ最大 2 回までリトライする仕組みを入れた。

### selftest: network_dns テストを netd IPC 経由に統一

カーネル内の `dns_lookup()` は netd との受信キューレースがあり、フレーキーテストの原因だった。`test_network_dns`（カーネル内 DNS）と `test_network_netd_dns`（netd IPC 経由 DNS）の 2 つのテストを、netd IPC 経由の 1 つに統一した。

これで selftest のテスト数が 1 つ減るが、テストの信頼性は向上する。カーネル内ネットワークスタックの削除（TODO の最優先タスク）に向けた一歩でもある。

### selftest 自体のハング問題を発見

スクリプトの修正が終わってテストを走らせたところ、今度はスクリプトではなく selftest 自体が `framebuffer_info` テスト付近でハングすることが判明した。HELLOSTD.ELF を実行しなくても再現する。

ハング位置が不安定（7 テスト目で止まったり 9 テスト目で止まったり）で、タイミング依存の問題と思われる。怪しいのは `framebuffer::screen_info()` が `without_interrupts` 内で `WRITER.lock()` を取得している点。GUI タスクが同じロックを保持中に selftest がこの関数を呼ぶと、割り込み無効化によりタスクスイッチが起きずデッドロックする可能性がある。

この問題は TODO.md に記録して、後日調査することにした。

### カーネル内ネットワークスタックの完全削除

TODO の最優先タスク（Step 2-4）を一気に片付けた。`kernel/src/net.rs`（1616行）を丸ごと削除！

#### 何を削除したか

- **net.rs 全体**: ARP/ICMP/UDP/TCP/DNS のプロトコル処理コード。これらは全て netd デーモンが担当する
- **DNS/TCP 系 syscall 5 本**: SYS_DNS_LOOKUP(40), SYS_TCP_CONNECT(41), SYS_TCP_SEND(42), SYS_TCP_RECV(43), SYS_TCP_CLOSE(44)
- **カーネルシェルコマンド 3 つ**: `netpoll`（ポーリングデバッグ）、`dns`（DNS 解決）、`http`（HTTP GET）

#### 何を残したか

- **IP 設定定数**: `net_config.rs` に MY_IP/GATEWAY_IP/DNS_SERVER_IP を分離。`ip` コマンドと SYS_GET_NET_INFO が参照する
- **raw フレーム syscall**: SYS_NET_SEND_FRAME(45), SYS_NET_RECV_FRAME(46), SYS_NET_GET_MAC(47) は netd が virtio-net にアクセスするために必要

#### レース条件の解消

以前はカーネルの `poll_and_handle()` と netd が同じ virtio-net 受信キューを取り合っていた。`poll_and_handle()` がパケットを食べてしまうと netd に届かないという、アーキテクチャとして破綻した状態だった。net.rs を削除したことで、`receive_packet()` を呼ぶのは `sys_net_recv_frame`（netd 用）だけになり、レース条件が構造的に発生しなくなった。

これでマイクロカーネル方針の「カーネルは raw フレーム送受信だけ、プロトコル処理はユーザー空間」が完成した。1616行のコード削除は気持ちいい。

## 学んだこと

- **grep パターンの精度は重要**: `SELFTEST END` のような汎用的なパターンは他の出力にもマッチしうる。`^=== SELFTEST END:` のように行頭アンカーと具体的な文字列を使うべき
- **CI スクリプトにはタイムアウトが必須**: `wait` のような無限待ちは CI をハングさせる。常にタイムアウトとフォールバックを用意する
- **`without_interrupts` + ロック取得はデッドロックの原因になりうる**: 割り込みを無効にするとタスクスイッチが起きないので、他のタスクが保持しているロックを待つと永遠に待ち続ける。これは典型的なカーネルプログラミングの落とし穴
