# 2026-02-12 開発日記

## 今日の目標

昨日実装したパイプ対応のあと、`make test` でテストスクリプト自体がハングする問題が見つかっていたので、それを調査・修正したい。

## やったこと

### selftest スクリプトのハング修正

`make test` を実行すると `scripts/run-selftest.sh` が永遠に終了しない問題を修正した。原因は複数あった。

#### 原因 1: `NET SELFTEST END` との誤マッチ

selftest 完了を検出するために `grep -q "SELFTEST END"` を使っていたが、これだとネットワーク selftest の出力 `=== NET SELFTEST END: 5/6 PASSED ===` にもマッチしてしまう。selftest がまだ 9 テスト目（全 47 テスト中）なのに QEMU を kill してしまっていた。

修正: パターンを `^=== SELFTEST END:` に変更。行頭が `=== SELFTEST` で始まるもののみマッチするので、`=== NET SELFTEST` にはマッチしない。

#### 原因 2: タイムアウトなしの `wait`

以前の実装は `wait "$QEMU_PID"` で QEMU の終了を無制限に待っていた。selftest --exit の `--exit` フラグが sendkey で欠落した場合（QEMU の PS/2 キーボードエミュレーションがキーを取りこぼす）、QEMU は自動終了せず永遠にハングする。

修正: 180 秒のタイムアウトループに変更。10 秒ごとに `SELFTEST END` の出力をチェックし、見つかれば QEMU を kill。タイムアウト後も QEMU が生きていれば強制終了。

#### 原因 3: sendkey のキー欠落

QEMU の sendkey コマンドは PS/2 キーボードのスキャンコードをエミュレートするが、短い間隔で送ると取りこぼすことがある。`selftest --exit` の `--exit` 部分が欠落すると、selftest は実行されるが完了後に ISA debug exit が呼ばれず QEMU が終了しない。

修正: selftest コマンド送信前に安定化ディレイ（sleep 2 + 改行 + sleep 1）を追加。さらに、selftest 開始（`SELFTEST START` 出力）を 15 秒間監視し、反応がなければ最大 2 回までリトライする仕組みを入れた。

### selftest: network_dns テストを netd IPC 経由に統一

カーネル内の `dns_lookup()` は netd との受信キューレースがあり、フレーキーテストの原因だった。`test_network_dns`（カーネル内 DNS）と `test_network_netd_dns`（netd IPC 経由 DNS）の 2 つのテストを、netd IPC 経由の 1 つに統一した。

これで selftest のテスト数が 1 つ減るが、テストの信頼性は向上する。カーネル内ネットワークスタックの削除（TODO の最優先タスク）に向けた一歩でもある。

### selftest 自体のハング問題を発見

スクリプトの修正が終わってテストを走らせたところ、今度はスクリプトではなく selftest 自体が `framebuffer_info` テスト付近でハングすることが判明した。HELLOSTD.ELF を実行しなくても再現する。

ハング位置が不安定（7 テスト目で止まったり 9 テスト目で止まったり）で、タイミング依存の問題と思われる。怪しいのは `framebuffer::screen_info()` が `without_interrupts` 内で `WRITER.lock()` を取得している点。GUI タスクが同じロックを保持中に selftest がこの関数を呼ぶと、割り込み無効化によりタスクスイッチが起きずデッドロックする可能性がある。

この問題は TODO.md に記録して、後日調査することにした。

### selftest ハング問題の修正: without_interrupts デッドロック解消

先ほど発見した「selftest が `framebuffer_info` や `handle_open` 付近でハングする」問題を修正した。

#### 原因の特定

ハング位置が不安定（7テスト目だったり9テスト目だったり）で、典型的なタイミング依存バグだった。調査の結果、根本原因は `framebuffer.rs` の全関数が `without_interrupts` 内で `WRITER.lock()` を取得していたこと。

デッドロックのシナリオ:

1. GUI タスクが `WRITER.lock()` を保持中にタイマー割り込み → タスクスイッチ
2. selftest タスクが `screen_info()` 等を呼ぶ → `without_interrupts` で割り込み無効化
3. `WRITER.lock()` 取得を試みるが、GUI タスクが保持中 → スピン待ち
4. 割り込み無効なのでタイマーが発火しない → GUI タスクに永遠に戻れない → **デッドロック**

つまり「割り込みハンドラとのデッドロックを防ぐために入れた `without_interrupts`」が、逆に「タスク間のデッドロックを引き起こしていた」という皮肉な状況だった。

#### without_interrupts が不要だった理由

コードのコメントには「キーボード割り込みハンドラが WRITER.lock() を取ろうとするのでデッドロックする」と書いてあった。しかし実際にキーボード割り込みハンドラ（`interrupts.rs`）を確認すると、`KEY_QUEUE.lock()` にしかアクセスしておらず、`WRITER` には一切触れていなかった。タイマー割り込みハンドラも同様。

つまり `without_interrupts` は「起きないデッドロック」を防ぐために入っていて、代わりに「実際に起きるデッドロック」を引き起こしていた。

#### 修正内容

`kernel/src/framebuffer.rs` の 10 関数と `kernel/src/serial.rs` の 1 関数から `without_interrupts` を除去:

- `set_global_colors`, `clear_global_screen`, `screen_size`, `screen_info`
- `draw_pixel_global`, `draw_rect_global`, `draw_line_global`, `draw_blit_global`, `draw_text_global`
- `_print`（kprint!/kprintln! の内部実装）
- `_serial_print`（serial_print!/serial_println! の内部実装）

`spin::Mutex` による排他制御だけで十分。`without_interrupts` がなくても、ロック保持中にタイマー割り込みが入ってタスクスイッチが起きれば、いずれロック保持タスクに戻ってロックが解放されるので、スピン待ちしていたタスクも進行できる。

#### 結果

selftest 全 48 テストが安定して PASS するようになった（テスト数も 47 → 48 に増えていた）。ハングは完全に解消。

### カーネル内ネットワークスタックの完全削除

TODO の最優先タスク（Step 2-4）を一気に片付けた。`kernel/src/net.rs`（1616行）を丸ごと削除！

#### 何を削除したか

- **net.rs 全体**: ARP/ICMP/UDP/TCP/DNS のプロトコル処理コード。これらは全て netd デーモンが担当する
- **DNS/TCP 系 syscall 5 本**: SYS_DNS_LOOKUP(40), SYS_TCP_CONNECT(41), SYS_TCP_SEND(42), SYS_TCP_RECV(43), SYS_TCP_CLOSE(44)
- **カーネルシェルコマンド 3 つ**: `netpoll`（ポーリングデバッグ）、`dns`（DNS 解決）、`http`（HTTP GET）

#### 何を残したか

- **IP 設定定数**: `net_config.rs` に MY_IP/GATEWAY_IP/DNS_SERVER_IP を分離。`ip` コマンドと SYS_GET_NET_INFO が参照する
- **raw フレーム syscall**: SYS_NET_SEND_FRAME(45), SYS_NET_RECV_FRAME(46), SYS_NET_GET_MAC(47) は netd が virtio-net にアクセスするために必要

#### レース条件の解消

以前はカーネルの `poll_and_handle()` と netd が同じ virtio-net 受信キューを取り合っていた。`poll_and_handle()` がパケットを食べてしまうと netd に届かないという、アーキテクチャとして破綻した状態だった。net.rs を削除したことで、`receive_packet()` を呼ぶのは `sys_net_recv_frame`（netd 用）だけになり、レース条件が構造的に発生しなくなった。

これでマイクロカーネル方針の「カーネルは raw フレーム送受信だけ、プロトコル処理はユーザー空間」が完成した。1616行のコード削除は気持ちいい。

### virtio-9p ドライバの実装: ホストディレクトリをゲストから直接アクセス

ユーザーランド開発サイクル高速化の最終ステップとして、virtio-9p ドライバを実装した。これにより、ホストの `./user/target` ディレクトリをゲストから `/9p` マウントポイント経由でリアルタイムにアクセスできるようになった。`cargo build` したら即座にゲストから `run /9p/...` で最新バイナリを実行でき、QEMU の再起動すら不要になった。

#### 9P2000.L プロトコルとは

9P は Plan 9 OS 発祥のファイルシステムプロトコルで、ネットワーク越しにファイルシステムを共有するためのもの。9P2000.L は Linux 向けの拡張版で、Linux のファイル属性（uid/gid/mode/size 等）をそのままやり取りできる。QEMU が `-virtfs` オプションでこのプロトコルをサポートしているため、ホスト側のディレクトリをゲストから直接読み書きできる。

プロトコルのメッセージは `size[4] type[1] tag[2] ...payload...` というフレーム形式で、fid（ファイル識別子）を使ってファイルやディレクトリを操作する。REST API のセッショントークンに近い概念で、walk で fid を取得 → lopen で開く → read/readdir でデータを読む → clunk で解放、という流れ。

#### 実装の流れ

1. **PCI デバイス検出**: vendor 0x1AF4, device 0x1009 で virtio-9p デバイスを発見
2. **virtio legacy トランスポート**: 既存の virtio-blk/net と同じパターンで Split Virtqueue をセットアップ。descriptor chain 2 個（送信 + 受信）で 9P メッセージを送受信
3. **9P メッセージ基盤**: LE エンコード/デコードのヘルパー関数群と、virtqueue 経由の `transact()` を実装
4. **version + attach**: `Tversion`（msize=8192, version="9P2000.L"）→ `Tattach`（root fid 取得）で 9P セッションを確立
5. **ファイル操作**: walk（パス解決）、lopen（ファイルオープン）、read（データ読み取り）、readdir（ディレクトリ一覧）、getattr（属性取得）、clunk（fid 解放）の 6 操作を実装
6. **VFS 統合**: 既存の FileSystem トレイトに合わせて V9pFs を実装し、`/9p` にマウント

#### 苦労した点

- **借用チェッカーとの戦い**: `transact()` で `self.tx_buf` と `self.rx_buf` のポインタを取りつつ `self.write_desc()` を呼ぶとき、可変借用と不変借用が衝突した。ポインタを先に変数に取り出してから `write_desc()` を呼ぶことで解決。Rust の借用チェッカーが unsafe なメモリアクセスのバグを事前に防いでくれた好例
- **デバイス config の読み取り**: virtio-9p の config space にはマウントタグ（文字列）が格納されている。offset 0x14 に tag_len[2] + tag[tag_len] という形式。virtio legacy では BAR0 + 0x14 がデバイス固有 config の開始位置

#### 結果

selftest に `9p_read` テストを追加し、49/49 全テスト PASS。これでユーザーランド開発のイテレーションが大幅に高速化された。

| 方法 | 手順 | 所要時間 |
|------|------|---------|
| disk.img 再作成 | `make disk-img` → `make run` | 遅い |
| hostfs.img 更新 | `make hostfs-update` → `make run` | 中程度（QEMU 再起動必要） |
| **virtio-9p** | `cargo build` → ゲスト内で `run /9p/...` | **最速（再起動不要）** |

## 学んだこと

- **grep パターンの精度は重要**: `SELFTEST END` のような汎用的なパターンは他の出力にもマッチしうる。`^=== SELFTEST END:` のように行頭アンカーと具体的な文字列を使うべき
- **CI スクリプトにはタイムアウトが必須**: `wait` のような無限待ちは CI をハングさせる。常にタイムアウトとフォールバックを用意する
- **`without_interrupts` + ロック取得はデッドロックの原因になりうる**: 割り込みを無効にするとタスクスイッチが起きないので、他のタスクが保持しているロックを待つと永遠に待ち続ける。これは典型的なカーネルプログラミングの落とし穴。今回実際にこのパターンを修正した。重要なのは「本当に割り込みハンドラがそのロックを取るのか」をコードで確認すること。コメントに「デッドロック防止」と書いてあっても、実際の割り込みハンドラがそのリソースにアクセスしていなければ `without_interrupts` は不要で、むしろ有害になる
- **9P2000.L は意外とシンプル**: ファイルシステムプロトコルと聞くと複雑そうだが、実際はメッセージの種類ごとに固定のフォーマットがあり、fid（ファイル識別子）で状態管理するステートフルなプロトコル。8 種の操作（version/attach/walk/lopen/read/readdir/getattr/clunk）だけで読み取り専用アクセスが実現できた。virtio トランスポートも virtio-blk と同じパターンなので、既存コードの知識がそのまま活かせた
- **開発サイクルの最適化は累積的に効く**: disk.img 全体再作成 → hostfs.img インクリメンタル更新 → virtio-9p リアルタイム共有と、段階的にイテレーション速度を改善してきた。最初の「毎回 dd + mkfs.fat」から比べると、今は cargo build → 即実行で圧倒的に速い。小さな改善を積み重ねることの大切さを実感した
