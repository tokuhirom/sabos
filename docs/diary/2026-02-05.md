# 2026-02-05: Day 5 — 意気込み

## 今日の意気込み

今日一日、こんなことが出来たらいいな、というのは「GUI の HUD 更新間隔を自分で調整できるようにして、観察しやすさを上げる」こと。昨日の GUI/HUD 追加は形になったので、今日は“使い勝手”の部分まで一歩進めて、再現しやすい観察ループを作りたい。

## 実装メモ

HUD の更新間隔を IPC で指定できるようにした。ここでいう **tick interval** は「GUI サービスのメインループが何回回ったら HUD を再描画するか」という意味で、時間そのものではなく **ループ回数ベースの間隔** になる。  
`gui hud on [interval]` の形で指定できるようにし、未指定なら従来通りのデフォルトで動くようにした。これで観察の粒度を変えられるようになり、HUD が“見たい頻度で更新される”状態になった。

## これから: GUI 電卓アプリに向けて必要なもの

今日の次の目標は **GUI 上で電卓が動く**こと。今ある GUI/IPC の土台を活かしつつ、次の要素が必要になると整理した。

1. **電卓アプリ本体 (ユーザー空間 ELF)**
   - 画面レイアウト（表示部 + ボタン）
   - 入力状態の管理（現在値/演算子/左項）
   - 四則演算のロジックと例外扱い（ゼロ除算など）

2. **GUI クライアント API の拡張（任意矩形の再描画）**
   - `clear/rect/text/present` は揃っているので、電卓 UI の描画は可能
   - ただし「部分更新」や「描き直しやすい構成」のために、**UI 描画を関数化**しておく必要がある

3. **入力の仕組み**
   - まずは **キーボード入力**で十分（マウスクリックは後回し）
   - シェルの入力と同じ read 系を使って、1 文字ずつ受け取る
   - `0-9`, `+ - * /`, `=` , `C` を受け付ける

4. **アプリ起動の導線**
   - `CALC.ELF` を disk image に含める
   - `run /CALC.ELF` で起動できるようにする

5. **テスト・再現性**
   - 最低限、`selftest` で起動確認 + IPC の応答確認を入れる余地がある
   - ただし GUI の描画内容は自動検証が難しいので、**起動ログと IPC 返答**で確認する形にする

## 実装: GUI 電卓アプリ（最小）＋ クリック対応

`CALC.ELF` を追加して、GUI 上で動く電卓の最小形を作った。入力は **マウスクリック**で、`0-9`, `+ - * /`, `=`, `C` を受け付ける。右上に **Q ボタン**を置いて終了できるようにした。  
GUI 側は「表示部 + ボタン」を描くだけにして、**クリックしたボタンに応じて表示部を再描画**する方式。数字入力や演算の状態は小さな状態機械で管理し、**fresh_entry（次の数字で置き換える）**というフラグで「演算子を押した直後の入力」を扱っている。

クリック対応のために、GUI サービス側に **マウス状態を返す IPC（opcode=8）**を追加した。GUI サービスはマウスを継続的に読む役目があるので、アプリ側はそこから **最後に更新された座標とボタン状態**を引き出す。ここで返す `seq` は「更新回数」のカウンタで、**クリックの立ち上がりだけを拾う**判定に使う。

さらに「GUIらしさ」として **ウィンドウを表示し、ドラッグで移動できる**ようにした。ここはアプリ側ではなく **GUI サービス側にウィンドウ管理を持たせる**方式に切り替えた。  
具体的には、GUI サービスにウィンドウ作成/描画/移動の IPC を追加し、タイトルバー上のドラッグを **サービス側で解釈して移動**させる。アプリは「ウィンドウ内座標で描画するだけ」に寄せることで、**他のアプリでも同じ仕組みを使える**形になった。

## 追加: もう1つの GUI アプリで汎用性確認

 ウィンドウ API が本当に汎用的かを確かめるために、`PAD.ELF` という小さな GUI アプリを追加した。  
 内容はシンプルで、ウィンドウ内に **INC ボタン**と **COLOR ボタン**を用意し、クリックでカウンタを増やしたり背景色を切り替えたりできる。  
 電卓以外のアプリでも同じウィンドウ API で動かせることが確認できた。

![GUI apps](images/2026-02-05-gui-calc-pad.png)

スクリーンショットは `scripts/run-gui-screenshot.sh` で自動取得できるようにした。  
内部では `make test` を走らせつつ、CALC/PAD を spawn して **GUI 画面を撮影**する。

合わせて selftest が時々取りこぼすことがあったので、`run-selftest.sh` の待ちを少し手厚くした。  
`selftest` 実行後に **開始ログが出るかを確認し、必要なら改行を送る**ことで入力の取りこぼしを減らしている。

---

## telnetd の第一歩（単一接続 + 別シェル）

開発サイクルを速くするために、**telnetd を user space サービスとして追加**した。  
現状は **単一接続のみ**で、接続が来たら **TSH.ELF（telnet 専用シェル）を別プロセスとして起動**し、TCP <-> IPC で入出力を中継する。

ここでのキーワードは **「別シェル」**。既存の SHELL.ELF を使うのではなく、telnet 用に最小コマンドセットを持つ別プロセスを動かすことで、コンソール I/O と独立した経路を作った。

### 追加したもの

- **TCP listen/accept の最小実装**（netstack に server 側の状態を追加）
- **telnetd サービス**（`/TELNETD.ELF`）
- **telnet 専用シェル**（`/TSH.ELF`）
- **selftest に telnetd 起動確認**を追加

これで「OS を再起動せずに別経路で操作できる」土台ができた。  
次は **複数セッション**や **テストスクリプトから telnet で selftest を叩く**方向に伸ばしていく。

Makefile に `CALC.ELF` を追加して、`run /CALC.ELF` で起動できるようにした。これで「GUI でアプリが動く」最小ラインに到達できた。

---

## selftest の分割と GUI IPC の詰まり対策

`selftest` が重くなってきたので、**ターゲット指定で分割実行**できるようにした。`selftest list` で対象一覧を出し、`selftest core` / `fs` / `net` / `gui` / `service` のように部分実行ができる。普段は `selftest` をそのまま走らせれば従来通りフルで回る。

GUI IPC が詰まっていた件は、**ログを最小限に足して進行位置を見える化**し、`recv_with_timeout` の待ちが永久にならないように **スピン上限のタイムアウト**を入れた。  
さらに、**協調的 yield での割り込み再有効化**の位置を見直し、`context_switch_enable` を分けて `yield_now()` からだけ使うように調整した。プリエンプション経路では従来通り割り込み無効を維持する。

それでも GUI の window create で落ちたので、**ELF ユーザースタックを 64KiB に拡張**して回避した。GUI サービスはスタック使用量が大きくなってきているので、今後もサイズ感には注意する。

最後に `make test` を実行し、`gui_ipc` まで含めて **19/19 PASS** を確認した。

CI では **GUI テストだけを別ジョブ**に切り分ける方針にした。  
`selftest base` を通常ジョブで回し、`selftest gui` を GUI 専用ジョブで実行する。重い GUI テストを切り離すことで、失敗時の原因切り分けも早くなるはず。

---

## df コマンド追加

FAT16 の使用量を確認したくなったので、ユーザーシェルに **`df` コマンド**を追加した。  
出力は JSON にして、`total_bytes / used_bytes / free_bytes` とクラスタ情報を出す。ここでいう **cluster** は FAT の最小割当単位で、ファイルはこの単位で領域を確保する。  
合わせて FAT16 ドライバに **空きクラスタ数の走査**と **総クラスタ数の計算**を追加し、`selftest` に `fat16_space` を増やして整合性チェックを入れた。

---

## 追記: FAT32 を最後まで作りきる（no_std クレート化）

昨日までの流れ（ユーザー空間から FAT を触る / VFS を型安全にする）を踏まえて、今日は **FAT32 を最後まで作りきる**ことに集中した。目的は「大きなボリュームに耐える」「LFN を扱える」「他の自作 OS でも流用できる」状態まで持っていくこと。

### まずは共通化: `fat-core` と `blockdev`

FAT 実装で何度も出てくる **BPB**（BIOS Parameter Block: ブートセクタに書かれている FAT の設定情報）や **LFN**（Long File Name: 8.3 形式より長い名前を扱う拡張）を、`libs/fat-core` に切り出した。ここは **no_std**（標準ライブラリ無しの Rust 環境）で動かせるようにして、将来どの OS でも再利用できるようにした。

- `parse_bpb()` で FAT 種別の判定
- `lfn_checksum()` や LFN 断片のデコード
- 8.3 形式の短い名前生成

同時に、ブロックデバイス抽象の入り口として `libs/blockdev` を追加した。今は最小の trait だけだが、「後で OS 間共有できる形」にしておくのが目的。

### カーネル側: FAT32 ドライバを実装

カーネルに `fat32.rs` を追加して、**読み込み/書き込み/削除/サブディレクトリ/LFN** を一通り実装した。FAT32 はルートディレクトリが「固定位置」ではなく「クラスタチェーン」なので、**クラスタチェーンをたどる**仕組みが中心になる。

- FAT エントリは 32bit（上位 4bit は予約なのでマスク）
- クラスタ → セクタ変換でデータ領域を走査
- LFN は逆順で並ぶので、チェックサムと順序で再構成

さらに `make disk-img` を **FAT32 フォーマット**に切り替え、HELLO.TXT も `Hello from FAT32!` に変更した。selftest の項目も `fat32 / fat32_space` に更新。

### ユーザー空間側: FAT32 を移植してコマンド対応

ユーザー空間にも FAT32 ドライバを移植し、`write / rm / mkdir / rmdir / df` を FAT32 で動かした。FAT16 時代の「root 直下だけ」制限は外して、**任意パスで操作できる**ようにした。

ここでハマったのは **process name が NULL だらけになる**問題。`sys_spawn` でユーザー空間の `&str` をそのまま保持してしまい、カーネルのページテーブルに切り替えた瞬間に参照できなくなっていた。プロセス名は **カーネル側で String にコピーしてから**使うことで解決。

### LFN チェックサムのオーバーフロー

`lfn_checksum()` で u8 の加算が **debug ビルドでオーバーフロー panic**していた。LFN のチェックサムは意図的に 8bit で回るので、`wrapping_add` を使うのが正しい。ここで「仕様どおりのオーバーフロー」を意識するのがポイントだった。

### テスト結果

`make test` を実行し、FAT32 化を含めて **selftest 20/20 PASS** を確認。

```
=== SELFTEST END: 20/20 PASSED ===
```

---

今日の意気込みを「昨日の流れを受けて、FAT32 を最後まで作りきる」に再設定して、実際に **読み書き・削除・LFN・テスト**まで一気通貫で終わらせられたのが大きい。次はこの FAT32 を土台に、さらに使いやすいツール群を積み重ねていきたい。
