# 2026-02-05: Day 5 — 意気込み

## 今日の意気込み

今日一日、こんなことが出来たらいいな、というのは「GUI の HUD 更新間隔を自分で調整できるようにして、観察しやすさを上げる」こと。昨日の GUI/HUD 追加は形になったので、今日は“使い勝手”の部分まで一歩進めて、再現しやすい観察ループを作りたい。

## 実装メモ

HUD の更新間隔を IPC で指定できるようにした。ここでいう **tick interval** は「GUI サービスのメインループが何回回ったら HUD を再描画するか」という意味で、時間そのものではなく **ループ回数ベースの間隔** になる。  
`gui hud on [interval]` の形で指定できるようにし、未指定なら従来通りのデフォルトで動くようにした。これで観察の粒度を変えられるようになり、HUD が“見たい頻度で更新される”状態になった。

## これから: GUI 電卓アプリに向けて必要なもの

今日の次の目標は **GUI 上で電卓が動く**こと。今ある GUI/IPC の土台を活かしつつ、次の要素が必要になると整理した。

1. **電卓アプリ本体 (ユーザー空間 ELF)**
   - 画面レイアウト（表示部 + ボタン）
   - 入力状態の管理（現在値/演算子/左項）
   - 四則演算のロジックと例外扱い（ゼロ除算など）

2. **GUI クライアント API の拡張（任意矩形の再描画）**
   - `clear/rect/text/present` は揃っているので、電卓 UI の描画は可能
   - ただし「部分更新」や「描き直しやすい構成」のために、**UI 描画を関数化**しておく必要がある

3. **入力の仕組み**
   - まずは **キーボード入力**で十分（マウスクリックは後回し）
   - シェルの入力と同じ read 系を使って、1 文字ずつ受け取る
   - `0-9`, `+ - * /`, `=` , `C` を受け付ける

4. **アプリ起動の導線**
   - `CALC.ELF` を disk image に含める
   - `run /CALC.ELF` で起動できるようにする

5. **テスト・再現性**
   - 最低限、`selftest` で起動確認 + IPC の応答確認を入れる余地がある
   - ただし GUI の描画内容は自動検証が難しいので、**起動ログと IPC 返答**で確認する形にする

## 実装: GUI 電卓アプリ（最小）＋ クリック対応

`CALC.ELF` を追加して、GUI 上で動く電卓の最小形を作った。入力は **マウスクリック**で、`0-9`, `+ - * /`, `=`, `C` を受け付ける。右上に **Q ボタン**を置いて終了できるようにした。  
GUI 側は「表示部 + ボタン」を描くだけにして、**クリックしたボタンに応じて表示部を再描画**する方式。数字入力や演算の状態は小さな状態機械で管理し、**fresh_entry（次の数字で置き換える）**というフラグで「演算子を押した直後の入力」を扱っている。

クリック対応のために、GUI サービス側に **マウス状態を返す IPC（opcode=8）**を追加した。GUI サービスはマウスを継続的に読む役目があるので、アプリ側はそこから **最後に更新された座標とボタン状態**を引き出す。ここで返す `seq` は「更新回数」のカウンタで、**クリックの立ち上がりだけを拾う**判定に使う。

さらに「GUIらしさ」として **ウィンドウを表示し、ドラッグで移動できる**ようにした。ここはアプリ側ではなく **GUI サービス側にウィンドウ管理を持たせる**方式に切り替えた。  
具体的には、GUI サービスにウィンドウ作成/描画/移動の IPC を追加し、タイトルバー上のドラッグを **サービス側で解釈して移動**させる。アプリは「ウィンドウ内座標で描画するだけ」に寄せることで、**他のアプリでも同じ仕組みを使える**形になった。

## 追加: もう1つの GUI アプリで汎用性確認

 ウィンドウ API が本当に汎用的かを確かめるために、`PAD.ELF` という小さな GUI アプリを追加した。  
 内容はシンプルで、ウィンドウ内に **INC ボタン**と **COLOR ボタン**を用意し、クリックでカウンタを増やしたり背景色を切り替えたりできる。  
 電卓以外のアプリでも同じウィンドウ API で動かせることが確認できた。

![GUI apps](images/2026-02-05-gui-calc-pad.png)

スクリーンショットは `scripts/run-gui-screenshot.sh` で自動取得できるようにした。  
内部では `make test` を走らせつつ、CALC/PAD を spawn して **GUI 画面を撮影**する。

合わせて selftest が時々取りこぼすことがあったので、`run-selftest.sh` の待ちを少し手厚くした。  
`selftest` 実行後に **開始ログが出るかを確認し、必要なら改行を送る**ことで入力の取りこぼしを減らしている。

---

## telnetd の第一歩（単一接続 + 別シェル）

開発サイクルを速くするために、**telnetd を user space サービスとして追加**した。  
現状は **単一接続のみ**で、接続が来たら **TSH.ELF（telnet 専用シェル）を別プロセスとして起動**し、TCP <-> IPC で入出力を中継する。

ここでのキーワードは **「別シェル」**。既存の SHELL.ELF を使うのではなく、telnet 用に最小コマンドセットを持つ別プロセスを動かすことで、コンソール I/O と独立した経路を作った。

### 追加したもの

- **TCP listen/accept の最小実装**（netstack に server 側の状態を追加）
- **telnetd サービス**（`/TELNETD.ELF`）
- **telnet 専用シェル**（`/TSH.ELF`）
- **selftest に telnetd 起動確認**を追加

これで「OS を再起動せずに別経路で操作できる」土台ができた。  
次は **複数セッション**や **テストスクリプトから telnet で selftest を叩く**方向に伸ばしていく。

Makefile に `CALC.ELF` を追加して、`run /CALC.ELF` で起動できるようにした。これで「GUI でアプリが動く」最小ラインに到達できた。

---

## selftest の分割と GUI IPC の詰まり対策

`selftest` が重くなってきたので、**ターゲット指定で分割実行**できるようにした。`selftest list` で対象一覧を出し、`selftest core` / `fs` / `net` / `gui` / `service` のように部分実行ができる。普段は `selftest` をそのまま走らせれば従来通りフルで回る。

GUI IPC が詰まっていた件は、**ログを最小限に足して進行位置を見える化**し、`recv_with_timeout` の待ちが永久にならないように **スピン上限のタイムアウト**を入れた。  
さらに、**協調的 yield での割り込み再有効化**の位置を見直し、`context_switch_enable` を分けて `yield_now()` からだけ使うように調整した。プリエンプション経路では従来通り割り込み無効を維持する。

それでも GUI の window create で落ちたので、**ELF ユーザースタックを 64KiB に拡張**して回避した。GUI サービスはスタック使用量が大きくなってきているので、今後もサイズ感には注意する。

最後に `make test` を実行し、`gui_ipc` まで含めて **19/19 PASS** を確認した。

CI では **GUI テストだけを別ジョブ**に切り分ける方針にした。  
`selftest base` を通常ジョブで回し、`selftest gui` を GUI 専用ジョブで実行する。重い GUI テストを切り離すことで、失敗時の原因切り分けも早くなるはず。

---

## df コマンド追加

FAT16 の使用量を確認したくなったので、ユーザーシェルに **`df` コマンド**を追加した。  
出力は JSON にして、`total_bytes / used_bytes / free_bytes` とクラスタ情報を出す。ここでいう **cluster** は FAT の最小割当単位で、ファイルはこの単位で領域を確保する。  
合わせて FAT16 ドライバに **空きクラスタ数の走査**と **総クラスタ数の計算**を追加し、`selftest` に `fat16_space` を増やして整合性チェックを入れた。

---

## 追記: FAT32 を最後まで作りきる（no_std クレート化）

昨日までの流れ（ユーザー空間から FAT を触る / VFS を型安全にする）を踏まえて、今日は **FAT32 を最後まで作りきる**ことに集中した。目的は「大きなボリュームに耐える」「LFN を扱える」「他の自作 OS でも流用できる」状態まで持っていくこと。

### まずは共通化: `fat-core` と `blockdev`

FAT 実装で何度も出てくる **BPB**（BIOS Parameter Block: ブートセクタに書かれている FAT の設定情報）や **LFN**（Long File Name: 8.3 形式より長い名前を扱う拡張）を、`libs/fat-core` に切り出した。ここは **no_std**（標準ライブラリ無しの Rust 環境）で動かせるようにして、将来どの OS でも再利用できるようにした。

- `parse_bpb()` で FAT 種別の判定
- `lfn_checksum()` や LFN 断片のデコード
- 8.3 形式の短い名前生成

同時に、ブロックデバイス抽象の入り口として `libs/blockdev` を追加した。今は最小の trait だけだが、「後で OS 間共有できる形」にしておくのが目的。

### カーネル側: FAT32 ドライバを実装

カーネルに `fat32.rs` を追加して、**読み込み/書き込み/削除/サブディレクトリ/LFN** を一通り実装した。FAT32 はルートディレクトリが「固定位置」ではなく「クラスタチェーン」なので、**クラスタチェーンをたどる**仕組みが中心になる。

- FAT エントリは 32bit（上位 4bit は予約なのでマスク）
- クラスタ → セクタ変換でデータ領域を走査
- LFN は逆順で並ぶので、チェックサムと順序で再構成

さらに `make disk-img` を **FAT32 フォーマット**に切り替え、HELLO.TXT も `Hello from FAT32!` に変更した。selftest の項目も `fat32 / fat32_space` に更新。

### ユーザー空間側: FAT32 を移植してコマンド対応

ユーザー空間にも FAT32 ドライバを移植し、`write / rm / mkdir / rmdir / df` を FAT32 で動かした。FAT16 時代の「root 直下だけ」制限は外して、**任意パスで操作できる**ようにした。

ここでハマったのは **process name が NULL だらけになる**問題。`sys_spawn` でユーザー空間の `&str` をそのまま保持してしまい、カーネルのページテーブルに切り替えた瞬間に参照できなくなっていた。プロセス名は **カーネル側で String にコピーしてから**使うことで解決。

### LFN チェックサムのオーバーフロー

`lfn_checksum()` で u8 の加算が **debug ビルドでオーバーフロー panic**していた。LFN のチェックサムは意図的に 8bit で回るので、`wrapping_add` を使うのが正しい。ここで「仕様どおりのオーバーフロー」を意識するのがポイントだった。

### テスト結果

`make test` を実行し、FAT32 化を含めて **selftest 20/20 PASS** を確認。

```
=== SELFTEST END: 20/20 PASSED ===
```

---

今日の意気込みを「昨日の流れを受けて、FAT32 を最後まで作りきる」に再設定して、実際に **読み書き・削除・LFN・テスト**まで一気通貫で終わらせられたのが大きい。次はこの FAT32 を土台に、さらに使いやすいツール群を積み重ねていきたい。

---

## 追記: FSInfo と BlockDevice 抽象化

「FAT32 を最後まで作りきる」の仕上げとして、**FSInfo** と **BlockDevice 抽象化**を入れて、性能と再利用性を上げた。

### FSInfo を使った空きクラスタ最適化

FAT32 には **FSInfo** という専用セクタがあり、**空きクラスタ数**や**次に探すべき空きクラスタのヒント**が入っている。これは「全部の FAT をなめて数える」という重い処理を避けるための仕組みで、**ボリュームの状態を高速に把握するためのキャッシュ**だ。

今回は `libs/fat-core` に FSInfo のパース/更新を追加し、
- `free_clusters()` は FSInfo が有効なら値を使う
- アロケーション/解放時に FSInfo を更新
という流れにした。もちろん **FSInfo が壊れている場合は走査にフォールバック**するので、安全側にも倒している。

### BlockDevice trait で I/O を共通化

`virtio-blk` と `syscall::block_read/write` を個別に呼ぶのをやめ、**BlockDevice trait** にまとめた。これは「セクタ読み書きを抽象化するインターフェース」で、
- カーネル側は `KernelBlockDevice`
- ユーザー空間は `SyscallBlockDevice`
で同じ FAT32 実装を動かせる。

**同じコードを kernel / user で使える**ので、no_std の再利用性が上がった。将来的に他の OS へ切り出すときも、BlockDevice だけ実装すれば動く設計になる。

### selftest の GUI IPC 安定化

FSInfo を入れて I/O が少し増えた影響か、GUI IPC の selftest がタイムアウトしやすくなった。そこで **IPC 応答待ちを“少し丁寧に”**して、
- 受信待ち中に `yield` を増やす
- ウィンドウ系 IPC は再送/再待ちでリトライ
という形に調整した。

`make test` の結果は **20/20 PASS** を確認。

---

今日の締めとして、性能（FSInfo）と再利用性（BlockDevice 抽象化）の両方を底上げできた。FAT32 はこれで「実装として完成している」状態に近づいたので、次はこの基盤の上でツールや上位レイヤを広げていきたい。

---

## 追記: yield に頼らないプリエンプティブ待機

「本格的な OS は yield しない」という観点で、カーネル側の待機ループを **yield 依存から HLT 依存**に切り替えた。具体的には、Ready タスクが残っている間は **`hlt` で待機**し、タイマー割り込みによる **プリエンプション**でタスクを切り替える。

これにより、カーネルが自発的に `yield_now()` を呼ばなくても、**タイムスライスで強制的に切り替わる**という「本格的な OS らしい」挙動になる。

- `scheduler::wait_until_no_ready_tasks()` を追加
- `main.rs` の待機ループを `hlt` ベースに変更
- scheduler の説明コメントも「プリエンプティブ」寄りに更新

`make test` で **20/20 PASS** を確認。

---

## 追記: GUI テトリス

「GUI 上で動くアプリをもう1つ作って汎用性を確かめる」という流れで、**テトリス**を実装した。ここでいう **テトリミノ** は「4つのブロックで構成されたテトリスのピース」のことで、7種類の形状をランダムに出す。

- `TETRIS.ELF` を追加して、ウィンドウ API（create/clear/rect/text/present/mouse）だけで描画できることを確認
- 盤面は 10x20、セルは 12px。クリック操作で左/右/回転/落下/ドロップ/リセットを行う
- 自動落下は `sleep` を使った簡易タイマで 500ms ごとに進める
- スコア/ライン数/次ピース表示をサイドパネルに出して「ゲームとして最低限成立」するところまで持っていった

新しいアプリ追加なので、`selftest` の GUI セクションに **`gui_tetris_elf`** を追加した。FAT32 から `TETRIS.ELF` を読み、ELF マジックを確認することで「ファイルが読める」ことを保証している。

スクショも残した。GUI ウィンドウでテトリスが動いているのが分かる状態まで到達できたのが嬉しい。

![GUI tetris](images/2026-02-05-gui-tetris.png)

`make test` の結果は **21/21 PASS**。

---

## 追記: 簡易 sed を追加

busybox に入っている程度の **簡易 sed** が欲しくなったので、ユーザーシェルに `sed` コマンドを追加した。ここでいう **リテラル置換** は「正規表現ではなく、文字列がそのまま一致した部分だけを置き換える」という意味で、`s/OLD/NEW/` の **s コマンド**だけに絞った。

- 対応範囲: `sed [-n] s/OLD/NEW/[gp] <file>`
- `g` は全置換、`p` は置換が起きた行だけ出力
- `-n` は自動出力を抑制（`p` がないと何も出さない）

処理の共通化のため、リテラル置換だけを `sabos-textutil` という **no_std の小さなクレート**として切り出した。こうしておくと、今後別のツール（例: `tr` や `grep` の一部）を作るときにも再利用できる。

selftest には `textutil_replace` を追加し、置換の基本ケースが通ることを確認した。

---

## 追記: 簡易パイプライン

sed があると「置換のためのパイプ」が欲しくなるので、ユーザーシェルに **簡易パイプライン**を実装した。ここでいう **パイプ** は「前のコマンドの出力を次のコマンドの入力に渡す仕組み」で、OS の pipe システムコールはまだ無いので、**シェル内で文字列を受け渡す簡易実装**にした。

- 対応コマンドは `echo / cat / sed` のみ（まずは置換用途に絞った）
- 例: `cat HELLO.TXT | sed s/Hello/SABOS/` のように使える
- `sed` は **ファイル指定が無いときに標準入力（パイプ入力）**を処理する

本格的なパイプ（プロセス間のストリーム）にはカーネル側の仕組みが必要なので、まずは **「シェル内での実用性」**を優先した。
