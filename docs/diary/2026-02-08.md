# 2026-02-08: Day 8 — SYS_MMAP バグ修正で std の println! が動いた！

## 今日の意気込み

昨日の std 対応 Phase 7 で `user-std` クレートが動くようになったものの、`println!` が使えず `raw_write()` というワークアラウンドで凌いでいた。今日はその根本原因を突き止めて、ちゃんと `println!` / `String` / `Vec` が動くようにしたい。

## SYS_MMAP ハングの原因究明

### 症状のおさらい

- `SYS_MMAP` を exec/spawn で起動したプロセスから呼ぶと制御が返らない
- シェルプロセス自身からの mmap selftest は PASS する
- `SYS_WRITE`（raw_write）は exec プロセスからも正常に動作する

### デバッグ手法

`sys_mmap` → `find_free_mmap_region` → `is_page_mapped` の各関数にデバッグ出力（`kprintln!`）を仕込んで、どの行でハングするか特定した。

最初は大まかなログ（関数の入り口/出口）から始めて、次にページテーブルの各レベル（L4 → L3 → L2 → L1）のエントリ内容を詳細に出力するように段階的にログを増やした。

### 判明した根本原因

```
[is_page_mapped] 0x40000000: L3[1] flags=0x83 addr=0x40000000 unused=false
[is_page_mapped] 0x40000000: L3 HUGE_PAGE -> mapped
```

**L3 エントリに 1GiB ヒュージページ（flags=0x83 = PRESENT | WRITABLE | HUGE_PAGE）が存在していた。**

UEFI は物理メモリを 1GiB 単位のヒュージページで identity mapping（物理アドレス = 仮想アドレス）する。`create_process_page_table()` はカーネルの L4 エントリを全コピーするため、この identity mapping がプロセスのページテーブルにもそのまま引き継がれる。

`MMAP_VADDR_BASE` は `0x4000_0000`（1GiB）に設定されていたが、これは L4[0] → L3[1] の範囲で、まさに UEFI のヒュージページと完全に重なっていた。結果、`find_free_mmap_region()` は全アドレスを「マッピング済み」と判定し、MMAP_VADDR_LIMIT まで延々とスキャンする無限ループに入っていた。

### なぜシェルでは動くのか

シェルプロセスの mmap selftest は `find_free_mmap_region()` を使わず、直接 `map_anonymous_pages_in_process()` にアドレスを渡していた（0x4000_0000 に 2 ページをマッピング）。つまり「空き領域の検索」をスキップしていたので、ヒュージページとの衝突が問題にならなかった。

### 修正

`MMAP_VADDR_BASE` を `0x100_0000_0000`（1TiB = L4[2] の範囲）に変更した。L4[0] は UEFI の identity mapping が入っている可能性があるが、L4[2] は空なので衝突しない。

```rust
// 修正前
const MMAP_VADDR_BASE: u64 = 0x4000_0000;     // 1 GiB (L4[0])
const MMAP_VADDR_LIMIT: u64 = 0x80_0000_0000;  // 512 GiB

// 修正後
const MMAP_VADDR_BASE: u64 = 0x100_0000_0000;  // 1 TiB (L4[2])
const MMAP_VADDR_LIMIT: u64 = 0x200_0000_0000;  // 2 TiB
```

## println! / String / Vec が動いた！

mmap 修正後、`user-std/src/main.rs` を以下のように書き換えた:

```rust
#![feature(restricted_std)]

fn main() {
    println!("Hello from SABOS std!");
    println!("2 + 3 = {}", 2 + 3);

    let s = String::from("Hello from std String!");
    println!("{}", s);

    let v: Vec<i32> = (1..=5).collect();
    let sum: i32 = v.iter().sum();
    println!("sum of 1..=5 = {}", sum);
}
```

**`raw_write()` ワークアラウンドを完全に削除し、`println!` のみで出力できるようになった。**

`println!` が動くまでの経路:
1. `println!` → std の `stdout()` → `OnceLock::get_or_init()` でスタティック Stdout を初期化
2. Stdout の初期化にはヒープ確保（`SYS_MMAP`）が必要
3. mmap 修正により SYS_MMAP が正常に動作 → Stdout 初期化成功
4. `Stdout::write()` → PAL の `sys_stdio_sabos.rs` → `SYS_WRITE` → シリアルコンソールに出力

`String::from` や `Vec::collect` もヒープアロケーション（SYS_MMAP）経由で正常動作。

## テスト結果

```
HELLOSTD.ELF test PASSED
  Arithmetic output OK
  Vec/alloc output OK
=== SELFTEST END: 40/40 PASSED ===
All tests PASSED!
```

## 学んだこと

- **x86_64 のページテーブル階層（L4 → L3 → L2 → L1）とヒュージページの仕組み**。L3 エントリに HUGE_PAGE フラグが立っていると、その下に L2/L1 テーブルは存在せず、1GiB の領域がまるごと 1 つのエントリでマッピングされる。
- **UEFI の identity mapping は想像以上に広い**。物理 RAM が 128MB でも、UEFI は 1GiB 単位でマッピングするため `0x40000000`〜`0x7FFFFFFF` まで identity mapping が存在する。
- **デバッグの手順は段階的に**。最初は大まかなログで問題の箇所を絞り、次に詳細ログで原因を特定する。最初から全部にログを入れるとノイズが多すぎる。
