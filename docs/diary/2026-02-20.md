# 2026-02-20: 巨大ファイル分割リファクタリングの日

## 今日の目標

SABOS のカーネルコードが育ってきて、いくつかのファイルが 3,000 行を超えてきた。可読性・保守性が下がってきたので、今日はリファクタリングに集中して、巨大ファイルをサブモジュールに分割する日にしたい。

---

## syscall.rs の分割（3,416行 → 10モジュール）

最初に手を付けたのは `syscall.rs`。3,416 行あり、コンソール入出力からネットワーク、プロセス管理、グラフィックスまで全部入っていて、目的の関数を探すのが大変だった。

`syscall.rs` を `syscall/` ディレクトリに変換し、以下の 10 モジュールに分割した:

| ファイル | 内容 |
|---------|------|
| `mod.rs` | asm エントリ、dispatch_inner、共通ヘルパー、re-export |
| `console.rs` | read/write/pipe/spawn_redirected/clear_screen |
| `graphics.rs` | fb_info/mouse/draw 系 |
| `handle.rs` | open/read/write/close/stat/seek/openat 等 |
| `filesystem.rs` | file_delete/write/dir 系/fs_stat |
| `ipc.rs` | IPC・ブロックデバイス |
| `process.rs` | exec/spawn/wait/kill/env 系 |
| `network.rs` | tcp/udp/dns/ping6/raw frame |
| `sysinfo.rs` | mem/task/net_info/pci/clock |
| `misc.rs` | selftest/halt/mmap/getrandom/sound/thread/futex |

Rust のモジュールシステムでは `syscall.rs` を `syscall/mod.rs` に変えるだけで `mod syscall;` の宣言を変える必要がないのが嬉しい。外部から参照されている公開 API（`exec_for_test` や `open_path_to_handle` 等）は `mod.rs` で `pub use` して既存の `crate::syscall::*` パスを壊さないようにした。

分割後も 64/64 テスト PASS で、動作は完全に保たれている。

## shell.rs の分割（3,208行 → 3モジュール）

次に `shell.rs` を分割した。selftest のテストケースが大量に増えてきて、テスト関数だけで 2,000 行以上ある状態だった。

| ファイル | 内容 | 行数 |
|---------|------|------|
| `mod.rs` | Shell 構造体、コア機能（handle_char, execute_command）、rdtsc、run_selftest | ~140行 |
| `commands.rs` | 全 cmd_* メソッド（help, clear, mem, page, beep 等） | ~700行 |
| `selftest.rs` | cmd_selftest、print_pass/fail、全 test_* メソッド（64テスト） | ~2,160行 |

`impl super::Shell` パターンで、異なるファイルから同じ構造体にメソッドを追加できるのが Rust の良いところ。`pub(super)` で兄弟モジュール間のアクセスを制限し、外部からは `mod.rs` の `run_selftest()` だけを公開した。

## netstack.rs の分割（3,039行 → 9モジュール）

ネットワークスタックも分割した。TCP、UDP、DNS、ARP、DHCP、IPv6 など複数のプロトコルが1ファイルに入っていて、特に TCP の実装（接続管理、3-way ハンドシェイク、再送タイマー等）だけで大きかった。

| ファイル | 内容 | 行数 |
|---------|------|------|
| `mod.rs` | 共有状態（NET_STATE）、NIC 抽象化、パケットディスパッチ、net_poller | ~680行 |
| `types.rs` | パケットヘッダ構造体（EthernetHeader, IpHeader 等）、TcpState | ~290行 |
| `arp.rs` | ARP 要求/応答、MAC アドレス解決（resolve_mac） | ~160行 |
| `icmp.rs` | IPv4 パケット送信、ICMP echo | ~140行 |
| `tcp.rs` | TCP プロトコル全体（connect/listen/send/recv、再送タイマー、ISN） | ~620行 |
| `udp.rs` | UDP ソケット（bind/send/recv） | ~190行 |
| `dns.rs` | DNS ルックアップ（A レコード） | ~150行 |
| `ipv6.rs` | IPv6、ICMPv6 echo、NDP | ~250行 |
| `dhcp.rs` | DHCP discover/offer/request/ack | ~400行 |

netstack は syscall や shell と違って、モジュール間の内部状態共有が多い。`NET_STATE`（グローバルな Mutex 付きネットワーク状態）を `mod.rs` に残し、各サブモジュールは `super::with_net_state()` 経由でアクセスする設計にした。`pub use` で外部 API（`tcp_connect`, `udp_bind`, `dns_lookup` 等）を re-export して、`crate::netstack::*` のパスを維持した。

---

## 開発サイクルの振り返り

- 巨大ファイルの分割は、機能ごとにファイルを分けるだけなのでロジックの変更はないが、`pub(crate)` と `pub use` の扱いで細かいコンパイルエラーが出やすい。分割前に外部参照を grep で洗い出しておくと効率が良い
- テストがあると安心してリファクタリングできる。64 項目の selftest が全 PASS を確認できるのは本当にありがたい
- 並列作業が効果的だった。shell.rs を手動で分割している間に、netstack.rs の分割をサブエージェントに任せて並行実行できた
- netstack のようにモジュール間依存が多いファイルでは、最初に `pub use` の洗い出しをしっかりやることが重要。後から足すより最初にまとめて整理するほうが手戻りが少ない
- 今日1日で 3 ファイル（合計 9,663 行）を 22 モジュールに分割できた。コード量は変わらないが、ファイルあたり 100〜700 行になって見通しが格段に良くなった

## 分割後の全体像

分割が終わった後、残りのファイルサイズも確認した。3,000 行超のファイルはもうゼロになった。

次に大きいのは `scheduler.rs`（2,026行）と `paging.rs`（1,990行）だが、どちらも1つの機能（タスクスケジューラ、ページテーブル管理）に集中しているので、今すぐ分割する必要はなさそう。1,000行台のファイル（`virtio_9p.rs`、`fat16.rs`、`ahci.rs` 等）もそれぞれ1つのドライバ/プロトコルで完結しているので問題なし。

今回の分割で「1ファイルに複数の無関係な機能が詰め込まれている」状態は解消できた。次にファイルが膨らんできたら、2,000 行あたりをラインに再分割を検討する。

---

## IPv6 ping selftest の安定化

リファクタリングが一段落したところで、ずっと気になっていた `selftest_net` の `net_ipv6_ping` テストの FAIL 問題に取り組んだ。

### 問題

`selftest_net` のテスト 5（`net_ipv6_ping`）が CI で常に FAIL していた。原因は QEMU の SLIRP ネットワークバックエンドが ICMPv6 Echo Reply をサポートしていないこと。SLIRP は NDP（Neighbor Discovery Protocol）には対応しているが、ICMPv6 Echo（ping6）は未実装で、`"Slirp: external icmpv6 not supported yet"` というエラーが出る。つまり SABOS 側の実装には問題がなく、テスト環境の制約だった。

### 解決方針

外部ネットワーク通信に依存するテストを、パケット処理ロジックの単体テストに置き換えることにした。

1. **カーネル selftest に `ipv6_stack` テストを追加** — 偽の ICMPv6 Echo Reply パケットをメモリ上で構築し、`handle_packet()` に直接注入する。ネットワーク通信なしで IPv6/ICMPv6 のパケット処理パスが正しく動くことを検証できる。
2. **`selftest_net` から `net_ipv6_ping` を削除** — SLIRP の制約で CI では通らないテストなので除去。

### 実装の詳細

`test_ipv6_stack` では以下の手順でテストする:

1. `with_net_state()` で `icmpv6_echo_reply` を `None` にクリア
2. 偽の Ethernet + IPv6 + ICMPv6 Echo Reply パケット（66 バイト）を構築:
   - Ethernet ヘッダー: dst=自分の MAC、src=ダミー、ethertype=0x86DD（IPv6）
   - IPv6 ヘッダー: src=fec0::2、dst=fec0::15（MY_IPV6）、next_header=58（ICMPv6）
   - ICMPv6: type=129（Echo Reply）、id=0x1234、seq=1、チェックサム付き
3. `handle_packet()` に注入して処理させる
4. `icmpv6_echo_reply` が `Some((0x1234, 1, fec0::2))` になっていれば PASS

チェックサムは RFC 1071 に従って IPv6 疑似ヘッダー + ICMPv6 データから計算している。`handle_packet()` 側はチェックサムを検証していないが、正しいパケットを構築しておくことで将来チェックサム検証を追加しても壊れない。

`NetState` と `with_net_state()` の可視性を `pub(self)` → `pub(crate)` に変更して selftest からアクセスできるようにした。`get_my_mac()` も同様。

### 結果

- カーネル selftest: 64 → **65/65 PASSED**（`ipv6_stack` 追加）
- selftest_net: 5 → **4/4 PASSED**（`net_ipv6_ping` 削除）

これで CI が安定する。「テスト環境の制約で通らないテスト」を放置するとテスト結果の信頼性が下がるので、早めに対処できてよかった。偽パケット注入というアプローチは、ネットワーク依存なしでプロトコル処理を検証できるので、今後 TCP や UDP のテストにも応用できそう。
