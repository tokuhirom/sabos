# 2026-02-20: 巨大ファイル分割リファクタリングの日

## 今日の目標

SABOS のカーネルコードが育ってきて、いくつかのファイルが 3,000 行を超えてきた。可読性・保守性が下がってきたので、今日はリファクタリングに集中して、巨大ファイルをサブモジュールに分割する日にしたい。

---

## syscall.rs の分割（3,416行 → 10モジュール）

最初に手を付けたのは `syscall.rs`。3,416 行あり、コンソール入出力からネットワーク、プロセス管理、グラフィックスまで全部入っていて、目的の関数を探すのが大変だった。

`syscall.rs` を `syscall/` ディレクトリに変換し、以下の 10 モジュールに分割した:

| ファイル | 内容 |
|---------|------|
| `mod.rs` | asm エントリ、dispatch_inner、共通ヘルパー、re-export |
| `console.rs` | read/write/pipe/spawn_redirected/clear_screen |
| `graphics.rs` | fb_info/mouse/draw 系 |
| `handle.rs` | open/read/write/close/stat/seek/openat 等 |
| `filesystem.rs` | file_delete/write/dir 系/fs_stat |
| `ipc.rs` | IPC・ブロックデバイス |
| `process.rs` | exec/spawn/wait/kill/env 系 |
| `network.rs` | tcp/udp/dns/ping6/raw frame |
| `sysinfo.rs` | mem/task/net_info/pci/clock |
| `misc.rs` | selftest/halt/mmap/getrandom/sound/thread/futex |

Rust のモジュールシステムでは `syscall.rs` を `syscall/mod.rs` に変えるだけで `mod syscall;` の宣言を変える必要がないのが嬉しい。外部から参照されている公開 API（`exec_for_test` や `open_path_to_handle` 等）は `mod.rs` で `pub use` して既存の `crate::syscall::*` パスを壊さないようにした。

分割後も 64/64 テスト PASS で、動作は完全に保たれている。

## shell.rs の分割（3,208行 → 3モジュール）

次に `shell.rs` を分割した。selftest のテストケースが大量に増えてきて、テスト関数だけで 2,000 行以上ある状態だった。

| ファイル | 内容 | 行数 |
|---------|------|------|
| `mod.rs` | Shell 構造体、コア機能（handle_char, execute_command）、rdtsc、run_selftest | ~140行 |
| `commands.rs` | 全 cmd_* メソッド（help, clear, mem, page, beep 等） | ~700行 |
| `selftest.rs` | cmd_selftest、print_pass/fail、全 test_* メソッド（64テスト） | ~2,160行 |

`impl super::Shell` パターンで、異なるファイルから同じ構造体にメソッドを追加できるのが Rust の良いところ。`pub(super)` で兄弟モジュール間のアクセスを制限し、外部からは `mod.rs` の `run_selftest()` だけを公開した。

## netstack.rs の分割（3,039行 → 9モジュール）

ネットワークスタックも分割した。TCP、UDP、DNS、ARP、DHCP、IPv6 など複数のプロトコルが1ファイルに入っていて、特に TCP の実装（接続管理、3-way ハンドシェイク、再送タイマー等）だけで大きかった。

| ファイル | 内容 | 行数 |
|---------|------|------|
| `mod.rs` | 共有状態（NET_STATE）、NIC 抽象化、パケットディスパッチ、net_poller | ~680行 |
| `types.rs` | パケットヘッダ構造体（EthernetHeader, IpHeader 等）、TcpState | ~290行 |
| `arp.rs` | ARP 要求/応答、MAC アドレス解決（resolve_mac） | ~160行 |
| `icmp.rs` | IPv4 パケット送信、ICMP echo | ~140行 |
| `tcp.rs` | TCP プロトコル全体（connect/listen/send/recv、再送タイマー、ISN） | ~620行 |
| `udp.rs` | UDP ソケット（bind/send/recv） | ~190行 |
| `dns.rs` | DNS ルックアップ（A レコード） | ~150行 |
| `ipv6.rs` | IPv6、ICMPv6 echo、NDP | ~250行 |
| `dhcp.rs` | DHCP discover/offer/request/ack | ~400行 |

netstack は syscall や shell と違って、モジュール間の内部状態共有が多い。`NET_STATE`（グローバルな Mutex 付きネットワーク状態）を `mod.rs` に残し、各サブモジュールは `super::with_net_state()` 経由でアクセスする設計にした。`pub use` で外部 API（`tcp_connect`, `udp_bind`, `dns_lookup` 等）を re-export して、`crate::netstack::*` のパスを維持した。

---

## 開発サイクルの振り返り

- 巨大ファイルの分割は、機能ごとにファイルを分けるだけなのでロジックの変更はないが、`pub(crate)` と `pub use` の扱いで細かいコンパイルエラーが出やすい。分割前に外部参照を grep で洗い出しておくと効率が良い
- テストがあると安心してリファクタリングできる。64 項目の selftest が全 PASS を確認できるのは本当にありがたい
- 並列作業が効果的だった。shell.rs を手動で分割している間に、netstack.rs の分割をサブエージェントに任せて並行実行できた
- netstack のようにモジュール間依存が多いファイルでは、最初に `pub use` の洗い出しをしっかりやることが重要。後から足すより最初にまとめて整理するほうが手戻りが少ない
- 今日1日で 3 ファイル（合計 9,663 行）を 22 モジュールに分割できた。コード量は変わらないが、ファイルあたり 100〜700 行になって見通しが格段に良くなった
