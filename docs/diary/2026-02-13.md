# 2026-02-13 開発日記

## 今日の目標

FAT32 ドライバのユーザー空間サービス化（fat32d）を完成させたい。計画は 5 ステップに分けてあり、Step 1〜4 のコード実装は昨日完了した。今日は Step 5（統合テスト + ドキュメント）を仕上げて、全テスト PASS で完了にする。

## やったこと

### fat32d 統合: 起動順序・IPC フィルタ・メモリ増強で全50テスト PASS

5 ステップの実装計画に沿って fat32d を作り上げた。全体のアーキテクチャはこう:

```
[ブート時]  VFS "/" → Fat32 (カーネル内) → KernelBlockDevice → virtio-blk
[通常運用] VFS "/" → Fat32IpcFs (プロキシ) → IPC → fat32d → UserBlockDevice → SYS_BLOCK_READ → virtio-blk
```

netd（ネットワークデーモン）に続いて、FAT32 ファイルシステムもユーザー空間に移行できた。マイクロカーネルの名にふさわしい構成になってきた。

#### Step 1: libs/fat32 ライブラリ抽出

`kernel/src/fat32.rs` から `Fat32Fs<D: BlockDevice>` のコアロジックを `libs/fat32/` に切り出した。BlockDevice トレイトをジェネリックパラメータにすることで、カーネル内（`KernelBlockDevice`）とユーザー空間（`UserBlockDevice`）の両方で同じ FAT32 コードを使えるようになった。

ジェネリック化のメリットは大きい。FAT32 のパース・読み書きロジックは 1000 行以上あるが、これを二重に持つ必要がない。テストで見つけたバグも一箇所の修正で済む。

#### Step 2: SYS_BLOCK_READ/WRITE に dev_index 追加

fat32d がユーザー空間からブロックデバイスにアクセスするために、既存の `SYS_BLOCK_READ`/`SYS_BLOCK_WRITE` に第 4 引数 `dev_index` を追加した。これにより `disk.img`（dev 0）と `hostfs.img`（dev 1）を区別してアクセスできる。

後方互換のため、第 4 引数（r10）が 0 なら従来通り最初のデバイスを使う。

同時に `SYS_FS_REGISTER`（番号 18）も定義した。これは fat32d がカーネルに「自分が FAT32 サービスです」と登録するためのシステムコール。

#### Step 3: fat32d デーモン実装

`user/src/bin/fat32d.rs` を新規作成。netd と同じパターンで:
1. `_start()`: ヒープアロケータ初期化 → `SYS_FS_REGISTER` 呼出 → IPC ループ
2. `fat32d_loop()`: `ipc_recv` → opcode パース → `Fat32Fs<UserBlockDevice>` で処理 → `ipc_send`

IPC プロトコルは 7 種のオペコード（LIST_DIR, STAT, READ_FILE_CHUNK, CREATE_FILE, DELETE_FILE, CREATE_DIR, DELETE_DIR）を定義。大容量ファイルは READ_FILE_CHUNK で offset ベースの分割読み取りに対応した。

#### Step 4: Fat32IpcFs（カーネル VFS プロキシ）

`kernel/src/fat32_ipc.rs` を新規作成。VFS の `FileSystem` トレイトを実装し、各操作を fat32d への IPC メッセージに変換する。`SYS_FS_REGISTER` syscall を受けると、VFS の `/` と `/host` をこのプロキシに remount する。

ブート時はカーネル内 FAT32 でファイルをロードし、fat32d が登録されたら IPC プロキシに切り替わる。この「ブート時カーネル内 → ランタイムユーザー空間」の遷移がうまくいった。

#### Step 5: 統合テスト — 3 つのハマりポイント

ここからが今日のメインイベント。統合テストで 3 つの大きな問題にハマった。

##### 問題 1: サービス起動タイムアウト（30 秒ハング）

最初のテストでは、init が fat32d を**最初のサービス**として起動していた。すると fat32d が `SYS_FS_REGISTER` を呼んだ瞬間に VFS が IPC プロキシに切り替わり、以降の全サービス（netd, gui, httpd 等）の ELF ロードが fat32d 経由になる。

問題は、1〜2 MB の ELF ファイルを 64 KB チャンクの IPC で読み込むと、何十回もの IPC ラウンドトリップ + ディスク読み取りが必要になること。結果として各サービスの起動に数十秒かかり、30 秒のタイムアウトに引っかかっていた。

**解決策**: fat32d を SERVICES 配列の**最後**に移動。こうすると全 ELF はカーネル内 FAT32 で高速にロードされ、fat32d の登録は全サービス起動後に行われる。起動が一瞬になった。

```rust
static SERVICES: [Service; 6] = [
    Service { name: "netd", ... },
    Service { name: "gui", ... },
    Service { name: "telnetd", ... },
    Service { name: "httpd", ... },
    Service { name: "shell", ... },
    Service { name: "fat32d", ... },  // 最後に起動 → VFS 切替は全サービス起動後
];
```

##### 問題 2: IPC メッセージ汚染（データ破壊）

起動は速くなったが、selftest で `handle_open` テストが FAIL。HELLO.TXT（18 バイト）の読み取りで total_size が 115824 と返ってきた。

デバッグ出力を追加して調べると、fat32d に送ったリクエストの応答として**netd のレスポンス**が返ってきていた。`ipc::recv()` は「自分宛てのキューから最初のメッセージを取り出す」だけで、**送信元を区別しない**。fat32d の応答を待っているときに netd からのメッセージが先にキューに入ると、それを fat32d の応答と誤認してしまう。

これは非常に厄介なバグだった。opcode フィールドを確認すると、fat32d の opcode=3（READ_FILE_CHUNK）を期待しているのに、opcode=12（netd のレスポンス）が返ってきていた。データの先頭バイトをサイズと解釈するので、でたらめな値になる。

**解決策**: `ipc::recv_from(task_id, from_sender, timeout_ms)` を新規追加。キュー内のメッセージを走査して、指定された送信元からのメッセージだけを取り出す。他の送信元のメッセージはキューに残る。

```rust
fn try_recv_from(task_id: u64, from_sender: u64) -> Option<IpcMessage> {
    let mut queues = IPC_QUEUES.lock();
    let q = queues.get_mut(&task_id)?;
    // キューを走査して指定送信元のメッセージを探す
    let pos = q.iter().position(|msg| msg.sender == from_sender)?;
    q.remove(pos)  // 見つかった位置から取り出す（VecDeque::remove）
}
```

Fat32IpcFs で `recv` を `recv_from` に差し替えたところ、データ破壊は完全に解消した。

##### 問題 3: OOM クラッシュ（ヒープ枯渇）

IPC 問題を直してテストを走らせると、HELLOSTD.ELF のネットワークテスト中に OOM（Out of Memory）でカーネルパニック。カーネルヒープが 16 MiB しかなく、88%（14.2 MiB）使用済みの状態で 800 KB のアロケーションが 3 KB 差で失敗していた。

fat32d 関連のバッファ（IPC メッセージ 64KB × 複数タスク分）でヒープ使用量が増えたのが原因。

**解決策**: カーネルヒープを 16 MiB → 32 MiB に増強、QEMU の RAM を 128 MB → 256 MB に増加。

#### 結果

全 50 テスト PASS！（fat32d_service テストを新規追加して 49 → 50）

```
=== SELFTEST END: 50/50 PASSED ===
```

## 学んだこと

- **IPC の送信元フィルタリングは必須**: マイクロカーネルでは複数のサービスが同時に IPC メッセージを送ってくる。`recv` で「誰からのメッセージでも受け取る」だと、意図しないサービスのメッセージを誤って処理してしまう。L4 や seL4 といった本格的なマイクロカーネルでも、recv 時に送信元を指定する仕組みがある。今回身をもって学んだ
- **サービスの起動順序はパフォーマンスに直結する**: fat32d を最初に起動すると、後続のサービスの ELF ロードが全て IPC 経由になり桁違いに遅くなる。「ブートストラップは速いパスで、ランタイムはきれいなアーキテクチャで」という使い分けが重要
- **ジェネリック化で同じコードをカーネル/ユーザー空間で共有できる**: Rust のジェネリクスと `BlockDevice` トレイトの組み合わせで、FAT32 のコアロジックを一箇所に集約できた。これは Rust ならではの強み。C だと関数ポインタテーブルで実現するが、型安全性がない
- **メモリ見積もりは余裕を持つ**: 16 MiB のヒープで「足りるだろう」と思っていたが、IPC バッファの追加で想定外に消費が増えた。カーネルヒープの OOM はデバッグが難しいので、最初から余裕を持たせるべき

## 開発サイクルの振り返り

今回の fat32d 実装は 5 ステップの計画に沿って進めたが、Step 5（統合テスト）で 3 つの大きな問題にハマった。計画段階では予見できなかった問題ばかりで、統合テストの重要性を再認識した。

改善できそうな点:
- **IPC のデバッグ出力**: 今回は手動でデバッグ出力を追加して問題を特定した。IPC メッセージのトレース機能（送信元/宛先/opcode のログ）をカーネルに組み込んでおけば、次回のデバッグが楽になる
- **メモリ使用量のモニタリング**: OOM になるまで気づかなかった。selftest でヒープ使用率を定期的にチェックして、閾値を超えたら警告する仕組みがあると良い
