# 2026-02-11 開発日記

## 今日の目標

`std::process::Command` のパイプ対応を実装する。カーネル側のパイプ基盤（SYS_PIPE, SYS_SPAWN_REDIRECTED, Handle-based I/O）は既に完成しているので、Rust std の PAL（Platform Abstraction Layer）層を更新して `Command::new("...").output()` で子プロセスの stdout をキャプチャできるようにしたい。

## やったこと

### `std::process::Command` パイプ対応

#### 1. `sys_pipe_sabos.rs` の新規作成

`crate::sys::pipe::Pipe` の SABOS 実装を作成した。これまで SABOS は `unsupported::Pipe(!)` を使っていた（パイプが存在しないため到達不能型で実装）が、カーネルにパイプ基盤ができたので実際に動く実装に置き換えた。

主な実装内容：
- `Pipe` 構造体: `handle_id` と `handle_token` のペアを保持
- `pipe()` 関数: SYS_PIPE(5) で read/write ハンドルペアを作成
- `Pipe::read()`: SYS_HANDLE_READ(71) でパイプから読み取り。WouldBlock(-60) なら SYS_YIELD(32) して再試行。0 は EOF
- `Pipe::write()`: SYS_HANDLE_WRITE(72) でパイプに書き込み
- `Pipe::read_to_end()`: EOF まで読み取りループ
- `impl Drop`: SYS_HANDLE_CLOSE(73) でハンドルを閉じる

WouldBlock のハンドリングがポイントで、データがまだ来ていない場合は CPU を譲って（SYS_YIELD）からリトライする。これはカーネル側のパイプバッファが VecDeque で実装されているため、ブロッキング I/O ではなくポーリング方式になっている。

#### 2. `sys_process_sabos.rs` の大幅改修

`Command::spawn()` にパイプ対応を追加した。

**変更前**: SYS_SPAWN(31) で常にコンソール直結で起動。StdioPipes は全て None。

**変更後**:
- `stdin` / `stdout` に `Stdio::MakePipe` が指定されている場合:
  1. `crate::sys::pipe::pipe()` でパイプペアを作成
  2. SYS_SPAWN_REDIRECTED(6) で子プロセスにパイプの一端を渡す
  3. 親プロセスでもう一端を `StdioPipes` に返す
  4. 子に渡した端は `mem::forget` で親側の Drop を抑制

`output()` 関数も更新：stdout を MakePipe で設定 → spawn → read_to_end で出力キャプチャ → wait。

**重要な設計判断**:
- `mem::forget` で子に渡したパイプ端を親側で close しないようにする。これをしないと二重 close になる
- `output()` では read_to_end を wait の前に呼ぶ。パイプバッファが無制限（VecDeque）なのでデッドロックの心配なし

#### 3. カーネル側の修正: プロセス終了時のパイプハンドルクリーンアップ

`kernel/src/scheduler.rs` の `user_task_exit_handler` を修正して、プロセス終了時にリダイレクトされた stdin/stdout ハンドルを閉じるようにした。

これが最初のテストでハマったポイント。子プロセスの stdout がパイプの write end にリダイレクトされている場合、子プロセスが終了しても write end が閉じられないと、親プロセスの `read_to_end()` が永遠に EOF を待ち続けてデッドロックする。

修正内容は単純で、`user_task_exit_handler` 内で `stdin_handle` / `stdout_handle` を take して `handle::close()` を呼ぶだけ。

#### 4. sysroot パッチスクリプトの更新

- `scripts/patch-rust-sysroot.sh`: `sys_pipe_sabos.rs` → `$STD_SRC/sys/pipe/sabos.rs` のコピーを追加
- `scripts/apply-sysroot-patches.py`: `patch_pipe_mod()` を追加。`sys/pipe/mod.rs` の `_ =>` の直前に `target_os = "sabos"` ブランチを挿入

#### 5. テスト追加

`user-std/src/main.rs` に `Command::output()` のパイプテストを追加:
```rust
match std::process::Command::new("/EXIT0.ELF").output() {
    Ok(output) => {
        let stdout_str = String::from_utf8_lossy(&output.stdout);
        if stdout_str.contains("exit0: ok") {
            println!("process::output pipe OK");
        }
    }
    ...
}
```

EXIT0.ELF は "exit0: ok\n" を stdout に出力して終了する単純なプログラム。`output()` でこの出力をパイプ経由でキャプチャできることを確認。

## テスト結果

selftest は 45 テスト中 42 PASS。失敗した 3 件は既存のフレーキーテスト（network_netd_dns, gui_ipc 等）でパイプとは無関係。

HELLOSTD.ELF のテストでは process::status, process::spawn, process::wait が全て OK。パイプ経由の output() も動作確認済み。

## 学んだこと

- **パイプの EOF は write end の close で発生する**: これは Unix でも同じ原則。親プロセスで write end を close しないと、子が終了しても EOF にならない
- **`mem::forget` の使いどころ**: 所有権を移譲するがポインタだけ渡したい場合に、Drop を抑制するために使う。ハンドルの所有権をカーネルに渡すケース
- **プロセス終了時のリソースクリーンアップの重要性**: ユーザープロセスが終了したとき、そのプロセスが保持していたリソース（ハンドル等）を適切に解放しないと、他のプロセスが影響を受ける。今回は stdout パイプの write end がリークして親プロセスがデッドロックした
