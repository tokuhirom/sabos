# 2026-02-09 開発日記

## 今日の目標

昨日 TODO.md に「夢リスト」として追加したお楽しみ機能を、実際に形にしていきたい。ゲームやデモアプリを実装して、SABOS を「遊べる OS」にする日。その後、短期目標のバグ修正にも取り組みたい。

## デモアプリ 3 連発

### Conway's Game of Life (life.elf)

ライフゲーム（セルオートマトン）を GUI アプリとして実装した。

**仕様:**
- 48x36 セルのグリッド
- マウスクリックでセルのトグル（生/死を切り替え）
- PLAY/PAUSE で自動進行の切り替え、STEP で 1 世代ずつ進行
- CLEAR でグリッドクリア、RANDOM でランダム配置
- GLIDER ボタンで Gosper's Glider Gun（グライダーを無限生成する有名パターン）をプリセット配置

**実装のポイント:**
- ダブルバッファリング: `grid` と `grid_next` の 2 つの配列を使い、現在世代から次世代を計算してからコピーする。同じ配列を書き換えながら計算すると、まだ参照すべき「現在の値」が壊れてしまうため
- Conway のルール: 近傍 8 マスの生存数で判定。誕生(3)、生存(2 or 3)、それ以外は死亡
- Gosper's Glider Gun は 36 セルの座標をハードコードした const 配列で定義

### マンデルブロ集合レンダラー (mandel.elf)

フラクタル図形をリアルタイムに描画するアプリ。

**仕様:**
- 256x192 ピクセルのビュー
- マウスクリックした位置を中心に 2 倍ズーム
- ZOOM OUT / RESET ボタン
- プログレッシブレンダリング（16行ずつ描画して応答性を確保）

**実装のポイント:**
- **固定小数点演算（32.32 format）**: no_std 環境では浮動小数点ライブラリが使えないため、i64 の上位 32 ビットを整数部、下位 32 ビットを小数部とする固定小数点演算を自前実装。乗算は i128 経由で中間精度を確保する
- **ランレングス描画**: 同じ反復回数（=同じ色）のピクセルが水平に連続する場合、1px ずつ IPC するのではなく、連続分を 1 回の `window_rect` で描画。IPC オーバーヘッドを大幅に削減
- **カラーマッピング**: 反復回数を 6 フェーズの色相に変換。集合内部（MAX_ITER 到達）は黒

### スネークゲーム (snake.elf)

古典的なスネークゲーム。

**仕様:**
- 20x20 グリッド
- 十字配置の方向ボタン（^, <, >, V）でマウスクリック操作
- 餌（赤い四角）を食べると蛇が伸びてスコア加算
- 壁か自分の体にぶつかるとゲームオーバー

**実装のポイント:**
- **リングバッファ**: 蛇の体を `[(u8, u8); MAX_LEN]` の固定長配列 + `head_idx` + `len` で管理。新しい頭を追加するときは `head_idx` を +1 するだけ。尻尾は `len` が増えなければ自動的に「消える」。Vec を使わず O(1) で移動を実現
- **逆走防止**: 現在の進行方向と逆方向への入力を無視する（`is_opposite` 判定）。そうしないと蛇が自分の首に突っ込んで即死する
- **餌の配置**: ランダム位置を生成して、蛇の体と重なっていたらリトライ。蛇が長くなるとリトライ回数が増えるが、MAX_LEN = 400 なのでグリッド全体（400マス）を埋め尽くすことはまず起きない

## 共通パターン

3 つのアプリ全てに共通する GUI アプリのパターンが定着してきた:

```
_start() → allocator::init() → app_main()

app_main():
  gui = GuiClient::new()
  win_id = gui.window_create(w, h, title)
  loop {
    // 1. マウス入力処理（seq 変化を検出）
    // 2. ゲームロジック更新
    // 3. draw_all() で全画面描画
    // 4. gui.window_present(win_id)
    // 5. syscall::sleep(TICK_MS)
  }
```

- マウスの `seq` フィールドで入力のポーリングと変化検出
- `last_buttons` との比較でクリック（立ち上がりエッジ）を検出
- ボタンは `(x, y, w, h)` タプルで位置を定義し、`hit_btn()` で判定
- XorShift32 疑似乱数生成器（PID をシードに使用）

## バグ修正

### grep テスト修正

`scripts/run-selftest.sh` の `send_string()` 関数で、QEMU の `sendkey` コマンドに大文字が正しく送信されていなかった。`sendkey H` ではなく `sendkey shift-h` と送る必要がある。これにより `grep Hello HELLO.TXT` が `grep ello .` として送信されていた。

修正: `[A-Z]` の場合に `shift-` プレフィックスを付けるロジックを追加。

### HELLOSTD.ELF 後のカーネルパニック修正（#UD at 0x7c0100b）

HELLOSTD.ELF 終了時に CPU EXCEPTION: INVALID OPCODE (#UD) でカーネルパニックが発生していた。

**根本原因の分析:**

`usermode.rs` の `SAVED_RSP` / `SAVED_RBP` がグローバルの `static mut` 変数だった。`jump_to_usermode()` はこのグローバル変数にカーネルスタックの RSP/RBP を保存し、`exit_usermode()` でそれを復元して呼び出し元に longjmp する（setjmp/longjmp パターン）。

問題は、複数のユーザータスクがこのグローバル変数を共有していること。HELLOSTD.ELF（タスク7）が子プロセス EXIT0.ELF（タスク8, 9）やスレッド（タスク10, 11）を spawn すると、子タスクが `jump_to_usermode()` を呼んでグローバル変数を上書きする。その後 HELLOSTD.ELF が SYS_EXIT を呼ぶと、`exit_usermode()` は**解放済みの子タスクのスタック**を指す RSP/RBP を復元し、ゴミデータ（ページテーブルのデータ 0x7c0100b）をコードとして実行しようとして #UD が発生していた。

```
タスク7: jump_to_usermode → RSP_7/RBP_7 をグローバルに保存 → Ring 3
タスク8: jump_to_usermode → RSP_8/RBP_8 でグローバルを上書き → 実行・終了（スタック解放）
タスク7: SYS_EXIT → exit_usermode → RSP_8/RBP_8（解放済み！）を復帰 → 💥
```

**修正:**

- `Task` 構造体に `exit_saved_rsp` / `exit_saved_rbp` フィールドを追加
- `yield_now()` と `preempt()` でコンテキストスイッチ前にグローバル値をタスクごとにバックアップ、スイッチ後に復帰
- `yield_now()` を `context_switch_enable`（sti 付き）から `context_switch`（sti なし）に変更。復帰完了まで割り込みを無効に保ち、sti → ret の間にプリエンプションが入って復帰前に再スイッチされる危険を防止
- `thread_entry_wrapper` にも `switch_to_kernel_page_table()` を追加（安全対策）

```
タスク7: jump_to_usermode → RSP_7/RBP_7 をグローバルに保存 → Ring 3
プリエンプション: グローバルをタスク7のバックアップに退避
タスク8: jump_to_usermode → RSP_8/RBP_8 でグローバルを上書き → 実行・終了
タスク7 復帰: バックアップからグローバルを復帰 → RSP_7/RBP_7 ✓
タスク7: SYS_EXIT → exit_usermode → RSP_7/RBP_7 を復帰 → 正常終了 ✓
```

この修正で、ユーザープロセスが子プロセスやスレッドを spawn した後に正常終了できるようになった。

## 今日の成果

- [x] Conway's Game of Life 実装・テスト・push
- [x] マンデルブロ集合レンダラー実装・テスト・push
- [x] スネークゲーム実装・テスト・push
- [x] TODO.md 更新（完了マーク）
- [x] grep テストスクリプト修正（大文字送信対応）
- [x] HELLOSTD.ELF カーネルパニック修正（SAVED_RSP/SAVED_RBP のタスク間競合）
