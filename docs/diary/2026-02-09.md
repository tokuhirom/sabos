# 2026-02-09 開発日記

## 今日の目標

昨日 TODO.md に「夢リスト」として追加したお楽しみ機能を、実際に形にしていきたい。ゲームやデモアプリを実装して、SABOS を「遊べる OS」にする日。その後、短期目標のバグ修正にも取り組みたい。

## デモアプリ 3 連発

### Conway's Game of Life (life.elf)

ライフゲーム（セルオートマトン）を GUI アプリとして実装した。

**仕様:**
- 48x36 セルのグリッド
- マウスクリックでセルのトグル（生/死を切り替え）
- PLAY/PAUSE で自動進行の切り替え、STEP で 1 世代ずつ進行
- CLEAR でグリッドクリア、RANDOM でランダム配置
- GLIDER ボタンで Gosper's Glider Gun（グライダーを無限生成する有名パターン）をプリセット配置

**実装のポイント:**
- ダブルバッファリング: `grid` と `grid_next` の 2 つの配列を使い、現在世代から次世代を計算してからコピーする。同じ配列を書き換えながら計算すると、まだ参照すべき「現在の値」が壊れてしまうため
- Conway のルール: 近傍 8 マスの生存数で判定。誕生(3)、生存(2 or 3)、それ以外は死亡
- Gosper's Glider Gun は 36 セルの座標をハードコードした const 配列で定義

### マンデルブロ集合レンダラー (mandel.elf)

フラクタル図形をリアルタイムに描画するアプリ。

**仕様:**
- 256x192 ピクセルのビュー
- マウスクリックした位置を中心に 2 倍ズーム
- ZOOM OUT / RESET ボタン
- プログレッシブレンダリング（16行ずつ描画して応答性を確保）

**実装のポイント:**
- **固定小数点演算（32.32 format）**: no_std 環境では浮動小数点ライブラリが使えないため、i64 の上位 32 ビットを整数部、下位 32 ビットを小数部とする固定小数点演算を自前実装。乗算は i128 経由で中間精度を確保する
- **ランレングス描画**: 同じ反復回数（=同じ色）のピクセルが水平に連続する場合、1px ずつ IPC するのではなく、連続分を 1 回の `window_rect` で描画。IPC オーバーヘッドを大幅に削減
- **カラーマッピング**: 反復回数を 6 フェーズの色相に変換。集合内部（MAX_ITER 到達）は黒

### スネークゲーム (snake.elf)

古典的なスネークゲーム。

**仕様:**
- 20x20 グリッド
- 十字配置の方向ボタン（^, <, >, V）でマウスクリック操作
- 餌（赤い四角）を食べると蛇が伸びてスコア加算
- 壁か自分の体にぶつかるとゲームオーバー

**実装のポイント:**
- **リングバッファ**: 蛇の体を `[(u8, u8); MAX_LEN]` の固定長配列 + `head_idx` + `len` で管理。新しい頭を追加するときは `head_idx` を +1 するだけ。尻尾は `len` が増えなければ自動的に「消える」。Vec を使わず O(1) で移動を実現
- **逆走防止**: 現在の進行方向と逆方向への入力を無視する（`is_opposite` 判定）。そうしないと蛇が自分の首に突っ込んで即死する
- **餌の配置**: ランダム位置を生成して、蛇の体と重なっていたらリトライ。蛇が長くなるとリトライ回数が増えるが、MAX_LEN = 400 なのでグリッド全体（400マス）を埋め尽くすことはまず起きない

## 共通パターン

3 つのアプリ全てに共通する GUI アプリのパターンが定着してきた:

```
_start() → allocator::init() → app_main()

app_main():
  gui = GuiClient::new()
  win_id = gui.window_create(w, h, title)
  loop {
    // 1. マウス入力処理（seq 変化を検出）
    // 2. ゲームロジック更新
    // 3. draw_all() で全画面描画
    // 4. gui.window_present(win_id)
    // 5. syscall::sleep(TICK_MS)
  }
```

- マウスの `seq` フィールドで入力のポーリングと変化検出
- `last_buttons` との比較でクリック（立ち上がりエッジ）を検出
- ボタンは `(x, y, w, h)` タプルで位置を定義し、`hit_btn()` で判定
- XorShift32 疑似乱数生成器（PID をシードに使用）

## バグ修正

### grep テスト修正

`scripts/run-selftest.sh` の `send_string()` 関数で、QEMU の `sendkey` コマンドに大文字が正しく送信されていなかった。`sendkey H` ではなく `sendkey shift-h` と送る必要がある。これにより `grep Hello HELLO.TXT` が `grep ello .` として送信されていた。

修正: `[A-Z]` の場合に `shift-` プレフィックスを付けるロジックを追加。

### HELLOSTD.ELF 後のカーネルパニック修正（#UD at 0x7c0100b）

HELLOSTD.ELF 終了時に CPU EXCEPTION: INVALID OPCODE (#UD) でカーネルパニックが発生していた。

**根本原因の分析:**

`usermode.rs` の `SAVED_RSP` / `SAVED_RBP` がグローバルの `static mut` 変数だった。`jump_to_usermode()` はこのグローバル変数にカーネルスタックの RSP/RBP を保存し、`exit_usermode()` でそれを復元して呼び出し元に longjmp する（setjmp/longjmp パターン）。

問題は、複数のユーザータスクがこのグローバル変数を共有していること。HELLOSTD.ELF（タスク7）が子プロセス EXIT0.ELF（タスク8, 9）やスレッド（タスク10, 11）を spawn すると、子タスクが `jump_to_usermode()` を呼んでグローバル変数を上書きする。その後 HELLOSTD.ELF が SYS_EXIT を呼ぶと、`exit_usermode()` は**解放済みの子タスクのスタック**を指す RSP/RBP を復元し、ゴミデータ（ページテーブルのデータ 0x7c0100b）をコードとして実行しようとして #UD が発生していた。

```
タスク7: jump_to_usermode → RSP_7/RBP_7 をグローバルに保存 → Ring 3
タスク8: jump_to_usermode → RSP_8/RBP_8 でグローバルを上書き → 実行・終了（スタック解放）
タスク7: SYS_EXIT → exit_usermode → RSP_8/RBP_8（解放済み！）を復帰 → 💥
```

**修正:**

- `Task` 構造体に `exit_saved_rsp` / `exit_saved_rbp` フィールドを追加
- `yield_now()` と `preempt()` でコンテキストスイッチ前にグローバル値をタスクごとにバックアップ、スイッチ後に復帰
- `yield_now()` を `context_switch_enable`（sti 付き）から `context_switch`（sti なし）に変更。復帰完了まで割り込みを無効に保ち、sti → ret の間にプリエンプションが入って復帰前に再スイッチされる危険を防止
- `thread_entry_wrapper` にも `switch_to_kernel_page_table()` を追加（安全対策）

```
タスク7: jump_to_usermode → RSP_7/RBP_7 をグローバルに保存 → Ring 3
プリエンプション: グローバルをタスク7のバックアップに退避
タスク8: jump_to_usermode → RSP_8/RBP_8 でグローバルを上書き → 実行・終了
タスク7 復帰: バックアップからグローバルを復帰 → RSP_7/RBP_7 ✓
タスク7: SYS_EXIT → exit_usermode → RSP_7/RBP_7 を復帰 → 正常終了 ✓
```

この修正で、ユーザープロセスが子プロセスやスレッドを spawn した後に正常終了できるようになった。

## 開発サイクル改善

### selftest 後の OOM パニック修正

selftest が途中で OOM パニックを起こしてテストが完走しない問題を修正した。

**調査結果:**

ヒープ統計を出力する `dump_stats()` を実装して OOM ハンドラに組み込んだところ、問題の全体像が見えた:

```
[heap] slab[0] size=   32 alloc=   88/16384  (0.5% 使用)
[heap] slab[1] size=   64 alloc=    5/ 8192  (0.06%)
  ...
[heap] large: bump=13097880/13107200 free_list=4200 bytes in 2 blocks
```

Large 領域 12.5 MiB が 99.9% 使用済みで、スラブ領域 3.5 MiB はほとんど空き。3つの問題が重なっていた:

**問題 1: IPC キューのメモリリーク**

タスクが終了しても、そのタスク宛の IPC キュー（`IPC_QUEUES` の BTreeMap エントリ + `Vec<u8>` メッセージ群）が永久に残っていた。`ipc::cleanup_task()` を追加し、全5箇所のタスク終了パス（`task_exit_handler`、`user_task_exit_handler`、`thread_exit_handler`、`kill_task`、`fault_task_exit`）で呼ぶようにした。

**問題 2: reaped 済みタスクのリソースリーク**

`wait_for_child()` でタスクを reap した後も、タスク構造体の `_stack`（16KB の Box<[u8]>）と `env_vars`（クローンされた環境変数 Vec）がヒープに残っていた。reap 後に `_stack = None` と `env_vars = Vec::new()` で即座に解放するようにした。

**問題 3: スラブアロケータのヒープ配分が不適切**

`TOTAL_UNITS` を 32 → 64 に変更。各スラブの割り当てが 512 KiB → 256 KiB に半減し（使用率 1% 未満なので余裕）、Large 領域が 12.5 MiB → 14.25 MiB に拡大した。ELF ファイルの一時ロード（1〜2 MB/ファイル × 6 プロセス）と常駐するタスクスタック（16 KB/タスク × 12 タスク）で Large 領域が圧迫されていた。

修正後、selftest は 42 テスト中 41 PASS（`network_netd_dns` のみ既知の FAIL）で完走するようになった。

### テスト KEY_DELAY 短縮

`scripts/run-selftest.sh` の `KEY_DELAY` を 0.8 → 0.3 に変更。QEMU の `sendkey` コマンド間のウェイトで、約 100 キーストローク × 0.5 秒短縮 ≈ 50 秒の節約。テストは安定して PASS。

### CI の冗長ビルド排除

GitHub Actions の `build` → `test` → `test-gui` が直列実行（`needs: build`）かつ二重ビルドだった。

- `test`/`test-gui` から `needs: build` を削除して 3 ジョブ並列実行に変更
- 冗長な `Build`/`Create disk image`/`Create ESP directory` ステップを削除（`make test` が全て含む）

### Cargo ワークスペース統合の検討

kernel/user/user-std を Cargo ワークスペースに統合できないか調査した。結論: **現時点では非推奨**。

- `per-package-target` 機能が `-Zbuild-std` と互換性がない（user-std で必須）
- プロファイルがメンバー間で異なる（kernel=debug, user-std=release+LTO）
- ビルド時間改善は 5% 未満の見込み

## 今日の成果

- [x] Conway's Game of Life 実装・テスト・push
- [x] マンデルブロ集合レンダラー実装・テスト・push
- [x] スネークゲーム実装・テスト・push
- [x] TODO.md 更新（完了マーク）
- [x] grep テストスクリプト修正（大文字送信対応）
- [x] HELLOSTD.ELF カーネルパニック修正（SAVED_RSP/SAVED_RBP のタスク間競合）
- [x] selftest OOM パニック修正（IPC リーク + タスクリソースリーク + ヒープ配分最適化）
- [x] テスト高速化（KEY_DELAY 0.8→0.3）
- [x] CI 高速化（並列実行 + 冗長ビルド排除）
- [x] Cargo ワークスペース統合検討（非推奨と判断）
