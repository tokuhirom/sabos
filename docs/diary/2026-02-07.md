# 2026-02-07: Day 7 — dirty rect トラッキング

## 今日の意気込み

昨日はバックバッファ導入 → ネイティブピクセルフォーマット → 行単位 memcpy と描画パイプラインを一気に高速化した。今日はその延長線上で、もう一段描画を賢くしたい。

今日一日、こんなことが出来たらいいな:

1. **dirty rect トラッキング** — 描画操作で変更された領域を自動追跡して、flush 時にその領域だけ MMIO に転送する仕組み。今は各描画関数が個別に flush_rect を呼んでいるけど、dirty rect があれば「複数の描画をまとめて 1 回の flush で済ませる」ことができる

## 完了: dirty rect トラッキングの導入

### 背景

昨日バックバッファを導入して MMIO 転送を一括化したが、まだ改善の余地があった。各描画関数（`draw_rect_global`, `draw_blit_global`, `draw_text_global` 等）が描画直後に個別に `flush_rect()` や `flush()` を呼んでいて、特に `draw_line_global` と `draw_text_global` は **全画面 flush** していた。

`_print` マクロに至っては「スクロールが発生したかどうか」を手動で判定するロジック（描画前後の cursor_y を比較）があり、コードが複雑化していた。

### dirty rect とは

**ダーティ矩形（dirty rectangle）**は「バックバッファのうち、前回の flush 以降に変更された領域」を追跡する手法。ゲームや GUI ツールキットでは定番の最適化テクニックだ。

仕組みはシンプル:
1. 各描画操作が「自分が変更した矩形」を `mark_dirty(x, y, w, h)` で登録
2. 既存の dirty rect があれば、bounding box（両方を包含する最小矩形）に拡張
3. `flush_dirty()` で dirty rect の領域だけを MMIO に転送し、リセット

bounding box 方式なので、離れた 2 つの矩形をマークすると間の未変更領域も転送されてしまう弱点はあるが、実装がシンプルで十分な効果がある。より高度な「矩形リスト」方式は、リスト管理のオーバーヘッドが問題になるので今は採用しない。

### 実装

`FramebufferWriter` に `dirty: Option<DirtyRect>` フィールドを追加した。

```rust
/// ダーティ矩形。変更された領域の境界ボックスを追跡する。
struct DirtyRect {
    x_min: usize,
    y_min: usize,
    x_max: usize, // exclusive
    y_max: usize, // exclusive
}
```

`mark_dirty` は既存の dirty rect と新しい領域の bounding box を計算する:

```rust
fn mark_dirty(&mut self, x: usize, y: usize, w: usize, h: usize) {
    let new = DirtyRect { x_min: x, y_min: y, x_max: (x+w).min(self.width), ... };
    self.dirty = Some(match self.dirty {
        Some(old) => DirtyRect {
            x_min: old.x_min.min(new.x_min),
            y_min: old.y_min.min(new.y_min),
            x_max: old.x_max.max(new.x_max),
            y_max: old.y_max.max(new.y_max),
        },
        None => new,
    });
}
```

`flush_dirty` は dirty rect があればその領域だけ `flush_rect` で転送し、なければ何もしない:

```rust
fn flush_dirty(&mut self) {
    if let Some(dirty) = self.dirty.take() {
        let w = dirty.x_max.saturating_sub(dirty.x_min);
        let h = dirty.y_max.saturating_sub(dirty.y_min);
        if w > 0 && h > 0 {
            self.flush_rect(dirty.x_min, dirty.y_min, w, h);
        }
    }
}
```

### 各描画関数の変更

内部の描画メソッドが `mark_dirty` を呼ぶように変更し、グローバル関数は末尾で `flush_dirty` を呼ぶ統一パターンにした。

| 内部メソッド | mark_dirty の呼び方 |
|-------------|-------------------|
| `draw_char` | `mark_dirty(x, y, 8, 8)` — 文字 1 個分 |
| `erase_char_at_cursor` | `mark_dirty(cursor_x, cursor_y, 8, 8)` |
| `scroll_up` | `mark_dirty(0, 0, width, height)` — 全画面 |
| `clear` | `mark_dirty(0, 0, width, height)` — 全画面 |

| グローバル関数 | Before | After |
|--------------|--------|-------|
| `draw_rect_global` | `flush_rect(x, y, w, h)` | `mark_dirty` + `flush_dirty` |
| `draw_blit_global` | `flush_rect(x, y, w, h)` | `mark_dirty` + `flush_dirty` |
| `draw_pixel_global` | `flush_rect(x, y, 1, 1)` | `mark_dirty` + `flush_dirty` |
| `draw_line_global` | **全画面 `flush()`** | bounding box の `mark_dirty` + `flush_dirty` |
| `draw_text_global` | **全画面 `flush()`** | 各 draw_char の dirty が蓄積 → `flush_dirty` |
| `_print` | 手動スクロール判定 + flush/flush_rect 切替 | `flush_dirty` のみ |

### 特に嬉しい改善

1. **`_print` のスクロール判定ロジックが不要に**: 以前は `y_before` / `y_after` を比較して flush 方法を切り替える手動ロジックがあったが、dirty rect が自動で追跡してくれるので丸ごと削除できた。コードがすっきりした

2. **`draw_line_global` が全画面 flush → bounding box だけに**: Bresenham で描いた直線の範囲は事前に `(x0.min(x1), y0.min(y1))` 〜 `(x0.max(x1), y0.max(y1))` で計算できるので、線が画面の一部にしかない場合は転送量が大幅に減る

3. **`draw_text_global` が全画面 flush → テキスト領域だけに**: 各 `draw_char` が 8x8 の dirty を積み上げ、最後の `flush_dirty` で bounding box だけ転送。短いテキストなら転送量が激減

### 不要になったコード

dirty rect 導入で全画面 `flush()` メソッドの呼び出し箇所がゼロになったので、`flush()` 自体を削除した。`flush_rect()` は `flush_dirty()` の内部から呼ばれるので残っている。

selftest **35/35 PASS**。
