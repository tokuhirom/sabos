# 2026-02-07: Day 7 — dirty rect トラッキング

## 今日の意気込み

昨日はバックバッファ導入 → ネイティブピクセルフォーマット → 行単位 memcpy と描画パイプラインを一気に高速化した。今日はその延長線上で、もう一段描画を賢くしたい。

今日一日、こんなことが出来たらいいな:

1. **dirty rect トラッキング** — 描画操作で変更された領域を自動追跡して、flush 時にその領域だけ MMIO に転送する仕組み。今は各描画関数が個別に flush_rect を呼んでいるけど、dirty rect があれば「複数の描画をまとめて 1 回の flush で済ませる」ことができる

## 完了: dirty rect トラッキングの導入

### 背景

昨日バックバッファを導入して MMIO 転送を一括化したが、まだ改善の余地があった。各描画関数（`draw_rect_global`, `draw_blit_global`, `draw_text_global` 等）が描画直後に個別に `flush_rect()` や `flush()` を呼んでいて、特に `draw_line_global` と `draw_text_global` は **全画面 flush** していた。

`_print` マクロに至っては「スクロールが発生したかどうか」を手動で判定するロジック（描画前後の cursor_y を比較）があり、コードが複雑化していた。

### dirty rect とは

**ダーティ矩形（dirty rectangle）**は「バックバッファのうち、前回の flush 以降に変更された領域」を追跡する手法。ゲームや GUI ツールキットでは定番の最適化テクニックだ。

仕組みはシンプル:
1. 各描画操作が「自分が変更した矩形」を `mark_dirty(x, y, w, h)` で登録
2. 既存の dirty rect があれば、bounding box（両方を包含する最小矩形）に拡張
3. `flush_dirty()` で dirty rect の領域だけを MMIO に転送し、リセット

bounding box 方式なので、離れた 2 つの矩形をマークすると間の未変更領域も転送されてしまう弱点はあるが、実装がシンプルで十分な効果がある。より高度な「矩形リスト」方式は、リスト管理のオーバーヘッドが問題になるので今は採用しない。

### 実装

`FramebufferWriter` に `dirty: Option<DirtyRect>` フィールドを追加した。

```rust
/// ダーティ矩形。変更された領域の境界ボックスを追跡する。
struct DirtyRect {
    x_min: usize,
    y_min: usize,
    x_max: usize, // exclusive
    y_max: usize, // exclusive
}
```

`mark_dirty` は既存の dirty rect と新しい領域の bounding box を計算する:

```rust
fn mark_dirty(&mut self, x: usize, y: usize, w: usize, h: usize) {
    let new = DirtyRect { x_min: x, y_min: y, x_max: (x+w).min(self.width), ... };
    self.dirty = Some(match self.dirty {
        Some(old) => DirtyRect {
            x_min: old.x_min.min(new.x_min),
            y_min: old.y_min.min(new.y_min),
            x_max: old.x_max.max(new.x_max),
            y_max: old.y_max.max(new.y_max),
        },
        None => new,
    });
}
```

`flush_dirty` は dirty rect があればその領域だけ `flush_rect` で転送し、なければ何もしない:

```rust
fn flush_dirty(&mut self) {
    if let Some(dirty) = self.dirty.take() {
        let w = dirty.x_max.saturating_sub(dirty.x_min);
        let h = dirty.y_max.saturating_sub(dirty.y_min);
        if w > 0 && h > 0 {
            self.flush_rect(dirty.x_min, dirty.y_min, w, h);
        }
    }
}
```

### 各描画関数の変更

内部の描画メソッドが `mark_dirty` を呼ぶように変更し、グローバル関数は末尾で `flush_dirty` を呼ぶ統一パターンにした。

| 内部メソッド | mark_dirty の呼び方 |
|-------------|-------------------|
| `draw_char` | `mark_dirty(x, y, 8, 8)` — 文字 1 個分 |
| `erase_char_at_cursor` | `mark_dirty(cursor_x, cursor_y, 8, 8)` |
| `scroll_up` | `mark_dirty(0, 0, width, height)` — 全画面 |
| `clear` | `mark_dirty(0, 0, width, height)` — 全画面 |

| グローバル関数 | Before | After |
|--------------|--------|-------|
| `draw_rect_global` | `flush_rect(x, y, w, h)` | `mark_dirty` + `flush_dirty` |
| `draw_blit_global` | `flush_rect(x, y, w, h)` | `mark_dirty` + `flush_dirty` |
| `draw_pixel_global` | `flush_rect(x, y, 1, 1)` | `mark_dirty` + `flush_dirty` |
| `draw_line_global` | **全画面 `flush()`** | bounding box の `mark_dirty` + `flush_dirty` |
| `draw_text_global` | **全画面 `flush()`** | 各 draw_char の dirty が蓄積 → `flush_dirty` |
| `_print` | 手動スクロール判定 + flush/flush_rect 切替 | `flush_dirty` のみ |

### 特に嬉しい改善

1. **`_print` のスクロール判定ロジックが不要に**: 以前は `y_before` / `y_after` を比較して flush 方法を切り替える手動ロジックがあったが、dirty rect が自動で追跡してくれるので丸ごと削除できた。コードがすっきりした

2. **`draw_line_global` が全画面 flush → bounding box だけに**: Bresenham で描いた直線の範囲は事前に `(x0.min(x1), y0.min(y1))` 〜 `(x0.max(x1), y0.max(y1))` で計算できるので、線が画面の一部にしかない場合は転送量が大幅に減る

3. **`draw_text_global` が全画面 flush → テキスト領域だけに**: 各 `draw_char` が 8x8 の dirty を積み上げ、最後の `flush_dirty` で bounding box だけ転送。短いテキストなら転送量が激減

### 不要になったコード

dirty rect 導入で全画面 `flush()` メソッドの呼び出し箇所がゼロになったので、`flush()` 自体を削除した。`flush_rect()` は `flush_dirty()` の内部から呼ばれるので残っている。

selftest **35/35 PASS**。

## 完了: メモリアロケータ本格化 Phase 1 — 足元の改善

午後はメモリアロケータを本格的な OS レベルに近づけていく作業に着手した。現状のアロケータを調査したところ、カーネルもユーザーも `linked_list_allocator` crate に丸乗り、ヒープは固定サイズ、フレームアロケータは1フレーム単位のビットマップ方式と、改善の余地がかなりあることが分かった。

まずは Phase 1 として「すぐできる足元の改善」を3つ実施した。

### 1a. フレームアロケータの二重解放をパニックに

以前は `deallocate_frame()` で二重解放を検出してもカウンタを増やしてログに出すだけだった。これだとバグがサイレントに進行して、あとから追いかけるのが大変になる。開発段階では即 `panic!` して止まる方がバグを見つけやすいので変更した。

### 1b. ユーザー空間 OOM ハンドラの改善

ユーザープロセスの OOM ハンドラが `loop {}` だった。メモリ確保に失敗してもプロセスが無限ループするだけで、何が起きたか全く分からない。エラーメッセージを出力してから `SYS_EXIT` でプロセスを終了するように改善した。

ちょっとした工夫として、allocator モジュールは各バイナリから `mod allocator;` で取り込まれる構造なので `crate::syscall` を直接呼べない。そのためインラインアセンブリで直接 `int 0x80` を叩いてシステムコールを発行している。

### 1c. リージョン探索の二分探索化

`phys_to_index()` と `index_to_phys()` が毎回全リージョンを線形探索していた。リージョン数が少ないうちは問題ないが、`partition_point` による二分探索に変更して O(N) → O(log N) にした。リージョンを開始アドレス昇順でソートし、プレフィックスサム配列（累積フレーム数）を追加することで実現。

selftest **35/35 PASS**。

## 完了: メモリアロケータ Phase 2 — バディアロケータの導入

Phase 1 で足元を固めたところで、Phase 2 の本命に突入。ビットマップ方式のフレームアロケータを **バディアロケータ（buddy allocator）**に置き換えた。

### バディアロケータとは

バディアロケータは Linux カーネルの物理メモリ管理でも使われている古典的なアルゴリズムだ。メモリを2のべき乗サイズの「ブロック」で管理する。

```
order 0:  4 KiB (1フレーム)
order 1:  8 KiB (2フレーム)
order 2: 16 KiB (4フレーム)
  ...
order 10: 4 MiB (1024フレーム)
```

各 order ごとに「フリーリスト」（空きブロックのリスト）を持つ。割り当て時は要求サイズ以上の最小ブロックを探し、大きすぎれば半分に **分割（split）**する。解放時は隣接する同サイズのブロック（**バディ**）が空いていれば **合体（coalesce）**して、より大きなブロックに昇格させる。

以前のビットマップ方式は1フレーム単位でしか割り当てられなかったが、バディアロケータは **連続した物理フレーム** を確保できる。DMA バッファや大きなページテーブルの確保に将来必要になる。

### バディの計算

バディの計算が面白い。ページオフセット `o` の order `k` ブロックのバディは `o XOR 2^k` で求まる。

```
order 0: offset 0 のバディは 1、offset 1 のバディは 0
order 1: offset 0 のバディは 2、offset 2 のバディは 0
order 2: offset 0 のバディは 4、offset 4 のバディは 0
```

XOR で求まるのは、バディ同士が「2^k ページ境界で交互に並ぶ」という性質による。合体するときは小さい方のオフセットが合体後のブロックの先頭になる。

### 設計: per-region 方式

SABOS の物理メモリは複数の非連続な CONVENTIONAL 領域から成る。バディの合体は連続したアドレス空間内でしか行えないので、**リージョンごとに独立したバディアロケータ**を持つ設計にした。

```
BuddyFrameAllocator
├── RegionBuddyAllocator (0x100000 〜 0x7FF000, 7164 pages)
│   ├── free_lists[0..10]: order ごとのフリーリスト
│   └── bitmap: 1ビット/フレーム
├── RegionBuddyAllocator (0x800000 〜 0x7FFFFFF, ...)
│   ├── free_lists[0..10]
│   └── bitmap
└── ...
```

### 割り当てアルゴリズム

```
allocate(order=2):
  1. free_lists[2] が空なら free_lists[3] を探す → ... → free_lists[10] まで
  2. free_lists[5] にブロック発見（order 5 = 32フレーム）
  3. 分割: order 5 → 4（上半分を free_lists[4] に戻す）
         order 4 → 3（上半分を free_lists[3] に戻す）
         order 3 → 2（上半分を free_lists[2] に戻す）
  4. order 2 ブロック（4フレーム）を返す
```

### 解放・合体アルゴリズム

```
deallocate(addr, order=0):
  1. ビットマップをクリア
  2. バディを計算: offset XOR 1 = バディのオフセット
  3. バディが free_lists[0] にいる → 取り出して合体 → order 1 に昇格
  4. 新しいバディを計算: offset XOR 2
  5. バディが free_lists[1] にいる → 取り出して合体 → order 2 に昇格
  6. ... MAX_ORDER まで繰り返し
  7. 合体できなくなったら free_lists[current_order] に追加
```

### フリーリスト構築

init 時やヒープ領域の予約後にフリーリストを構築する。ビットマップの空きフレームを走査し、各位置で「アライメント制約を満たす最大の order」を求めてフリーリストに登録する。

```
リージョン: 7ページ（全て空き）
  offset 0: order 2 (4ページ、4ページアライン)
  offset 4: order 1 (2ページ、2ページアライン)
  offset 6: order 0 (1ページ)
```

order の判定では「上半分の全フレームが空きか」だけをチェックする最適化を入れた。下半分は前の order で確認済みなので再チェック不要。

### 公開 API

既存の `allocate_frame()` / `deallocate_frame()` はそのまま維持（order 0 の割り当て・解放として動く）。新たに `allocate_order(order)` / `deallocate_order(frame, order)` を追加した。将来 DMA バッファ等で連続フレームが必要になったときに使える。

### ハマりポイント: huge page split と物理アドレスの偶然の一致

バディアロケータの実装自体は一発で動いたが、テストすると init プロセスがページフォルトで落ちた。

```
Page fault in user mode!
  Accessed address: VirtAddr(0x504b90)
  Error code: PROTECTION_VIOLATION | USER_MODE
```

ページテーブルの各レベルをダンプしてみると、L4/L3/L2 はすべて USER_ACCESSIBLE が立っているのに、L1 エントリだけ `PRESENT | WRITABLE`（USER_ACCESSIBLE なし）だった。

原因は `map_user_pages_in_process()` の `is_our_frame` チェックにあった。2MiB huge page を 4KiB に split すると、L1 テーブルの各エントリにアイデンティティマッピング（物理アドレス == 仮想アドレス）が設定される。一方、バディアロケータが別のページのデータ用フレームとして、たまたまこのアイデンティティマッピングと **同じ物理アドレス** を返すことがある。

```
例: バディが物理フレーム 0x504000 を別ページのデータ用に返す
  → allocated_frames に 0x504000 が入る
  → 仮想ページ 0x504000 の L1 エントリは split で物理 0x504000 を指している
  → is_our_frame チェック: allocated_frames に 0x504000 がある → true!
  → 「前のセグメントで設定済み」と誤認 → 新フレーム割り当てをスキップ
  → USER_ACCESSIBLE が設定されないまま
```

ビットマップアロケータでは低アドレスから順に割り当てるため 0x500000 付近のフレームに到達することはなかったが、バディアロケータは分割の関係で高アドレスのフレームを早期に返すため、この衝突が起きた。

修正: `is_our_frame` の条件に「L1 エントリに USER_ACCESSIBLE が設定されているか」のチェックを追加した。split 由来のエントリには USER_ACCESSIBLE がないので、正しく区別できる。

selftest **35/35 PASS**。

## 完了: std 対応 Phase 2 — ファイルシステムの完成

午後はいよいよ std 対応の Phase 2 に突入。`std::fs` / `std::io::Write` / `std::io::Seek` の基盤となるハンドルベースのファイル操作を完成させた。Phase 1（argc/argv/envp + 環境変数）は前日までに完了しているので、ファイル I/O の土台を整える番だ。

### 背景

SABOS のファイルハンドルは Capability-based security で、Handle = (id, token) のペア + 権限ビットで管理される。`handle::read()` は実装済みで pos 管理もあるが、`handle::write()` はスタブ（`NotSupported` を返す）のまま放置されていた。`SYS_OPEN` も WRITE 権限を明示的に拒否していて、ファイルへの書き込みはレガシーなパスベース API（`SYS_FILE_WRITE`）に頼るしかなかった。

std の `std::fs::File` は open → write → seek → close のハンドルベース操作を前提としているので、これを整備しないと先に進めない。

### Task 1: SYS_HANDLE_WRITE の実装

ここが一番面白かった。ファイルの書き込みを **write-back 方式** で実装した。

write-back 方式とは、CPU キャッシュでおなじみの戦略で「書き込みを即座にディスクに反映せず、メモリ上のバッファに書き込んでおいて、close() 時にまとめてフラッシュする」というもの。反対の write-through 方式（書き込みのたびに即ディスクに反映）だと、1バイトごとに FAT32 の delete + create が走ってしまい現実的でない。

```rust
// handle::write() の核心部分
let end = entry.pos + buf.len();
if end > entry.data.len() {
    entry.data.resize(end, 0);  // 必要ならバッファを拡張
}
entry.data[entry.pos..end].copy_from_slice(buf);
entry.pos = end;
entry.dirty = true;  // 「書き込みがあった」マーク
```

`HandleEntry` に `dirty: bool` フラグを追加した。write() のたびにこのフラグが立ち、close() 時に dirty == true かつ path が空でなければ FAT32 に書き戻す。書き戻しは既存の `SYS_FILE_WRITE` と同じパターン（delete + create）を使う。

```rust
// handle::close() でのフラッシュ
if entry.dirty && !entry.path.is_empty() {
    let path = entry.path.clone();
    let data = entry.data.clone();
    table[handle.id as usize] = None;  // 先にテーブルから削除
    drop(table);  // ロック解放（FAT32 操作中のデッドロック回避）
    let mut fat32 = Fat32::new()?;
    let _ = fat32.delete_file(&path);
    fat32.create_file(&path, &data)?;
}
```

ロック順序に注意が必要だった。HANDLE_TABLE のロックを持ったまま FAT32 操作をするとデッドロックの危険がある（FAT32 ドライバ内部でも VirtIO のロックを取る）ので、テーブルからエントリを取り出してロックを解放してから FAT32 操作をする。

`sys_open()` では WRITE 権限の一律拒否を解除した。ただし `/proc` 配下は引き続き書き込み禁止（設計方針通り）。`open_path_to_handle()` も書き換えて、WRITE 権限付きで既存ファイルを開くとデータを読み込んで RW ハンドルを返し、ファイルが存在しない場合は空データの新規ファイルとしてハンドルを作成するようにした。

selftest **36/36 PASS**。

### Task 2: SYS_HANDLE_STAT(77) の実装

ファイルのメタデータを一括取得する syscall。`std::fs::metadata()` に相当する。

```rust
#[repr(C)]
pub struct HandleStat {
    pub size: u64,    // ファイルサイズ
    pub kind: u64,    // 0 = File, 1 = Directory
    pub rights: u64,  // 権限ビット
}
```

内部では既存の `get_size()` / `get_kind()` / `get_rights()` を統合する形で `stat()` 関数を作った。STAT 権限が必要。

### Task 3: SYS_HANDLE_SEEK(78) の実装

ファイルポジションの変更。`std::io::Seek` トレイトの基盤になる。

whence 定数は POSIX と同じセマンティクス:
- `SEEK_SET (0)`: ファイル先頭からの絶対位置
- `SEEK_CUR (1)`: 現在位置からの相対オフセット（負の値あり）
- `SEEK_END (2)`: ファイル末尾からの相対オフセット（負の値あり）

offset は i64 として扱い、SEEK_CUR や SEEK_END で負の値（後ろに戻る）を許可する。範囲外になった場合は 0 〜 ファイルサイズにクランプするので、不正な位置にはならない。

Task 2 と Task 3 はまとめてコミットした。syscall-list.md も更新。

selftest **36/36 PASS**。

### Task 4: selftest 追加

新しく 2 つのテストを `run_fs` に追加。

**test_handle_write**: WRITE 権限で `/HWTEST.TXT` を新規作成 → `"hello"` を書き込み → close（FAT32 にフラッシュ）→ READ で再度 open → 読み返して `"hello"` であることを確認 → close → ファイル削除（クリーンアップ）。write-back 方式の一連の流れを端から端まで検証する。

**test_handle_seek**: `HELLO.TXT` を READ + SEEK + STAT で open → stat でサイズ取得 → 先頭 8 バイト読む → SEEK_SET(0) で先頭に戻す → 再度 8 バイト読む → 同じ内容であることを確認 → close。seek の基本動作を確認する。

selftest **38/38 PASSED**（+2）。

### 今回の設計で特に良かったこと

1. **write-back 方式**: write() のたびに FAT32 に書き戻す write-through ではなく、close() 時に一括フラッシュ。OS のページキャッシュと同じ発想で、パフォーマンスと実装のシンプルさを両立できた

2. **新規ファイル作成の自然な対応**: WRITE 権限付きで存在しないファイルを open すると、空データのハンドルが返る。ユーザーは「open → write → close」だけで新規ファイルを作成できる。`O_CREAT` のようなフラグ地獄を避けて、SABOS らしいシンプルな API にできた

3. **ロック順序の考慮**: HANDLE_TABLE → FAT32 のネストしたロックを避けるため、close() でテーブルからエントリを取り出してからロックを解放し、その後に FAT32 操作を行う設計。デッドロック回避の基本だが、ちゃんと意識できた

### 次のステップ

Phase 2 が完了し、ハンドルベースのファイル I/O が open / read / write / seek / stat / close とフルセットで揃った。次は Phase 3 で `std` 本体のビルドに挑戦する予定。`x86_64-unknown-none` ターゲットで std を動かすには、カスタムの pal (Platform Abstraction Layer) を実装して、今回作ったシステムコール群を繋ぎ込む必要がある。大きな山になりそうだが、土台が整ったので楽しみだ。

## 完了: std 対応 Phase 6 — ネットワーク抽象化ライブラリ（net.rs）

### 背景と動機

shell.rs / httpd.rs / telnetd.rs の 3 つのバイナリにそれぞれ netd IPC クライアントコードが重複していた（合計 ~380 行）。型安全でない生の `conn_id` / `opcode` 操作が各所に散らばっており、`TcpStream` / `TcpListener` のような使いやすい抽象がなかった。

std 対応の一環として、`std::net` 風のソケット抽象化を user 空間ライブラリとして実装した。

### 新規作成: user/src/net.rs

以下の型と関数を提供する共通ネットワークライブラリを作成した:

**アドレス型:**
- `Ipv4Addr` — IPv4 アドレス（std::net::Ipv4Addr 互換風）
- `SocketAddr` — IP + ポート（std::net::SocketAddr 互換風）
- `NetError` — ネットワークエラー型

**高レベル API:**
- `TcpStream` — TCP ストリーム。`connect()` / `write()` / `write_all()` / `read()` を提供し、**Drop で自動クローズ**（RAII パターン）
- `TcpListener` — TCP リスナー。`bind()` / `accept()` / `accept_timeout()` を提供
- `dns_lookup()` — DNS 名前解決
- `init_netd()` / `set_netd_id()` — netd 初期化

**低レベル API（telnetd のセッション管理等向け）:**
- `raw_send()` / `raw_recv()` / `raw_close()` / `raw_listen()` / `raw_accept()` — conn_id を直接操作

内部実装では `netd_request()` が IPC 通信の共通関数を担い、IPC 失敗時の netd ID 再解決 + リトライも自動的に行う。

### 各バイナリの移行

**shell.rs（-191 行）:**
- `cmd_dns` → `net::dns_lookup()`
- `cmd_http` → `TcpStream::connect()` + `stream.write()` / `stream.read()`
- `cmd_nc` → クライアントは `TcpStream::connect`、サーバーは `TcpListener::bind` + `accept`
- `nc_relay_loop` → `net::raw_send` / `net::raw_recv`（低レベル操作のため raw API 使用）

**httpd.rs（-145 行）:**
- `httpd_main` → `net::init_netd()` + `TcpListener::bind(port)` + `listener.accept()`
- `handle_connection` → 引数を `TcpStream` に変更、Drop で自動クローズ
- `send_*_response` → `stream.write_all()` 使用

**telnetd.rs（-142 行）:**
- セッション管理のため `conn_id` を直接操作する必要があり、`TcpStream` / `TcpListener` ではなく raw API を使用
- `netd_tcp_send/recv/close/listen/accept` → `net::raw_send/recv/close/listen/accept`

### selftest

ユーザーシェルに `selftest_net` コマンドを追加:
1. `net_init_netd` — netd 初期化の確認
2. `net_addr_types` — Ipv4Addr / SocketAddr の基本操作確認
3. `net_dns_lookup` — DNS 名前解決（example.com）
4. `net_tcp_http_get` — TcpStream::connect + HTTP GET のエンドツーエンド確認

テストスクリプトにも `selftest_net` の実行を追加（ネットワーク環境依存のため WARN 表示）。

カーネル selftest **40/40 PASSED**。

### Drop で自動クローズが嬉しい

今回の設計で特に良かったのは `TcpStream` の RAII パターン。以前は各関数の `return` 前に `netd_tcp_close(conn_id)` を手動で呼ぶ必要があり、エラーパスで忘れるとコネクションリークが起きる可能性があった。Drop で自動クローズすることで、httpd の `handle_connection` がすっきりした:

```rust
// Before: 6箇所で手動 close が必要
fn handle_connection(netd_id: u64, conn_id: u32) {
    // ...各エラーパスで netd_tcp_close(netd_id, conn_id) を呼ぶ必要
}

// After: Drop に任せる
fn handle_connection(stream: net::TcpStream) {
    // ...return するだけで stream が自動クローズ
}
```

telnetd のように conn_id のライフサイクルを自分で管理したい場合は raw API を使えるので、柔軟性も確保できている。

## 完了: std 対応 Phase 7 — カスタムターゲットと `-Zbuild-std`

### 背景

std 対応の最終段階。Phase 1〜6 で必要なシステムコールとユーザー空間ライブラリは整った。Phase 7 では Rust の `std` クレートを SABOS 向けにビルドし、ユーザープログラムで `fn main()` と std の型（String, Vec 等）を使えるようにする。

### やったこと

#### 1. カスタムターゲット JSON の作成

`x86_64-sabos.json` を作成した。`x86_64-unknown-none` をベースに以下を変更:
- `"os": "sabos"` — PAL の選択に使われる
- `"has-thread-local": false` — ELF TLS 未対応のため `no_threads` TLS を使う
- `"panic-strategy": "abort"` — スタックアンワインド不要
- `"features": "+sse,+sse2"` — 浮動小数点演算を有効化
- `"metadata": { "std": true }` — std をビルド可能にするマーカー

`target-pointer-width` は整数型 (`64`) で指定する必要があった。文字列 `"64"` にするとビルドエラーになる。

#### 2. sysroot パッチファイル

`rust-std-sabos/` ディレクトリに以下のファイルを作成:

| ファイル | 役割 |
|---------|------|
| `sys_pal_sabos_mod.rs` | PAL モジュールエントリ |
| `sys_pal_sabos_common.rs` | init/cleanup/abort/_start |
| `sys_pal_sabos_os.rs` | exit(SYS_EXIT), getpid(SYS_GETPID) |
| `sys_alloc_sabos.rs` | GlobalAlloc (SYS_MMAP/SYS_MUNMAP) |
| `sys_stdio_sabos.rs` | Stdout/Stdin (SYS_WRITE/SYS_READ) |
| `sys_random_sabos.rs` | fill_bytes (SYS_GETRANDOM) |

PAL の `_start` は `main(0, null)` を呼んで、戻り値で `SYS_EXIT` する:

```rust
#[unsafe(no_mangle)]
pub unsafe extern "C" fn _start() -> ! {
    unsafe extern "C" { fn main(argc: isize, argv: *const *const u8) -> i32; }
    let result = unsafe { main(0, core::ptr::null()) };
    unsafe { core::arch::asm!("int 0x80", in("rax") 60u64, in("rdi") result as u64, options(noreturn)); }
}
```

#### 3. sysroot パッチ適用スクリプト

`scripts/patch-rust-sysroot.sh` と `scripts/apply-sysroot-patches.py` を作成。Python スクリプトで sysroot の既存ファイルにパッチを正確に挿入する。idempotent 設計で、既にパッチ済みならスキップする。

パッチ対象:
- `sys/pal/mod.rs` — `target_os = "sabos"` ブランチ追加
- `sys/alloc/mod.rs` — sabos アロケータブランチ追加
- `sys/stdio/mod.rs` — sabos stdio ブランチ追加
- `sys/thread_local/mod.rs` — `no_threads` 条件に sabos 追加
- `sys/env_consts.rs` — OS 名等の定数追加
- `sys/io/error/mod.rs` — generic エラーグループに sabos 追加
- `sys/random/mod.rs` — sabos 乱数ブランチ追加

#### 4. user-std クレート

既存の `user/` (no_std) とは別に `user-std/` を作成。`.cargo/config.toml` で `-Zbuild-std` を設定:

```toml
[unstable]
build-std = ["core", "alloc", "std", "panic_abort", "compiler_builtins"]
build-std-features = ["compiler-builtins-mem"]
```

`compiler-builtins-mem` は memset/memcpy/memmove/memcmp を提供する feature で、これがないとリンクエラーになる。

### ハマりポイント

たくさんハマった。

**1. パッチの挿入位置ミス（sed → Python 移行）**

最初は sed でパッチを挿入していたが、`cfg_select!` マクロのネストが深く、正しい位置に挿入するのが困難だった。たとえば `alloc/mod.rs` の `cfg_select!` のクロージングブレースを見つけるつもりが、`realloc_fallback` 関数の中に挿入してしまった。Python スクリプトに切り替えて、ブレースの深さをトラッキングしながら正確な位置を特定するようにした。

**2. debug ビルドの OOM**

debug ビルドの ELF バイナリは **6.4MB** あり、カーネルが `read_file()` で全体を `Vec<u8>` に読み込む際に 8MB の連続アロケーションが要求され、16MB のカーネルヒープでは確保できずに OOM になった。

解決: release ビルド（`opt-level = "z"` + LTO + strip）にすることで **29KB** まで削減。6.4MB → 29KB、200倍以上の圧縮。

**3. SYS_MMAP がハングする問題（未解決）**

std の `println!` → `stdout()` → `OnceLock::get_or_init()` → `LineWriter::new()` の初期化パスで `System::alloc()` が呼ばれ、SYS_MMAP が発行される。この syscall が**応答を返さない**問題が発生した。

原因の調査:
- `_start` → `main()` は正常に呼ばれる
- `raw_write()` で直接 `int 0x80` の SYS_WRITE は正常に動く
- `SYS_MMAP` を直接 inline asm で呼ぶと応答が返らない

SABOS の既存 selftest では SYS_MMAP は正常に PASS する（shell プロセスからの呼び出し）ので、**exec で spawn されたプロセスからの SYS_MMAP** に何らかの問題がある可能性が高い。

暫定対応: `raw_write()` で直接 SYS_WRITE を呼んで出力する方式に変更。std のビルドとリンクは成功し、`fn main()` でプログラムが動作する状態を確認。アロケータ（Vec/String 等）と println! は今後の課題として残す。

**4. その他の小さなハマり**

- `panic_immediate_abort` が feature から panic strategy に変更されていた
- `io/error/mod.rs` にデフォルト `_ =>` がなく、sabos が generic グループに必要だった
- `random/mod.rs` の `fill_bytes` が未定義 → `sys_random_sabos.rs` を追加
- `#![feature(restricted_std)]` が必要
- `panic_abort` と `compiler_builtins` を build-std リストに追加する必要あり

### テスト

`run-selftest.sh` に HELLOSTD.ELF のテストを追加:
- `run /hellostd.elf` を実行
- "Hello from SABOS std!" が出力されることを確認
- `send_string` 関数に `/` → `slash`、`.` → `dot` のマッピングを追加（QEMU monitor の sendkey 対応）

結果: HELLOSTD.ELF test PASSED、カーネル selftest **40/40 PASSED**。

### 達成したこと

- `fn main()` で書ける std 対応バイナリが SABOS 上で動く
- `-Zbuild-std` で std クレートを SABOS 向けにビルドできる
- 既存の no_std バイナリは影響を受けない（user-std は別クレート）
- テストでの回帰なし

### 残課題

1. **SYS_MMAP の問題を解決して println!/Vec/String を使えるようにする** — exec で spawn されたプロセスからの MMAP が応答しない原因を特定する必要がある
2. **sysroot パッチの管理** — nightly 更新でパッチが壊れる可能性。`rust-toolchain.toml` でバージョン固定する
