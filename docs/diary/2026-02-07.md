# 2026-02-07: Day 7 — dirty rect トラッキング

## 今日の意気込み

昨日はバックバッファ導入 → ネイティブピクセルフォーマット → 行単位 memcpy と描画パイプラインを一気に高速化した。今日はその延長線上で、もう一段描画を賢くしたい。

今日一日、こんなことが出来たらいいな:

1. **dirty rect トラッキング** — 描画操作で変更された領域を自動追跡して、flush 時にその領域だけ MMIO に転送する仕組み。今は各描画関数が個別に flush_rect を呼んでいるけど、dirty rect があれば「複数の描画をまとめて 1 回の flush で済ませる」ことができる

## 完了: dirty rect トラッキングの導入

### 背景

昨日バックバッファを導入して MMIO 転送を一括化したが、まだ改善の余地があった。各描画関数（`draw_rect_global`, `draw_blit_global`, `draw_text_global` 等）が描画直後に個別に `flush_rect()` や `flush()` を呼んでいて、特に `draw_line_global` と `draw_text_global` は **全画面 flush** していた。

`_print` マクロに至っては「スクロールが発生したかどうか」を手動で判定するロジック（描画前後の cursor_y を比較）があり、コードが複雑化していた。

### dirty rect とは

**ダーティ矩形（dirty rectangle）**は「バックバッファのうち、前回の flush 以降に変更された領域」を追跡する手法。ゲームや GUI ツールキットでは定番の最適化テクニックだ。

仕組みはシンプル:
1. 各描画操作が「自分が変更した矩形」を `mark_dirty(x, y, w, h)` で登録
2. 既存の dirty rect があれば、bounding box（両方を包含する最小矩形）に拡張
3. `flush_dirty()` で dirty rect の領域だけを MMIO に転送し、リセット

bounding box 方式なので、離れた 2 つの矩形をマークすると間の未変更領域も転送されてしまう弱点はあるが、実装がシンプルで十分な効果がある。より高度な「矩形リスト」方式は、リスト管理のオーバーヘッドが問題になるので今は採用しない。

### 実装

`FramebufferWriter` に `dirty: Option<DirtyRect>` フィールドを追加した。

```rust
/// ダーティ矩形。変更された領域の境界ボックスを追跡する。
struct DirtyRect {
    x_min: usize,
    y_min: usize,
    x_max: usize, // exclusive
    y_max: usize, // exclusive
}
```

`mark_dirty` は既存の dirty rect と新しい領域の bounding box を計算する:

```rust
fn mark_dirty(&mut self, x: usize, y: usize, w: usize, h: usize) {
    let new = DirtyRect { x_min: x, y_min: y, x_max: (x+w).min(self.width), ... };
    self.dirty = Some(match self.dirty {
        Some(old) => DirtyRect {
            x_min: old.x_min.min(new.x_min),
            y_min: old.y_min.min(new.y_min),
            x_max: old.x_max.max(new.x_max),
            y_max: old.y_max.max(new.y_max),
        },
        None => new,
    });
}
```

`flush_dirty` は dirty rect があればその領域だけ `flush_rect` で転送し、なければ何もしない:

```rust
fn flush_dirty(&mut self) {
    if let Some(dirty) = self.dirty.take() {
        let w = dirty.x_max.saturating_sub(dirty.x_min);
        let h = dirty.y_max.saturating_sub(dirty.y_min);
        if w > 0 && h > 0 {
            self.flush_rect(dirty.x_min, dirty.y_min, w, h);
        }
    }
}
```

### 各描画関数の変更

内部の描画メソッドが `mark_dirty` を呼ぶように変更し、グローバル関数は末尾で `flush_dirty` を呼ぶ統一パターンにした。

| 内部メソッド | mark_dirty の呼び方 |
|-------------|-------------------|
| `draw_char` | `mark_dirty(x, y, 8, 8)` — 文字 1 個分 |
| `erase_char_at_cursor` | `mark_dirty(cursor_x, cursor_y, 8, 8)` |
| `scroll_up` | `mark_dirty(0, 0, width, height)` — 全画面 |
| `clear` | `mark_dirty(0, 0, width, height)` — 全画面 |

| グローバル関数 | Before | After |
|--------------|--------|-------|
| `draw_rect_global` | `flush_rect(x, y, w, h)` | `mark_dirty` + `flush_dirty` |
| `draw_blit_global` | `flush_rect(x, y, w, h)` | `mark_dirty` + `flush_dirty` |
| `draw_pixel_global` | `flush_rect(x, y, 1, 1)` | `mark_dirty` + `flush_dirty` |
| `draw_line_global` | **全画面 `flush()`** | bounding box の `mark_dirty` + `flush_dirty` |
| `draw_text_global` | **全画面 `flush()`** | 各 draw_char の dirty が蓄積 → `flush_dirty` |
| `_print` | 手動スクロール判定 + flush/flush_rect 切替 | `flush_dirty` のみ |

### 特に嬉しい改善

1. **`_print` のスクロール判定ロジックが不要に**: 以前は `y_before` / `y_after` を比較して flush 方法を切り替える手動ロジックがあったが、dirty rect が自動で追跡してくれるので丸ごと削除できた。コードがすっきりした

2. **`draw_line_global` が全画面 flush → bounding box だけに**: Bresenham で描いた直線の範囲は事前に `(x0.min(x1), y0.min(y1))` 〜 `(x0.max(x1), y0.max(y1))` で計算できるので、線が画面の一部にしかない場合は転送量が大幅に減る

3. **`draw_text_global` が全画面 flush → テキスト領域だけに**: 各 `draw_char` が 8x8 の dirty を積み上げ、最後の `flush_dirty` で bounding box だけ転送。短いテキストなら転送量が激減

### 不要になったコード

dirty rect 導入で全画面 `flush()` メソッドの呼び出し箇所がゼロになったので、`flush()` 自体を削除した。`flush_rect()` は `flush_dirty()` の内部から呼ばれるので残っている。

selftest **35/35 PASS**。

## 完了: メモリアロケータ本格化 Phase 1 — 足元の改善

午後はメモリアロケータを本格的な OS レベルに近づけていく作業に着手した。現状のアロケータを調査したところ、カーネルもユーザーも `linked_list_allocator` crate に丸乗り、ヒープは固定サイズ、フレームアロケータは1フレーム単位のビットマップ方式と、改善の余地がかなりあることが分かった。

まずは Phase 1 として「すぐできる足元の改善」を3つ実施した。

### 1a. フレームアロケータの二重解放をパニックに

以前は `deallocate_frame()` で二重解放を検出してもカウンタを増やしてログに出すだけだった。これだとバグがサイレントに進行して、あとから追いかけるのが大変になる。開発段階では即 `panic!` して止まる方がバグを見つけやすいので変更した。

### 1b. ユーザー空間 OOM ハンドラの改善

ユーザープロセスの OOM ハンドラが `loop {}` だった。メモリ確保に失敗してもプロセスが無限ループするだけで、何が起きたか全く分からない。エラーメッセージを出力してから `SYS_EXIT` でプロセスを終了するように改善した。

ちょっとした工夫として、allocator モジュールは各バイナリから `mod allocator;` で取り込まれる構造なので `crate::syscall` を直接呼べない。そのためインラインアセンブリで直接 `int 0x80` を叩いてシステムコールを発行している。

### 1c. リージョン探索の二分探索化

`phys_to_index()` と `index_to_phys()` が毎回全リージョンを線形探索していた。リージョン数が少ないうちは問題ないが、`partition_point` による二分探索に変更して O(N) → O(log N) にした。リージョンを開始アドレス昇順でソートし、プレフィックスサム配列（累積フレーム数）を追加することで実現。

selftest **35/35 PASS**。

## 完了: メモリアロケータ Phase 2 — バディアロケータの導入

Phase 1 で足元を固めたところで、Phase 2 の本命に突入。ビットマップ方式のフレームアロケータを **バディアロケータ（buddy allocator）**に置き換えた。

### バディアロケータとは

バディアロケータは Linux カーネルの物理メモリ管理でも使われている古典的なアルゴリズムだ。メモリを2のべき乗サイズの「ブロック」で管理する。

```
order 0:  4 KiB (1フレーム)
order 1:  8 KiB (2フレーム)
order 2: 16 KiB (4フレーム)
  ...
order 10: 4 MiB (1024フレーム)
```

各 order ごとに「フリーリスト」（空きブロックのリスト）を持つ。割り当て時は要求サイズ以上の最小ブロックを探し、大きすぎれば半分に **分割（split）**する。解放時は隣接する同サイズのブロック（**バディ**）が空いていれば **合体（coalesce）**して、より大きなブロックに昇格させる。

以前のビットマップ方式は1フレーム単位でしか割り当てられなかったが、バディアロケータは **連続した物理フレーム** を確保できる。DMA バッファや大きなページテーブルの確保に将来必要になる。

### バディの計算

バディの計算が面白い。ページオフセット `o` の order `k` ブロックのバディは `o XOR 2^k` で求まる。

```
order 0: offset 0 のバディは 1、offset 1 のバディは 0
order 1: offset 0 のバディは 2、offset 2 のバディは 0
order 2: offset 0 のバディは 4、offset 4 のバディは 0
```

XOR で求まるのは、バディ同士が「2^k ページ境界で交互に並ぶ」という性質による。合体するときは小さい方のオフセットが合体後のブロックの先頭になる。

### 設計: per-region 方式

SABOS の物理メモリは複数の非連続な CONVENTIONAL 領域から成る。バディの合体は連続したアドレス空間内でしか行えないので、**リージョンごとに独立したバディアロケータ**を持つ設計にした。

```
BuddyFrameAllocator
├── RegionBuddyAllocator (0x100000 〜 0x7FF000, 7164 pages)
│   ├── free_lists[0..10]: order ごとのフリーリスト
│   └── bitmap: 1ビット/フレーム
├── RegionBuddyAllocator (0x800000 〜 0x7FFFFFF, ...)
│   ├── free_lists[0..10]
│   └── bitmap
└── ...
```

### 割り当てアルゴリズム

```
allocate(order=2):
  1. free_lists[2] が空なら free_lists[3] を探す → ... → free_lists[10] まで
  2. free_lists[5] にブロック発見（order 5 = 32フレーム）
  3. 分割: order 5 → 4（上半分を free_lists[4] に戻す）
         order 4 → 3（上半分を free_lists[3] に戻す）
         order 3 → 2（上半分を free_lists[2] に戻す）
  4. order 2 ブロック（4フレーム）を返す
```

### 解放・合体アルゴリズム

```
deallocate(addr, order=0):
  1. ビットマップをクリア
  2. バディを計算: offset XOR 1 = バディのオフセット
  3. バディが free_lists[0] にいる → 取り出して合体 → order 1 に昇格
  4. 新しいバディを計算: offset XOR 2
  5. バディが free_lists[1] にいる → 取り出して合体 → order 2 に昇格
  6. ... MAX_ORDER まで繰り返し
  7. 合体できなくなったら free_lists[current_order] に追加
```

### フリーリスト構築

init 時やヒープ領域の予約後にフリーリストを構築する。ビットマップの空きフレームを走査し、各位置で「アライメント制約を満たす最大の order」を求めてフリーリストに登録する。

```
リージョン: 7ページ（全て空き）
  offset 0: order 2 (4ページ、4ページアライン)
  offset 4: order 1 (2ページ、2ページアライン)
  offset 6: order 0 (1ページ)
```

order の判定では「上半分の全フレームが空きか」だけをチェックする最適化を入れた。下半分は前の order で確認済みなので再チェック不要。

### 公開 API

既存の `allocate_frame()` / `deallocate_frame()` はそのまま維持（order 0 の割り当て・解放として動く）。新たに `allocate_order(order)` / `deallocate_order(frame, order)` を追加した。将来 DMA バッファ等で連続フレームが必要になったときに使える。

### ハマりポイント: huge page split と物理アドレスの偶然の一致

バディアロケータの実装自体は一発で動いたが、テストすると init プロセスがページフォルトで落ちた。

```
Page fault in user mode!
  Accessed address: VirtAddr(0x504b90)
  Error code: PROTECTION_VIOLATION | USER_MODE
```

ページテーブルの各レベルをダンプしてみると、L4/L3/L2 はすべて USER_ACCESSIBLE が立っているのに、L1 エントリだけ `PRESENT | WRITABLE`（USER_ACCESSIBLE なし）だった。

原因は `map_user_pages_in_process()` の `is_our_frame` チェックにあった。2MiB huge page を 4KiB に split すると、L1 テーブルの各エントリにアイデンティティマッピング（物理アドレス == 仮想アドレス）が設定される。一方、バディアロケータが別のページのデータ用フレームとして、たまたまこのアイデンティティマッピングと **同じ物理アドレス** を返すことがある。

```
例: バディが物理フレーム 0x504000 を別ページのデータ用に返す
  → allocated_frames に 0x504000 が入る
  → 仮想ページ 0x504000 の L1 エントリは split で物理 0x504000 を指している
  → is_our_frame チェック: allocated_frames に 0x504000 がある → true!
  → 「前のセグメントで設定済み」と誤認 → 新フレーム割り当てをスキップ
  → USER_ACCESSIBLE が設定されないまま
```

ビットマップアロケータでは低アドレスから順に割り当てるため 0x500000 付近のフレームに到達することはなかったが、バディアロケータは分割の関係で高アドレスのフレームを早期に返すため、この衝突が起きた。

修正: `is_our_frame` の条件に「L1 エントリに USER_ACCESSIBLE が設定されているか」のチェックを追加した。split 由来のエントリには USER_ACCESSIBLE がないので、正しく区別できる。

selftest **35/35 PASS**。
