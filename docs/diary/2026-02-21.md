# 2026-02-21: VMA（仮想メモリ領域）管理の実装

## 今日の目標

メモリ管理の Phase 4 として VMA（Virtual Memory Area）管理を導入する。プロセスのアドレス空間を VMA のリストとして構造化し、mmap/munmap を VMA ベースに書き換える。これまで `find_free_mmap_region()` がページテーブルを全走査して空き領域を探していた非効率な実装を、VMA リストの隙間探索に置き換えるのが主な目的。

---

## VMA とは

VMA（Virtual Memory Area）は、プロセスの仮想アドレス空間における「連続した領域」を表すデータ構造。Linux カーネルでも同名の概念があり、`/proc/PID/maps` で確認できるアレの元になるもの。各 VMA は開始・終了アドレス、アクセス権限（読み取り/書き込み/実行）、用途（ELF ロード、スタック、匿名マッピング等）を持つ。

VMA リストがあると何が嬉しいか:
- **空き領域の検索が速い**: ページテーブルの全エントリを走査する O(ページ数) から、VMA の隙間を見る O(VMA 数) に改善。VMA は通常数十程度なので桁違いに速い
- **メモリレイアウトの可視化**: `/proc/maps` でプロセスのメモリマップを一覧できる
- **部分的な munmap**: VMA を分割することで、マッピングの一部だけを解除できる
- **将来の Demand Paging の基盤**: ページフォルト時に「このアドレスはどの VMA に属するか」を引ける

## 実装の詳細

### Step 1: `kernel/src/vma.rs` 新規作成

VMA の核となるデータ構造を作った。

```rust
pub enum VmaKind { Anonymous, ElfLoad, UserStack }

pub struct VmaProt { pub read: bool, pub write: bool, pub execute: bool }

pub struct Vma {
    pub start: u64,   // 開始アドレス（4KiB アライン、包含的）
    pub end: u64,     // 終了アドレス（4KiB アライン、排他的）
    pub prot: VmaProt,
    pub kind: VmaKind,
    pub name: String, // デバッグ用: ".text", "[stack]", "[anon]" 等
}

pub struct VmaList {
    vmas: Vec<Vma>,   // start 昇順ソート
}
```

内部表現は `Vec<Vma>` のソート済みリスト。BTreeMap ではなく Vec を選んだのは、VMA 数が数十程度で線形探索で十分な性能が出ること、コードの見通しが良いこと、部分分割の操作が直感的に書けることが理由。

VmaList のメソッド:
- `insert(vma)`: 重複チェック + 二分探索で挿入位置を決定してソート順維持
- `find_free_region(size, base, limit)`: first-fit 方式で VMA の隙間から空き領域を探索
- `remove_range(start, end)`: 4 パターンの分割処理（完全削除/先頭切り取り/末尾切り取り/中央分割）

### Step 2: selftest に VMA 単体テスト追加（4 項目）

VMA ロジックの正しさを確認するために 4 つのテストを追加:
- `vma_insert`: 3 つの VMA を挿入してソート順が維持されることを確認
- `vma_find_free`: 既存 VMA の隙間から正しいアドレスが返ることを確認
- `vma_remove_range`: 完全削除・先頭切り取り・末尾切り取り・中央分割の 4 パターンを網羅
- `vma_overlap_reject`: 重なる VMA の追加が Err で拒否されることを確認

### Step 3: UserProcess に VmaList を統合

`UserProcess` に `vma_list: VmaList` フィールドを追加。ELF プロセス作成時に各 LOAD セグメントとユーザースタックの VMA を自動登録するようにした。ELF セグメントの名前は権限フラグから推定している（r-x → ".text"、r-- → ".rodata"、rw- → ".data"）。

scheduler.rs に VMA 操作のヘルパー関数を 4 つ追加:
- `find_free_vma_region()`: 現在タスクの VmaList で空き領域探索
- `add_vma_to_current()`: VMA 追加
- `remove_vma_range_from_current()`: VMA 範囲削除
- `get_vma_list_for_task()`: procfs 用（指定タスクの VMA リストをクローンして返す）

### Step 4: mmap/munmap を VMA ベースに切り替え

ここが本命。`sys_mmap()` を書き換えて:
- **旧**: `find_free_mmap_region(l4_frame, num_pages)` — L4 ページテーブルから L1 まで 4 段降りてマップ済みかチェックする O(ページ数) の走査
- **新**: `scheduler::find_free_vma_region(size, base, limit)` — VMA リストの隙間を O(VMA 数) で探索

マッピング成功後に `add_vma_to_current()` で VMA を登録。`sys_munmap()` では `remove_vma_range_from_current()` で VMA を削除してからページをアンマップ。

旧実装の `find_free_mmap_region()` と `is_page_mapped()` は完全に削除。合わせて 80 行以上のページテーブル走査コードがなくなり、すっきりした。

### Step 5: procfs に `/proc/maps` 追加

`/proc/maps` を読むと全ユーザープロセスの VMA 情報が JSON で出力される:

```json
{"processes":[
  {"id":1,"name":"SHELL.ELF","vmas":[
    {"start":"0x400000","end":"0x401000","size":4096,"prot":"r-x","kind":"ElfLoad","name":".text"},
    {"start":"0x600000","end":"0x601000","size":4096,"prot":"rw-","kind":"ElfLoad","name":".data"},
    {"start":"0x2000000","end":"0x2010000","size":65536,"prot":"rw-","kind":"UserStack","name":"[stack]"}
  ]}
]}
```

selftest に `procfs_maps` テストも追加して、`/proc/maps` が正常に JSON を返すことを確認。

---

## テスト結果

全 6 ステップを通して、各段階で `make test` を実行して全テスト PASS を確認した:
- Step 2 完了時: **69/69 PASSED**（VMA テスト 4 項目追加）
- Step 5 完了時: **70/70 PASSED**（procfs_maps テスト追加）

ビルド警告もゼロ。既存の mmap テストも VMA ベースの新実装で問題なく通っている。

## 設計判断の記録

### `allocated_frames` は残す

VMA を導入しても `UserProcess.allocated_frames`（物理フレームのリスト）は削除しない。VMA は「このアドレス範囲に何がマッピングされているか」という意図の記録、`allocated_frames` は「このプロセスが所有する物理フレーム」の記録で、役割が異なる。将来 Demand Paging を実装するとき、VMA はあるがまだ物理フレームを割り当てていない（= ページフォルト待ち）という状態が生まれるので、この分離が重要になる。

### Vec + 二分探索を選んだ理由

VMA 数は通常数十程度。BTreeMap のようなバランス木は O(log n) だが、n が小さいと定数項のオーバーヘッドで Vec の線形探索に負ける。また、`remove_range()` での分割処理は Vec の方が直感的に書ける。将来 VMA 数が数千になったら BTreeMap への移行を検討するが、今のところ不要。

---

## 開発サイクルの振り返り

- VMA の実装は段階的に進められた。Step 1-2 で VMA ロジックの単体テスト、Step 3 で統合、Step 4 で実際の切り替え、Step 5 で可視化。各段階でテストが通ることを確認しながら進められたので安心感があった
- `find_free_mmap_region` の削除で 80 行以上のページテーブル走査コードがなくなった。VMA リストという適切な抽象化を入れることで、コード量が減って可読性も上がるのは気持ちいい
- dead code 警告を段階的に解消していくのが少し面倒だった。Step 3 で関数を追加しても Step 4 まで使われないので警告が出る。最終的にはゼロになったが、途中段階での警告は「まだ使ってないだけ」と分かっていても気になる
