# 2026-02-02: Day 2 — メモリ管理の強化とタスクの世界へ

Day 1 ではブートからシェルまで一気に駆け抜けた。今日はカーネルの内部をもっと「ちゃんとした OS」に近づけていく。

## 今日のゴール

1. **ビットマップアロケータ**: バンプ方式の物理フレームアロケータをビットマップ方式に置き換える。フレームの解放ができるようになり、メモリの再利用が可能に
2. **プロセス / タスクの基盤**: カーネルタスクの概念を導入し、コンテキストスイッチの基盤を作る。最終的には複数タスクの協調的マルチタスクを目指す

Day 1 の「次にやりたいこと」リストをそのまま消化していく形。

## 実装計画

### Task 1: ビットマップフレームアロケータ

現在の `BumpFrameAllocator` はフレームの解放ができない。ビットマップ方式に置き換えて `deallocate_frame()` を追加する。

**変更ファイル:**
- `kernel/src/memory.rs` — `BumpFrameAllocator` → `BitmapFrameAllocator` に置き換え
  - ビットマップ (`Vec<u64>`) で各フレームの使用/空き状態を管理。1ビット = 1フレーム
  - `allocate_frame()`: ビットマップから空きビットを探してセット
  - `deallocate_frame()`: 指定フレームのビットをクリア
  - `free_frames()`: 空きフレーム数を返す統計関数
  - 既存の `MemoryRegion` / `FRAME_ALLOCATOR` / `init()` のインターフェースは維持
- `kernel/src/shell.rs` — `mem` コマンドで空きフレーム数も表示

### Task 2: 協調的マルチタスク — タスク構造体とスケジューラ

カーネルタスクの概念を導入する。各タスクは独自のスタックを持ち、`yield` で自発的に CPU を譲る（協調的マルチタスク）。

**変更ファイル:**
- `kernel/src/task.rs` (新規) — タスクの定義
  - `Task` 構造体: タスク ID、状態、スタック、コンテキスト（レジスタ保存領域）
  - `TaskState`: Running / Ready / Finished
  - `Context` 構造体: callee-saved レジスタ (rbx, rbp, r12-r15, rsp) の保存領域
- `kernel/src/scheduler.rs` (新規) — ラウンドロビンスケジューラ
  - タスクキュー (`VecDeque<Task>`)
  - `spawn()`: 新しいタスクを登録
  - `schedule()`: 次のタスクに切り替え
  - `context_switch()`: アセンブリでレジスタ退避/復帰（`naked_fn` or グローバルアセンブリ）
- `kernel/src/main.rs` — `mod task; mod scheduler;` 追加、デモタスクを生成して動作確認
- `kernel/src/shell.rs` — `ps` コマンドでタスク一覧を表示

### Task 3: プリエンプティブマルチタスク（タイマー割り込みベース）

タイマー割り込み (IRQ 0) でスケジューラを呼び出し、タスクを強制切り替えする。

**変更ファイル:**
- `kernel/src/interrupts.rs` — タイマー割り込みハンドラから `scheduler::preempt()` を呼ぶ。PIC マスクの明示的設定も追加
- `kernel/src/scheduler.rs` — `preempt()` 関数を追加（`try_lock` でデッドロック回避）
- `kernel/src/main.rs` — プリエンプティブデモタスク（yield を使わないビジーループ）を追加

## 実装ログ

### Task 1: ビットマップフレームアロケータ ✅

`BumpFrameAllocator` を `BitmapFrameAllocator` に置き換え。1ビット=1フレームのビットマップで管理し、`deallocate_frame()` でフレームの解放が可能に。`(!word).trailing_zeros()` で高速に空きビットを探索する。`mem` コマンドで空きフレーム数も表示するようにした。

### Task 2: 協調的マルチタスク ✅

`scheduler.rs` に `global_asm!` でコンテキストスイッチを実装。Microsoft x64 ABI の callee-saved レジスタ (rbx, rbp, rdi, rsi, r12-r15) を push/pop してスタックポインタを切り替える。`task_trampoline` が新タスクの初回起動を担当し、r12 に入れたエントリ関数を `call r12` で呼び出す。デモタスク A/B が交互にメッセージを出力して協調的マルチタスクの動作を確認した。

### Task 3: プリエンプティブマルチタスク ✅

タイマー割り込み (IRQ 0) からスケジューラを呼び出し、タスクを強制切り替えする。

**ハマったポイント:**

1. **PIC マスク問題**: UEFI が IRQ 0（タイマー）をマスクしていた。`pic8259` の `initialize()` は初期化前のマスクを復元するため、UEFI のマスク設定がそのまま残ってしまう。`write_masks(0xFC, 0xFF)` で明示的にタイマーとキーボードをアンマスクする必要があった。timer ticks カウンターを追加して「タイマーが一度も発火していない」ことを発見し、原因を特定できた。

2. **task_trampoline の sti**: `yield_now()` は割り込みを無効化してから `context_switch` するため、新タスクが初めて実行される時は割り込みが無効のまま。`task_trampoline` の先頭に `sti` を追加して、エントリ関数の実行前に割り込みを有効化する。

3. **preempt() のデッドロック回避**: `try_lock()` を使い、SCHEDULER のロック保持中にタイマーが発火した場合はプリエンプションをスキップ。次のタイマーで再試行する。

4. **EOI の順序**: EOI を `context_switch` の前に送る。後に送ると、切り替え先タスクがタイマー割り込みを受け取れなくなる。

**結果:** yield を呼ばないビジーループタスクが交互に実行されることを確認。timer ticks: ~158, preempt switches: ~157。

![プリエンプティブマルチタスク](images/preemptive.png)
