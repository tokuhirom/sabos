# 2026-02-02: Day 2 — メモリ管理の強化とタスクの世界へ

Day 1 ではブートからシェルまで一気に駆け抜けた。今日はカーネルの内部をもっと「ちゃんとした OS」に近づけていく。

## 今日のゴール

1. **ビットマップアロケータ**: バンプ方式の物理フレームアロケータをビットマップ方式に置き換える。フレームの解放ができるようになり、メモリの再利用が可能に
2. **プロセス / タスクの基盤**: カーネルタスクの概念を導入し、コンテキストスイッチの基盤を作る。最終的には複数タスクの協調的マルチタスクを目指す

Day 1 の「次にやりたいこと」リストをそのまま消化していく形。

## 実装計画

### Task 1: ビットマップフレームアロケータ

現在の `BumpFrameAllocator` はフレームの解放ができない。ビットマップ方式に置き換えて `deallocate_frame()` を追加する。

**変更ファイル:**
- `kernel/src/memory.rs` — `BumpFrameAllocator` → `BitmapFrameAllocator` に置き換え
  - ビットマップ (`Vec<u64>`) で各フレームの使用/空き状態を管理。1ビット = 1フレーム
  - `allocate_frame()`: ビットマップから空きビットを探してセット
  - `deallocate_frame()`: 指定フレームのビットをクリア
  - `free_frames()`: 空きフレーム数を返す統計関数
  - 既存の `MemoryRegion` / `FRAME_ALLOCATOR` / `init()` のインターフェースは維持
- `kernel/src/shell.rs` — `mem` コマンドで空きフレーム数も表示

### Task 2: 協調的マルチタスク — タスク構造体とスケジューラ

カーネルタスクの概念を導入する。各タスクは独自のスタックを持ち、`yield` で自発的に CPU を譲る（協調的マルチタスク）。

**変更ファイル:**
- `kernel/src/task.rs` (新規) — タスクの定義
  - `Task` 構造体: タスク ID、状態、スタック、コンテキスト（レジスタ保存領域）
  - `TaskState`: Running / Ready / Finished
  - `Context` 構造体: callee-saved レジスタ (rbx, rbp, r12-r15, rsp) の保存領域
- `kernel/src/scheduler.rs` (新規) — ラウンドロビンスケジューラ
  - タスクキュー (`VecDeque<Task>`)
  - `spawn()`: 新しいタスクを登録
  - `schedule()`: 次のタスクに切り替え
  - `context_switch()`: アセンブリでレジスタ退避/復帰（`naked_fn` or グローバルアセンブリ）
- `kernel/src/main.rs` — `mod task; mod scheduler;` 追加、デモタスクを生成して動作確認
- `kernel/src/shell.rs` — `ps` コマンドでタスク一覧を表示

### Task 3: プリエンプティブマルチタスク（タイマー割り込みベース）

タイマー割り込み (IRQ 0) でスケジューラを呼び出し、タスクを強制切り替えする。

**変更ファイル:**
- `kernel/src/interrupts.rs` — タイマー割り込みハンドラから `scheduler::preempt()` を呼ぶ。PIC マスクの明示的設定も追加
- `kernel/src/scheduler.rs` — `preempt()` 関数を追加（`try_lock` でデッドロック回避）
- `kernel/src/main.rs` — プリエンプティブデモタスク（yield を使わないビジーループ）を追加

### Task 4: sleep / タイマー機能

今のタスクは busy-wait か yield しかできない。PIT のティックカウントを使ってタスクを一定時間スリープさせる機能を実装する。

**変更ファイル:**
- `kernel/src/scheduler.rs` — TaskState に Sleeping を追加。`sleep_ticks()` / `sleep_ms()` 関数を追加。`preempt()` でスリープ中タスクの起床判定
- `kernel/src/interrupts.rs` — tick カウントの公開（既存の TIMER_TICK_COUNT を利用）
- `kernel/src/main.rs` — sleep を使うデモタスクを追加
- `kernel/src/shell.rs` — ps コマンドで Sleeping 状態を表示

## 実装ログ

### Task 1: ビットマップフレームアロケータ ✅

Day 1 で作ったフレームアロケータは「バンプアロケータ」という方式だった。これは「次に空いてるフレームの番号」のカウンターだけを持っていて、割り当てるたびに +1 するだけのシンプルな仕組み。高速だけど、途中のフレームを解放して再利用する手段がない。カウンターを戻すだけじゃ途中の穴は管理できないから。

今回これを「ビットマップアロケータ」に置き換えた。各フレームに 1 ビットを割り当てて、0 なら空き、1 なら使用中。解放したければそのビットを 1→0 にするだけ。各フレームの状態を個別に記録しているから、どこでも好きに割り当て・解放できる。`Vec<u64>` でビットマップを持ち、1 つの u64 で 64 フレーム分を管理する。空きビットの探索は `(!word).trailing_zeros()` で高速にできる。ビット反転して trailing zeros を数えれば「最初の 0 ビットの位置」が一発でわかる。

シェルの `mem` コマンドも空きフレーム数を表示するように更新した。

### Task 2: 協調的マルチタスク ✅

ここからマルチタスクの世界に入る。まずは「協調的マルチタスク (cooperative multitasking)」から。これは複数のタスクが自発的に CPU を譲り合う方式で、タスク自身が `yield_now()` を呼ばない限り永遠にそのタスクが動き続ける。Windows 3.1 や Classic Mac OS がこの方式だった。タスクが行儀よく yield してくれないとシステム全体が止まるという弱点がある。

タスクを切り替えるにはコンテキストスイッチ (context switch) が必要。これは今のタスクの CPU レジスタ（CPU の作業用変数のようなもの）をメモリに退避して、次のタスクのレジスタをメモリから復帰する操作のこと。実質的にはスタックポインタ (rsp) を切り替えるだけで、タスクの実行状態が丸ごと入れ替わる。

ただし全レジスタを保存する必要はない。x86_64 の関数呼び出し規約には callee-saved レジスタ（呼ばれた側が保存する責任を持つレジスタ）という概念があって、コンテキストスイッチではこれだけ保存すれば十分。残りの caller-saved レジスタは呼び出し側が既にスタックに保存済みだから。Microsoft x64 ABI（UEFI ターゲットが使う ABI）では rbx, rbp, rdi, rsi, r12-r15 が callee-saved。

`global_asm!` でコンテキストスイッチのアセンブリを書いた。8 個の callee-saved レジスタを push → rsp を保存 → 新しい rsp をロード → pop で復帰 → ret。新しいタスクの場合は `task_trampoline` にジャンプして、r12 に入れておいたエントリ関数を `call r12` で呼び出す。

スケジューラはラウンドロビン方式。タスクを順番に一つずつ実行していく最もシンプルなスケジューリング。現在のタスクの次から順に Ready 状態のタスクを探して切り替える。デモタスク A/B が交互にメッセージを出力して動作を確認した。

### Task 3: プリエンプティブマルチタスク ✅

協調的マルチタスクだとタスクが yield を忘れたらシステムが固まる。そこで次は「プリエンプティブマルチタスク (preemptive multitasking)」。preempt は英語で「先取りする、横取りする」という意味で、OS がタイマー割り込みを使ってタスクを強制的に中断し、別のタスクに切り替える方式。タスクが無限ループしても他のタスクが止まらない。現代の OS（Linux, Windows, macOS）はすべてこの方式。

心臓部は PIT (Programmable Interval Timer) というタイマーチップ。デフォルトで約 18.2 Hz（約 55ms 間隔）で IRQ 0 割り込みを発生させる。この割り込みハンドラから `preempt()` を呼んでタスクを切り替える。

割り込みハンドラの中では EOI (End Of Interrupt) の送信タイミングが重要。EOI は PIC に「この割り込みの処理は終わった」と通知する操作で、送らないと PIC が次の割り込みをブロックし続ける。プリエンプションでは EOI を context_switch の前に送る必要がある。後に送ると、切り替え先タスクがタイマー割り込みを受け取れなくなるから。

**ハマったポイント:**

一番ハマったのは PIC のマスク設定。UEFI が IRQ 0（タイマー）をマスクしていて、`pic8259` の `initialize()` は初期化前のマスク値を復元するため、UEFI のマスク設定がそのまま残ってしまっていた。timer ticks のアトミックカウンターを追加して調べたら「タイマーが一度も発火していない」ことがわかり、`write_masks(0xFC, 0xFF)` で明示的にアンマスクして解決。

もう一つは `task_trampoline` の問題。`yield_now()` は割り込みを無効化してから `context_switch` するので、新タスクが初めて実行されるときは割り込みが無効のまま。これだとタイマー割り込みが来ないのでプリエンプションが効かない。`task_trampoline` の先頭に `sti`（割り込み有効化命令）を追加して解決した。

`preempt()` は `try_lock()` を使ってデッドロックを回避している。タイマー割り込みは SCHEDULER のロック保持中にも発火しうるので、`lock()` で待つとデッドロックになる。`try_lock()` が失敗したら今回はスキップして、次のタイマー（55ms 後）で再試行すればいい。

**結果:** yield を呼ばないビジーループタスクが交互に実行されることを確認。timer ticks: ~158, preempt switches: ~157。

![プリエンプティブマルチタスク](images/preemptive.png)

### Task 4: sleep / タイマー機能 ✅

ここまでのタスクは CPU を譲りたいとき yield するか、busy-wait（ループで時間を潰す）しかなかった。busy-wait は CPU 時間を無駄に消費するので、「一定時間何もしないで待つ」なら CPU を他のタスクに譲って、時間が来たら起こしてもらう方が効率的。これが sleep 機能。

TaskState に `Sleeping(wake_at)` を追加した。wake_at は「タイマーティックがこの値に達したら起こしてね」という起床時刻。`sleep_ms(ms)` を呼ぶと、現在のティック数 + 必要なティック数を wake_at にセットして Sleeping 状態にし、yield_now() で CPU を譲る。

起床の判定は `preempt()` の中で行う。タイマー割り込みのたびに全タスクの Sleeping 状態をチェックして、起床時刻に達したものを Ready に戻す。PIT が 18.2 Hz で発火するから、約 55ms ごとに起床チェックが走る。精度は最大 55ms の誤差がある（ティック単位でしか判定できないから）けど、カーネルタスクの sleep としては十分。

ミリ秒からティック数への変換は `ticks = ms * 182 / 10000` で計算する。PIT のデフォルト周波数 1193182 Hz / 65536 ≈ 18.2065 Hz から逆算した値。

デモでは 500ms sleep と 300ms sleep の 2 タスクを同時に走らせた。300ms の方が先に起きて、期待通りの順序でメッセージが出力されることを確認。

![sleep デモ](images/sleep.png)
