# 2026-02-02: Day 2 — メモリ管理の強化とタスクの世界へ

Day 1 ではブートからシェルまで一気に駆け抜けた。今日はカーネルの内部をもっと「ちゃんとした OS」に近づけていく。

## 今日のゴール

1. **ビットマップアロケータ**: バンプ方式の物理フレームアロケータをビットマップ方式に置き換える。フレームの解放ができるようになり、メモリの再利用が可能に
2. **プロセス / タスクの基盤**: カーネルタスクの概念を導入し、コンテキストスイッチの基盤を作る。最終的には複数タスクの協調的マルチタスクを目指す

Day 1 の「次にやりたいこと」リストをそのまま消化していく形。

## 実装計画

### Task 1: ビットマップフレームアロケータ

現在の `BumpFrameAllocator` はフレームの解放ができない。ビットマップ方式に置き換えて `deallocate_frame()` を追加する。

**変更ファイル:**
- `kernel/src/memory.rs` — `BumpFrameAllocator` → `BitmapFrameAllocator` に置き換え
  - ビットマップ (`Vec<u64>`) で各フレームの使用/空き状態を管理。1ビット = 1フレーム
  - `allocate_frame()`: ビットマップから空きビットを探してセット
  - `deallocate_frame()`: 指定フレームのビットをクリア
  - `free_frames()`: 空きフレーム数を返す統計関数
  - 既存の `MemoryRegion` / `FRAME_ALLOCATOR` / `init()` のインターフェースは維持
- `kernel/src/shell.rs` — `mem` コマンドで空きフレーム数も表示

### Task 2: 協調的マルチタスク — タスク構造体とスケジューラ

カーネルタスクの概念を導入する。各タスクは独自のスタックを持ち、`yield` で自発的に CPU を譲る（協調的マルチタスク）。

**変更ファイル:**
- `kernel/src/task.rs` (新規) — タスクの定義
  - `Task` 構造体: タスク ID、状態、スタック、コンテキスト（レジスタ保存領域）
  - `TaskState`: Running / Ready / Finished
  - `Context` 構造体: callee-saved レジスタ (rbx, rbp, r12-r15, rsp) の保存領域
- `kernel/src/scheduler.rs` (新規) — ラウンドロビンスケジューラ
  - タスクキュー (`VecDeque<Task>`)
  - `spawn()`: 新しいタスクを登録
  - `schedule()`: 次のタスクに切り替え
  - `context_switch()`: アセンブリでレジスタ退避/復帰（`naked_fn` or グローバルアセンブリ）
- `kernel/src/main.rs` — `mod task; mod scheduler;` 追加、デモタスクを生成して動作確認
- `kernel/src/shell.rs` — `ps` コマンドでタスク一覧を表示

### Task 3: プリエンプティブマルチタスク（タイマー割り込みベース）

タイマー割り込み (IRQ 0) でスケジューラを呼び出し、タスクを強制切り替えする。

**変更ファイル:**
- `kernel/src/interrupts.rs` — タイマー割り込みハンドラから `scheduler::preempt()` を呼ぶ。PIC マスクの明示的設定も追加
- `kernel/src/scheduler.rs` — `preempt()` 関数を追加（`try_lock` でデッドロック回避）
- `kernel/src/main.rs` — プリエンプティブデモタスク（yield を使わないビジーループ）を追加

## 実装ログ

### Task 1: ビットマップフレームアロケータ ✅

`BumpFrameAllocator` を `BitmapFrameAllocator` に置き換え。1ビット=1フレームのビットマップで管理し、`deallocate_frame()` でフレームの解放が可能に。`(!word).trailing_zeros()` で高速に空きビットを探索する。`mem` コマンドで空きフレーム数も表示するようにした。

### Task 2: 協調的マルチタスク ✅

`scheduler.rs` に `global_asm!` でコンテキストスイッチを実装。Microsoft x64 ABI の callee-saved レジスタ (rbx, rbp, rdi, rsi, r12-r15) を push/pop してスタックポインタを切り替える。`task_trampoline` が新タスクの初回起動を担当し、r12 に入れたエントリ関数を `call r12` で呼び出す。デモタスク A/B が交互にメッセージを出力して協調的マルチタスクの動作を確認した。

### Task 3: プリエンプティブマルチタスク ✅

タイマー割り込み (IRQ 0) からスケジューラを呼び出し、タスクを強制切り替えする。

**ハマったポイント:**

1. **PIC マスク問題**: UEFI が IRQ 0（タイマー）をマスクしていた。`pic8259` の `initialize()` は初期化前のマスクを復元するため、UEFI のマスク設定がそのまま残ってしまう。`write_masks(0xFC, 0xFF)` で明示的にタイマーとキーボードをアンマスクする必要があった。timer ticks カウンターを追加して「タイマーが一度も発火していない」ことを発見し、原因を特定できた。

2. **task_trampoline の sti**: `yield_now()` は割り込みを無効化してから `context_switch` するため、新タスクが初めて実行される時は割り込みが無効のまま。`task_trampoline` の先頭に `sti` を追加して、エントリ関数の実行前に割り込みを有効化する。

3. **preempt() のデッドロック回避**: `try_lock()` を使い、SCHEDULER のロック保持中にタイマーが発火した場合はプリエンプションをスキップ。次のタイマーで再試行する。

4. **EOI の順序**: EOI を `context_switch` の前に送る。後に送ると、切り替え先タスクがタイマー割り込みを受け取れなくなる。

**結果:** yield を呼ばないビジーループタスクが交互に実行されることを確認。timer ticks: ~158, preempt switches: ~157。

![プリエンプティブマルチタスク](images/preemptive.png)

## 今日の用語集

### バンプアロケータ (bump allocator)
「次に空いてるフレーム番号」のカウンターだけを持つ、最もシンプルなアロケータ。割り当てるたびにカウンターを +1 するだけ。高速だが、途中のフレームを解放して再利用する手段がない。

### ビットマップアロケータ (bitmap allocator)
各フレームに 1 ビットを割り当てて、0=空き / 1=使用中 を管理する方式。ビットを 1→0 にすれば解放、0→1 にすれば割り当て。各フレームの状態を個別に記録する構造があるから、バンプ方式ではできなかった解放と再利用が可能になる。

### コンテキストスイッチ (context switch)
CPU が実行中のタスクを別のタスクに切り替えること。具体的には、現在のタスクのレジスタ（CPU の作業用変数）をメモリに退避し、次のタスクのレジスタをメモリから復帰する操作。スタックポインタ (rsp) を切り替えることで、タスクの実行状態を丸ごと入れ替える。

### callee-saved レジスタ
関数呼び出し規約で「呼ばれた側が保存する責任を持つ」レジスタ。関数から戻るときに、呼ばれる前の値に戻っている保証がある。コンテキストスイッチではこれらだけを保存すればよい（caller-saved は呼び出し側が既に保存済み）。Microsoft x64 ABI では rbx, rbp, rdi, rsi, r12-r15 が該当。

### 協調的マルチタスク (cooperative multitasking)
複数のタスクが **自発的に** CPU を譲り合う方式。タスク自身が `yield_now()` を呼ばない限り、永遠にそのタスクが動き続ける。「協調的」= タスクが協力して譲り合うという意味。タスクが行儀よく yield しないとシステム全体が止まる。Windows 3.1 や Classic Mac OS がこの方式だった。

### プリエンプティブマルチタスク (preemptive multitasking)
**OS が強制的に** タスクを中断して切り替える方式。preempt = 「先取りする、横取りする」という英語。タイマー割り込み（ハードウェアが定期的に CPU に送る信号）をトリガーにして、タスクが yield しなくても OS が割り込んで別タスクに切り替える。タスクが無限ループしても他のタスクが止まらないので、現代の OS（Linux, Windows, macOS）はすべてこの方式。

### PIT (Programmable Interval Timer)
PC に搭載されたタイマーチップ。設定した間隔で IRQ 0 割り込みを発生させる。デフォルトでは約 18.2 Hz（約 55ms 間隔）で発火する。プリエンプティブマルチタスクのタイムスライスの基盤。

### EOI (End Of Interrupt)
PIC に「この割り込みの処理は終わった」と通知する操作。EOI を送らないと PIC は「まだ処理中」と判断し、同じ優先度以下の割り込みをブロックし続ける。プリエンプションでは EOI を context_switch の前に送る必要がある（切り替え先タスクもタイマー割り込みを受け取れるようにするため）。

### ラウンドロビン (round robin)
スケジューリングアルゴリズムの一つ。タスクを順番に一つずつ実行していく方式。現在のタスクの次から順に Ready 状態のタスクを探し、見つかったらそれに切り替える。公平だがシンプルな方式。
