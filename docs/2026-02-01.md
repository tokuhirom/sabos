# 2026-02-01: Day 1 — ここから始まる物語

自作OS、始めてみることにした。名前は SABOS。
ネットワーク接続ができて、GUIアプリが動くところまでいけたら最高だけど、まあ習作なので楽しいことが一番大事。

## 基本方針

x86_64 / Rust / UEFI で行くことにした。

- **x86_64**: QEMUでのデバッグが楽だし、資料が豊富
- **Rust**: せっかくなのでメモリ安全な言語で。no_std でベアメタルできるのが良い
- **UEFI**: 最初から64bitで動けるし、Legacy BIOS みたいなモード遷移の苦行をしなくていい。画面描画用のフレームバッファ (GOP) も最初から使えるので GUI 目標と相性が良い

そもそも UEFI って何？ってところから調べた。PC の電源入れてから OS が起動するまでの間に動くファームウェアのインターフェース仕様で、昔の BIOS の後継。UEFI のおかげでブートローダ自作の手間がだいぶ省ける。

## 開発環境

devbox で rustup, QEMU, OVMF を入れた。`devbox shell` 一発で全部揃うのは便利。
Rust は nightly が必要（`x86_64-unknown-uefi` ターゲットのため）。

OVMF って何？と思って調べたら、QEMU で UEFI を動かすためのファームウェア実装だった。実機にはマザーボードに UEFI の ROM が焼かれてるけど、QEMU にはそれがない。OVMF がその代役をしてくれる。EDK II（UEFI のリファレンス実装）から派生したオープンソースプロジェクトらしい。

```
実機:   電源ON → マザーボードのUEFI ROM → OS起動
QEMU:   起動   → OVMF (OVMF_CODE.fd)    → OS起動
```

Makefile で QEMU に渡してるファイルが2つあって:

- **`OVMF_CODE.fd`** — ファームウェア本体（読み取り専用）
- **`OVMF_VARS.fd`** — UEFI変数の保存領域（ブート順序の設定とか）

これのおかげで実機なしで `make run` するだけで UEFI アプリの開発ができてる。ありがたい。

## Hello, SABOS!

UEFI アプリとして "Hello, SABOS!" をシリアル出力するところまで到達。`make run` で QEMU が起動して表示される。

```
Hello, SABOS!
```

uefi crate (v0.35) の API は `uefi::system::with_stdout()` でコンソール出力する形。
QEMU は `-drive format=raw,file=fat:rw:esp` でディレクトリをそのまま FAT パーティションとして認識させられるので、イメージファイルを作る手間がない。

## 開発ルール

いくつか決めた。

- **main に直接コミット**。習作なのでブランチ運用は面倒なだけ
- **GitHub Actions でビルドを保証**。一度作ったものが壊れてないことを常にチェックする。これ大事
- **コメントはマシマシ**。後から読んで「なんでこうしたんだっけ」ってならないように。学習用なので丁寧に書く
- **開発日記を書く**。最初は ADR にしようかと思ったけど、もっとカジュアルに日記形式でいいかなと。スクショも貼っていく

## GOP で画面に描画できた！

GOP (Graphics Output Protocol) って何？ってところから。UEFI が提供するグラフィックス描画の仕組みで、フレームバッファ（ピクセルデータを書き込むメモリ領域）にアクセスできる。Legacy BIOS だとテキストモードから始めて VBE を叩いてグラフィックスモードに切り替えて...と面倒だけど、UEFI + GOP なら最初からピクセル単位で画面に描ける。

やったこと:

1. `uefi::boot::get_handle_for_protocol::<GraphicsOutput>()` で GOP プロトコルを取得
2. `current_mode_info().resolution()` で画面サイズ取得 → 1280x800 だった
3. `BltOp::VideoFill` で画面全体を青で塗りつぶし
4. その上に白い矩形を中央に描画

Blt は Block Transfer の略で、GPU のハードウェア機能で高速に塗りつぶせるらしい。

ハマったポイント: QEMU に `-nodefaults -display none` だけだと GPU デバイスが存在しないので GOP が見つからなくて panic した。`-vga std` を追加して仮想 VGA アダプタを載せる必要があった。

![GOP で青背景 + 白矩形を描画](images/2026-02-01-gop.png)

シリアル出力:
```
Hello, SABOS!
GOP: 1280x800, format: Bgr
Screen painted!
```

QEMUのスクショは、QEMU monitor の `screendump` コマンドで PPM ファイルとして保存して、ImageMagick で PNG に変換した。

## フレームバッファにテキスト描画

矩形が描けたら次は文字が出したくなる。Blt で 1 ピクセルずつ描くのは非効率なので、GOP のフレームバッファに直接ピクセルを書き込む方式にした。

`font8x8` crate を使った。8x8 ピクセルのビットマップフォントで、各文字が 8 バイトのビットパターンで表現されてる。ビットが立ってたら前景色、立ってなかったら背景色を書く。シンプル。

ハマったポイント: `font8x8` はデフォルトで `std` feature が有効になっていて、no_std 環境だと panic_handler が重複してコンパイルエラーになった。`default-features = false` で解決。no_std crate を使うときは常にデフォルトフィーチャーを確認しないとダメだな。

`FramebufferWriter` 構造体を作って `core::fmt::Write` を実装したので、`write!()` マクロが使える。色も変えられるようにした。

もう一つ注意点として、ピクセルフォーマットが RGB と BGR で byte 順が違う。QEMU + OVMF は BGR だった。これも FramebufferWriter 内で吸収してる。

あと、フレームバッファへの書き込みは `write_volatile` を使わないとコンパイラの最適化で消される可能性がある。メモリマップドI/Oの基本。

![フレームバッファにテキスト描画](images/2026-02-01-text.png)

## Exit Boot Services — UEFI アプリからカーネルへ

ここがこの日のハイライト。

UEFI には Boot Services と Runtime Services がある。Boot Services はメモリ確保、プロトコル（GOP とか）へのアクセス、コンソール出力などを提供してくれるけど、OS が「もう自分でやるから」と言うまでの話。`exit_boot_services()` を呼ぶと Boot Services は終了して、全メモリ・全ハードウェアの管理がカーネルに移る。

Exit 前にやっておくべきこと:

1. **フレームバッファ情報を保存** — GOP プロトコルは Exit 後に使えなくなるけど、フレームバッファの物理アドレス自体はメモリ上に残る。アドレス・サイズ・解像度・ピクセルフォーマットを `FramebufferInfo` に控えておく
2. **メモリマップを取得** — どの物理アドレス範囲がどういう種類のメモリかの一覧。CONVENTIONAL が OS が自由に使える領域

uefi crate の `exit_boot_services()` は内部で自動的にメモリマップを取得して Exit を呼んでくれる。メモリマップのキーが変わっていたら自動リトライもしてくれて賢い。

ハマったポイント: Exit 前に GOP の `ScopedProtocol` を `drop(gop)` しておかないとダメ。ScopedProtocol は RAII ラッパーで、drop 時に `close_protocol` を呼ぶ。プロトコルへの参照が残った状態で Exit すると未定義動作になる。

あと、UEFI の stdout に大量に書き込むと途中で panic することがわかった。メモリマップ全エントリの出力は重すぎたみたい。サマリーだけ出す形にした。

結果: Exit Boot Services 後にフレームバッファへの描画が成功。83 MiB のメモリが使える。

![カーネルとして動作中](images/2026-02-01-kernel.png)

```
=== SABOS ===

Framebuffer: 1280x800
Pixel format: Bgr

Boot services exited successfully!
Kernel is now in control.

Memory map:
  Usable memory: 83 MiB (21446 pages)
  Total entries: 100
```

## GDT / IDT — 例外が起きても死なないカーネルへ

Exit Boot Services で「カーネルが動いてる」状態にはなったけど、今のままだとゼロ除算やページフォルトみたいな CPU 例外が起きた瞬間にトリプルフォルト → CPU リセット → 無言の再起動になる。何が起きたかわからないのは最悪なので、例外ハンドラを設定する。

### GDT って何？

GDT (Global Descriptor Table) は CPU に「メモリセグメントのルール」を教えるテーブル。x86_64 のロングモードではセグメンテーションはほぼ無効化されてるけど、最低限以下が必要:

- **カーネルコードセグメント** (Ring 0, 64-bit)
- **カーネルデータセグメント** (Ring 0)
- **TSS セグメント** — TSS の場所を CPU に教える

TSS (Task State Segment) はもともとタスク切り替え用の構造体だったけど、x86_64 では主に「例外発生時に使う別スタック」の指定に使われる。IST (Interrupt Stack Table) っていう仕組みで、ダブルフォルト時に専用の安全なスタックに切り替えられる。

### IDT って何？

IDT (Interrupt Descriptor Table) は「割り込みや例外が起きたらどの関数を呼ぶか」を CPU に教えるテーブル。256 個のエントリがあって:

- **0〜31 番**: CPU 例外（ゼロ除算、ページフォルト、ダブルフォルト等）
- **32〜255 番**: ハードウェア割り込みやソフトウェア割り込み（キーボード、タイマー等。後で設定する）

### トリプルフォルトの恐怖

例外ハンドラが設定されていないとこうなる:

```
何かの例外発生 → ハンドラがない → ダブルフォルト発生
→ ダブルフォルトのハンドラもない → トリプルフォルト
→ CPU リセット（無言の再起動）
```

ダブルフォルトハンドラを IST（専用スタック）付きで設定しておけば、通常スタックが壊れていても安全に停止して「何が起きたか」を表示できる。これが最後の砦。

### 実装

`x86_64` crate と `lazy_static` crate を使った。

- `gdt.rs`: GDT + TSS のセットアップ。ダブルフォルト用に 20KiB の専用スタックを確保して IST に登録
- `interrupts.rs`: IDT に各例外ハンドラを登録。設定した例外:
  - `#DE` 除算エラー → panic
  - `#DB` デバッグ → panic
  - `#BP` ブレークポイント → 正常復帰（テスト用）
  - `#UD` 不正オペコード → panic
  - `#GP` 一般保護違反 → panic
  - `#PF` ページフォルト → panic（CR2 レジスタからアクセスアドレスも表示）
  - `#DF` ダブルフォルト → panic（IST 専用スタック使用）

初期化順序が大事で、GDT → IDT の順に init する必要がある（IDT のダブルフォルトエントリが IST を使うので、先に TSS が有効になっていないとダメ）。

ハマったポイント: Rust 2024 edition では `static mut` への共有参照（`&DOUBLE_FAULT_STACK`）が禁止された。`&raw const DOUBLE_FAULT_STACK` に書き換えて対応。エディションごとに unsafe のルールが厳しくなっていくのは良いことだけど、サンプルコードがそのまま動かないことがある。

### int3 テスト

IDT が正しく動いているか確認するために `int3` (ブレークポイント命令) を使った。`int3` は x86 の 1バイト命令 (`0xCC`) で、IDT の 3 番 `#BP` 例外を発生させる。DOS 時代の `int 21h`（DOS システムコール）と同じソフトウェア割り込みの仲間だけど、こっちはデバッグ専用。GDB のブレークポイントもこの仕組みで動いてるらしい。

breakpoint_handler は panic しないようにしてあるので、`int3` → ハンドラ呼び出し → 正常復帰 → "OK!" が表示されれば成功。

```
Testing int3 breakpoint... OK!
All exception handlers are set up.
```

![GDT/IDT 初期化成功](images/2026-02-01-gdt-idt.png)

### feature gate: abi_x86_interrupt

割り込みハンドラは通常の関数と違って、x86 の割り込み呼び出し規約 (`extern "x86-interrupt"`) に従う必要がある。これは Rust の不安定機能なので `#![feature(abi_x86_interrupt)]` が必要。nightly ならではの世界。

## ヒープアロケータ — Vec も String も使いたい！

ここまで `no_std` + `no_alloc` の世界で生きてきたけど、`Vec` も `Box` も `String` も使えないのは正直つらい。動的メモリ確保ができないと、今後のドライバやデータ構造の実装がしんどくなる一方。ということでヒープアロケータを実装した。

### そもそもヒープって何が必要なの？

Rust で `Vec::new()` とか `Box::new()` を呼ぶと、内部で `alloc` crate がグローバルアロケータ (`#[global_allocator]`) に「メモリくれ」って要求する。普通の OS 上で動くプログラムだと libc の `malloc` がこれをやってくれるけど、カーネルにはそんなものはない。自分で用意する必要がある。

必要なもの:
1. **ヒープ用のメモリ領域** — アロケータが管理する生のメモリ
2. **アロケータの実装** — `GlobalAlloc` トレイトを実装した構造体
3. **`extern crate alloc;`** — Rust の `alloc` crate を有効にする

### 実装方針

`linked_list_allocator` crate を使った。フリーリスト方式のアロケータで、解放されたメモリブロックをリンクリストで管理する。自前で書くより信頼性が高いし、OS 開発チュートリアルでもよく使われてる。

ヒープ領域は BSS セクションに 1 MiB の静的配列を確保する方式にした。BSS はゼロ初期化される領域で、バイナリのファイルサイズは増えない。将来的にはメモリマップから動的に確保する形にできるけど、まずはシンプルに。

```rust
// BSS に 1 MiB のヒープ領域を確保
#[repr(align(16))]
struct HeapMemory([u8; HEAP_SIZE]);
static mut HEAP_MEMORY: HeapMemory = HeapMemory([0; HEAP_SIZE]);

// グローバルアロケータとして登録
#[global_allocator]
static ALLOCATOR: LockedHeap = LockedHeap::empty();
```

`#[repr(align(16))]` はアラインメント指定。x86_64 の SSE 命令は 16 バイトアラインメントを要求するので念のため。

### テスト結果

`Box`, `Vec`, `String`, `format!` が全部動いた！

```
Heap allocator test:
  Box<i32>: 42
  Vec: [1, 2, 3, 4, 5, 6] (len=6)
  String: "Hello, SABOS heap!"
  format!: "Heap size: 1024 KiB"

Heap allocator is working!
```

![ヒープアロケータ動作確認](images/2026-02-01-heap.png)

`alloc` crate が使えるようになったことで、今後のコードの表現力が格段に上がる。`Vec` でバッファ管理、`String` でテキスト処理、`Box` でトレイトオブジェクト、`format!` で動的フォーマット... Rust の真の力が使えるようになった感がある。

### 初期化順序

```
gdt::init()       → GDT/TSS をセットアップ
interrupts::init() → IDT に例外ハンドラ登録
allocator::init()  → ヒープアロケータ初期化 ← NEW!
```

ヒープの初期化は GDT/IDT の後にしている。アロケータ自体は割り込みに依存しないけど、もしヒープ初期化中に例外が起きた場合にちゃんとキャッチできるようにする安全策。

## 次にやりたいこと

- ハードウェア割り込み（PIC + タイマー + キーボード）
- ページングのセットアップ
- スクロール機能
