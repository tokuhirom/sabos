# 2026-02-01: Day 1 — ここから始まる物語

自作OS、始めてみることにした。名前は SABOS。
ネットワーク接続ができて、GUIアプリが動くところまでいけたら最高だけど、まあ習作なので楽しいことが一番大事。

## 基本方針

x86_64 / Rust / UEFI で行くことにした。

- **x86_64**: QEMUでのデバッグが楽だし、資料が豊富
- **Rust**: せっかくなのでメモリ安全な言語で。no_std でベアメタルできるのが良い
- **UEFI**: 最初から64bitで動けるし、Legacy BIOS みたいなモード遷移の苦行をしなくていい。画面描画用のフレームバッファ (GOP) も最初から使えるので GUI 目標と相性が良い

そもそも UEFI って何？ってところから調べた。PC の電源入れてから OS が起動するまでの間に動くファームウェアのインターフェース仕様で、昔の BIOS の後継。UEFI のおかげでブートローダ自作の手間がだいぶ省ける。

## 開発環境

devbox で rustup, QEMU, OVMF を入れた。`devbox shell` 一発で全部揃うのは便利。
Rust は nightly が必要（`x86_64-unknown-uefi` ターゲットのため）。

OVMF って何？と思って調べたら、QEMU で UEFI を動かすためのファームウェア実装だった。実機にはマザーボードに UEFI の ROM が焼かれてるけど、QEMU にはそれがない。OVMF がその代役をしてくれる。EDK II（UEFI のリファレンス実装）から派生したオープンソースプロジェクトらしい。

```
実機:   電源ON → マザーボードのUEFI ROM → OS起動
QEMU:   起動   → OVMF (OVMF_CODE.fd)    → OS起動
```

Makefile で QEMU に渡してるファイルが2つあって:

- **`OVMF_CODE.fd`** — ファームウェア本体（読み取り専用）
- **`OVMF_VARS.fd`** — UEFI変数の保存領域（ブート順序の設定とか）

これのおかげで実機なしで `make run` するだけで UEFI アプリの開発ができてる。ありがたい。

## Hello, SABOS!

UEFI アプリとして "Hello, SABOS!" をシリアル出力するところまで到達。`make run` で QEMU が起動して表示される。

```
Hello, SABOS!
```

uefi crate (v0.35) の API は `uefi::system::with_stdout()` でコンソール出力する形。
QEMU は `-drive format=raw,file=fat:rw:esp` でディレクトリをそのまま FAT パーティションとして認識させられるので、イメージファイルを作る手間がない。

## 開発ルール

いくつか決めた。

- **main に直接コミット**。習作なのでブランチ運用は面倒なだけ
- **GitHub Actions でビルドを保証**。一度作ったものが壊れてないことを常にチェックする。これ大事
- **コメントはマシマシ**。後から読んで「なんでこうしたんだっけ」ってならないように。学習用なので丁寧に書く
- **開発日記を書く**。最初は ADR にしようかと思ったけど、もっとカジュアルに日記形式でいいかなと。スクショも貼っていく

## GOP で画面に描画できた！

GOP (Graphics Output Protocol) って何？ってところから。UEFI が提供するグラフィックス描画の仕組みで、フレームバッファ（ピクセルデータを書き込むメモリ領域）にアクセスできる。Legacy BIOS だとテキストモードから始めて VBE を叩いてグラフィックスモードに切り替えて...と面倒だけど、UEFI + GOP なら最初からピクセル単位で画面に描ける。

やったこと:

1. `uefi::boot::get_handle_for_protocol::<GraphicsOutput>()` で GOP プロトコルを取得
2. `current_mode_info().resolution()` で画面サイズ取得 → 1280x800 だった
3. `BltOp::VideoFill` で画面全体を青で塗りつぶし
4. その上に白い矩形を中央に描画

Blt は Block Transfer の略で、GPU のハードウェア機能で高速に塗りつぶせるらしい。

ハマったポイント: QEMU に `-nodefaults -display none` だけだと GPU デバイスが存在しないので GOP が見つからなくて panic した。`-vga std` を追加して仮想 VGA アダプタを載せる必要があった。

![GOP で青背景 + 白矩形を描画](images/2026-02-01-gop.png)

シリアル出力:
```
Hello, SABOS!
GOP: 1280x800, format: Bgr
Screen painted!
```

QEMUのスクショは、QEMU monitor の `screendump` コマンドで PPM ファイルとして保存して、ImageMagick で PNG に変換した。

## フレームバッファにテキスト描画

矩形が描けたら次は文字が出したくなる。Blt で 1 ピクセルずつ描くのは非効率なので、GOP のフレームバッファに直接ピクセルを書き込む方式にした。

`font8x8` crate を使った。8x8 ピクセルのビットマップフォントで、各文字が 8 バイトのビットパターンで表現されてる。ビットが立ってたら前景色、立ってなかったら背景色を書く。シンプル。

ハマったポイント: `font8x8` はデフォルトで `std` feature が有効になっていて、no_std 環境だと panic_handler が重複してコンパイルエラーになった。`default-features = false` で解決。no_std crate を使うときは常にデフォルトフィーチャーを確認しないとダメだな。

`FramebufferWriter` 構造体を作って `core::fmt::Write` を実装したので、`write!()` マクロが使える。色も変えられるようにした。

もう一つ注意点として、ピクセルフォーマットが RGB と BGR で byte 順が違う。QEMU + OVMF は BGR だった。これも FramebufferWriter 内で吸収してる。

あと、フレームバッファへの書き込みは `write_volatile` を使わないとコンパイラの最適化で消される可能性がある。メモリマップドI/Oの基本。

![フレームバッファにテキスト描画](images/2026-02-01-text.png)

## Exit Boot Services — UEFI アプリからカーネルへ

ここがこの日のハイライト。

UEFI には Boot Services と Runtime Services がある。Boot Services はメモリ確保、プロトコル（GOP とか）へのアクセス、コンソール出力などを提供してくれるけど、OS が「もう自分でやるから」と言うまでの話。`exit_boot_services()` を呼ぶと Boot Services は終了して、全メモリ・全ハードウェアの管理がカーネルに移る。

Exit 前にやっておくべきこと:

1. **フレームバッファ情報を保存** — GOP プロトコルは Exit 後に使えなくなるけど、フレームバッファの物理アドレス自体はメモリ上に残る。アドレス・サイズ・解像度・ピクセルフォーマットを `FramebufferInfo` に控えておく
2. **メモリマップを取得** — どの物理アドレス範囲がどういう種類のメモリかの一覧。CONVENTIONAL が OS が自由に使える領域

uefi crate の `exit_boot_services()` は内部で自動的にメモリマップを取得して Exit を呼んでくれる。メモリマップのキーが変わっていたら自動リトライもしてくれて賢い。

ハマったポイント: Exit 前に GOP の `ScopedProtocol` を `drop(gop)` しておかないとダメ。ScopedProtocol は RAII ラッパーで、drop 時に `close_protocol` を呼ぶ。プロトコルへの参照が残った状態で Exit すると未定義動作になる。

あと、UEFI の stdout に大量に書き込むと途中で panic することがわかった。メモリマップ全エントリの出力は重すぎたみたい。サマリーだけ出す形にした。

結果: Exit Boot Services 後にフレームバッファへの描画が成功。83 MiB のメモリが使える。

![カーネルとして動作中](images/2026-02-01-kernel.png)

```
=== SABOS ===

Framebuffer: 1280x800
Pixel format: Bgr

Boot services exited successfully!
Kernel is now in control.

Memory map:
  Usable memory: 83 MiB (21446 pages)
  Total entries: 100
```

## GDT / IDT — 例外が起きても死なないカーネルへ

Exit Boot Services で「カーネルが動いてる」状態にはなったけど、今のままだとゼロ除算やページフォルトみたいな CPU 例外が起きた瞬間にトリプルフォルト → CPU リセット → 無言の再起動になる。何が起きたかわからないのは最悪なので、例外ハンドラを設定する。

### GDT って何？

GDT (Global Descriptor Table) は CPU に「メモリセグメントのルール」を教えるテーブル。x86_64 のロングモードではセグメンテーションはほぼ無効化されてるけど、最低限以下が必要:

- **カーネルコードセグメント** (Ring 0, 64-bit)
- **カーネルデータセグメント** (Ring 0)
- **TSS セグメント** — TSS の場所を CPU に教える

TSS (Task State Segment) はもともとタスク切り替え用の構造体だったけど、x86_64 では主に「例外発生時に使う別スタック」の指定に使われる。IST (Interrupt Stack Table) っていう仕組みで、ダブルフォルト時に専用の安全なスタックに切り替えられる。

### IDT って何？

IDT (Interrupt Descriptor Table) は「割り込みや例外が起きたらどの関数を呼ぶか」を CPU に教えるテーブル。256 個のエントリがあって:

- **0〜31 番**: CPU 例外（ゼロ除算、ページフォルト、ダブルフォルト等）
- **32〜255 番**: ハードウェア割り込みやソフトウェア割り込み（キーボード、タイマー等。後で設定する）

### トリプルフォルトの恐怖

例外ハンドラが設定されていないとこうなる:

```
何かの例外発生 → ハンドラがない → ダブルフォルト発生
→ ダブルフォルトのハンドラもない → トリプルフォルト
→ CPU リセット（無言の再起動）
```

ダブルフォルトハンドラを IST（専用スタック）付きで設定しておけば、通常スタックが壊れていても安全に停止して「何が起きたか」を表示できる。これが最後の砦。

### 実装

`x86_64` crate と `lazy_static` crate を使った。

- `gdt.rs`: GDT + TSS のセットアップ。ダブルフォルト用に 20KiB の専用スタックを確保して IST に登録
- `interrupts.rs`: IDT に各例外ハンドラを登録。設定した例外:
  - `#DE` 除算エラー → panic
  - `#DB` デバッグ → panic
  - `#BP` ブレークポイント → 正常復帰（テスト用）
  - `#UD` 不正オペコード → panic
  - `#GP` 一般保護違反 → panic
  - `#PF` ページフォルト → panic（CR2 レジスタからアクセスアドレスも表示）
  - `#DF` ダブルフォルト → panic（IST 専用スタック使用）

初期化順序が大事で、GDT → IDT の順に init する必要がある（IDT のダブルフォルトエントリが IST を使うので、先に TSS が有効になっていないとダメ）。

ハマったポイント: Rust 2024 edition では `static mut` への共有参照（`&DOUBLE_FAULT_STACK`）が禁止された。`&raw const DOUBLE_FAULT_STACK` に書き換えて対応。エディションごとに unsafe のルールが厳しくなっていくのは良いことだけど、サンプルコードがそのまま動かないことがある。

### int3 テスト

IDT が正しく動いているか確認するために `int3` (ブレークポイント命令) を使った。`int3` は x86 の 1バイト命令 (`0xCC`) で、IDT の 3 番 `#BP` 例外を発生させる。DOS 時代の `int 21h`（DOS システムコール）と同じソフトウェア割り込みの仲間だけど、こっちはデバッグ専用。GDB のブレークポイントもこの仕組みで動いてるらしい。

breakpoint_handler は panic しないようにしてあるので、`int3` → ハンドラ呼び出し → 正常復帰 → "OK!" が表示されれば成功。

```
Testing int3 breakpoint... OK!
All exception handlers are set up.
```

![GDT/IDT 初期化成功](images/2026-02-01-gdt-idt.png)

### feature gate: abi_x86_interrupt

割り込みハンドラは通常の関数と違って、x86 の割り込み呼び出し規約 (`extern "x86-interrupt"`) に従う必要がある。これは Rust の不安定機能なので `#![feature(abi_x86_interrupt)]` が必要。nightly ならではの世界。

## 次にやりたいこと

- ヒープアロケータ（動的メモリ確保）
- ページングのセットアップ
- スクロール機能
