# 2026-02-01: Day 1 — ここから始まる物語

自作OS、始めてみることにした。名前は SABOS。
ネットワーク接続ができて、GUIアプリが動くところまでいけたら最高だけど、まあ習作なので楽しいことが一番大事。

## 基本方針

x86_64 / Rust / UEFI で行くことにした。

- **x86_64**: QEMUでのデバッグが楽だし、資料が豊富
- **Rust**: せっかくなのでメモリ安全な言語で。no_std でベアメタルできるのが良い
- **UEFI**: 最初から64bitで動けるし、Legacy BIOS みたいなモード遷移の苦行をしなくていい。画面描画用のフレームバッファ (GOP) も最初から使えるので GUI 目標と相性が良い

そもそも UEFI って何？ってところから調べた。PC の電源入れてから OS が起動するまでの間に動くファームウェアのインターフェース仕様で、昔の BIOS の後継。UEFI のおかげでブートローダ自作の手間がだいぶ省ける。

## 開発環境

devbox で rustup, QEMU, OVMF を入れた。`devbox shell` 一発で全部揃うのは便利。
Rust は nightly が必要（`x86_64-unknown-uefi` ターゲットのため）。

OVMF って何？と思って調べたら、QEMU で UEFI を動かすためのファームウェア実装だった。実機にはマザーボードに UEFI の ROM が焼かれてるけど、QEMU にはそれがない。OVMF がその代役をしてくれる。EDK II（UEFI のリファレンス実装）から派生したオープンソースプロジェクトらしい。

```
実機:   電源ON → マザーボードのUEFI ROM → OS起動
QEMU:   起動   → OVMF (OVMF_CODE.fd)    → OS起動
```

Makefile で QEMU に渡してるファイルが2つあって:

- **`OVMF_CODE.fd`** — ファームウェア本体（読み取り専用）
- **`OVMF_VARS.fd`** — UEFI変数の保存領域（ブート順序の設定とか）

これのおかげで実機なしで `make run` するだけで UEFI アプリの開発ができてる。ありがたい。

## Hello, SABOS!

UEFI アプリとして "Hello, SABOS!" をシリアル出力するところまで到達。`make run` で QEMU が起動して表示される。

```
Hello, SABOS!
```

uefi crate (v0.35) の API は `uefi::system::with_stdout()` でコンソール出力する形。
QEMU は `-drive format=raw,file=fat:rw:esp` でディレクトリをそのまま FAT パーティションとして認識させられるので、イメージファイルを作る手間がない。

## 開発ルール

いくつか決めた。

- **main に直接コミット**。習作なのでブランチ運用は面倒なだけ
- **GitHub Actions でビルドを保証**。一度作ったものが壊れてないことを常にチェックする。これ大事
- **コメントはマシマシ**。後から読んで「なんでこうしたんだっけ」ってならないように。学習用なので丁寧に書く
- **開発日記を書く**。最初は ADR にしようかと思ったけど、もっとカジュアルに日記形式でいいかなと。スクショも貼っていく

## GOP で画面に描画できた！

GOP (Graphics Output Protocol) って何？ってところから。UEFI が提供するグラフィックス描画の仕組みで、フレームバッファ（ピクセルデータを書き込むメモリ領域）にアクセスできる。Legacy BIOS だとテキストモードから始めて VBE を叩いてグラフィックスモードに切り替えて...と面倒だけど、UEFI + GOP なら最初からピクセル単位で画面に描ける。

やったこと:

1. `uefi::boot::get_handle_for_protocol::<GraphicsOutput>()` で GOP プロトコルを取得
2. `current_mode_info().resolution()` で画面サイズ取得 → 1280x800 だった
3. `BltOp::VideoFill` で画面全体を青で塗りつぶし
4. その上に白い矩形を中央に描画

Blt は Block Transfer の略で、GPU のハードウェア機能で高速に塗りつぶせるらしい。

ハマったポイント: QEMU に `-nodefaults -display none` だけだと GPU デバイスが存在しないので GOP が見つからなくて panic した。`-vga std` を追加して仮想 VGA アダプタを載せる必要があった。

![GOP で青背景 + 白矩形を描画](images/2026-02-01-gop.png)

シリアル出力:
```
Hello, SABOS!
GOP: 1280x800, format: Bgr
Screen painted!
```

QEMUのスクショは、QEMU monitor の `screendump` コマンドで PPM ファイルとして保存して、ImageMagick で PNG に変換した。

## 次にやりたいこと

- メモリマップの取得と Exit Boot Services → カーネルとして自立する
- フレームバッファに文字を描画（フォントレンダリング）
