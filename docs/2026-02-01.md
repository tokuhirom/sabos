# 2026-02-01: Day 1 — ここから始まる物語

自作OS、始めてみることにした。名前は SABOS。
ネットワーク接続ができて、GUIアプリが動くところまでいけたら最高だけど、まあ習作なので楽しいことが一番大事。

## 基本方針

x86_64 / Rust / UEFI で行くことにした。

- **x86_64**: QEMUでのデバッグが楽だし、資料が豊富
- **Rust**: せっかくなのでメモリ安全な言語で。no_std でベアメタルできるのが良い
- **UEFI**: 最初から64bitで動けるし、Legacy BIOS みたいなモード遷移の苦行をしなくていい。画面描画用のフレームバッファ (GOP) も最初から使えるので GUI 目標と相性が良い

そもそも UEFI って何？ってところから調べた。PC の電源入れてから OS が起動するまでの間に動くファームウェアのインターフェース仕様で、昔の BIOS の後継。UEFI のおかげでブートローダ自作の手間がだいぶ省ける。

## 開発環境

devbox で rustup, QEMU, OVMF を入れた。`devbox shell` 一発で全部揃うのは便利。
Rust は nightly が必要（`x86_64-unknown-uefi` ターゲットのため）。

OVMF って何？と思って調べたら、QEMU で UEFI を動かすためのファームウェア実装だった。実機にはマザーボードに UEFI の ROM が焼かれてるけど、QEMU にはそれがない。OVMF がその代役をしてくれる。EDK II（UEFI のリファレンス実装）から派生したオープンソースプロジェクトらしい。

```
実機:   電源ON → マザーボードのUEFI ROM → OS起動
QEMU:   起動   → OVMF (OVMF_CODE.fd)    → OS起動
```

Makefile で QEMU に渡してるファイルが2つあって:

- **`OVMF_CODE.fd`** — ファームウェア本体（読み取り専用）
- **`OVMF_VARS.fd`** — UEFI変数の保存領域（ブート順序の設定とか）

これのおかげで実機なしで `make run` するだけで UEFI アプリの開発ができてる。ありがたい。

## Hello, SABOS!

UEFI アプリとして "Hello, SABOS!" をシリアル出力するところまで到達。`make run` で QEMU が起動して表示される。

```
Hello, SABOS!
```

uefi crate (v0.35) の API は `uefi::system::with_stdout()` でコンソール出力する形。
QEMU は `-drive format=raw,file=fat:rw:esp` でディレクトリをそのまま FAT パーティションとして認識させられるので、イメージファイルを作る手間がない。

## 開発ルール

いくつか決めた。

- **main に直接コミット**。習作なのでブランチ運用は面倒なだけ
- **GitHub Actions でビルドを保証**。一度作ったものが壊れてないことを常にチェックする。これ大事
- **コメントはマシマシ**。後から読んで「なんでこうしたんだっけ」ってならないように。学習用なので丁寧に書く
- **開発日記を書く**。最初は ADR にしようかと思ったけど、もっとカジュアルに日記形式でいいかなと。スクショも貼っていく

## GOP で画面に描画できた！

GOP (Graphics Output Protocol) って何？ってところから。UEFI が提供するグラフィックス描画の仕組みで、フレームバッファ（ピクセルデータを書き込むメモリ領域）にアクセスできる。Legacy BIOS だとテキストモードから始めて VBE を叩いてグラフィックスモードに切り替えて...と面倒だけど、UEFI + GOP なら最初からピクセル単位で画面に描ける。

やったこと:

1. `uefi::boot::get_handle_for_protocol::<GraphicsOutput>()` で GOP プロトコルを取得
2. `current_mode_info().resolution()` で画面サイズ取得 → 1280x800 だった
3. `BltOp::VideoFill` で画面全体を青で塗りつぶし
4. その上に白い矩形を中央に描画

Blt は Block Transfer の略で、GPU のハードウェア機能で高速に塗りつぶせるらしい。

ハマったポイント: QEMU に `-nodefaults -display none` だけだと GPU デバイスが存在しないので GOP が見つからなくて panic した。`-vga std` を追加して仮想 VGA アダプタを載せる必要があった。

![GOP で青背景 + 白矩形を描画](images/2026-02-01-gop.png)

シリアル出力:
```
Hello, SABOS!
GOP: 1280x800, format: Bgr
Screen painted!
```

QEMUのスクショは、QEMU monitor の `screendump` コマンドで PPM ファイルとして保存して、ImageMagick で PNG に変換した。

## フレームバッファにテキスト描画

矩形が描けたら次は文字が出したくなる。Blt で 1 ピクセルずつ描くのは非効率なので、GOP のフレームバッファに直接ピクセルを書き込む方式にした。

`font8x8` crate を使った。8x8 ピクセルのビットマップフォントで、各文字が 8 バイトのビットパターンで表現されてる。ビットが立ってたら前景色、立ってなかったら背景色を書く。シンプル。

ハマったポイント: `font8x8` はデフォルトで `std` feature が有効になっていて、no_std 環境だと panic_handler が重複してコンパイルエラーになった。`default-features = false` で解決。no_std crate を使うときは常にデフォルトフィーチャーを確認しないとダメだな。

`FramebufferWriter` 構造体を作って `core::fmt::Write` を実装したので、`write!()` マクロが使える。色も変えられるようにした。

もう一つ注意点として、ピクセルフォーマットが RGB と BGR で byte 順が違う。QEMU + OVMF は BGR だった。これも FramebufferWriter 内で吸収してる。

あと、フレームバッファへの書き込みは `write_volatile` を使わないとコンパイラの最適化で消される可能性がある。メモリマップドI/Oの基本。

![フレームバッファにテキスト描画](images/2026-02-01-text.png)

## Exit Boot Services — UEFI アプリからカーネルへ

ここがこの日のハイライト。

UEFI には Boot Services と Runtime Services がある。Boot Services はメモリ確保、プロトコル（GOP とか）へのアクセス、コンソール出力などを提供してくれるけど、OS が「もう自分でやるから」と言うまでの話。`exit_boot_services()` を呼ぶと Boot Services は終了して、全メモリ・全ハードウェアの管理がカーネルに移る。

Exit 前にやっておくべきこと:

1. **フレームバッファ情報を保存** — GOP プロトコルは Exit 後に使えなくなるけど、フレームバッファの物理アドレス自体はメモリ上に残る。アドレス・サイズ・解像度・ピクセルフォーマットを `FramebufferInfo` に控えておく
2. **メモリマップを取得** — どの物理アドレス範囲がどういう種類のメモリかの一覧。CONVENTIONAL が OS が自由に使える領域

uefi crate の `exit_boot_services()` は内部で自動的にメモリマップを取得して Exit を呼んでくれる。メモリマップのキーが変わっていたら自動リトライもしてくれて賢い。

ハマったポイント: Exit 前に GOP の `ScopedProtocol` を `drop(gop)` しておかないとダメ。ScopedProtocol は RAII ラッパーで、drop 時に `close_protocol` を呼ぶ。プロトコルへの参照が残った状態で Exit すると未定義動作になる。

あと、UEFI の stdout に大量に書き込むと途中で panic することがわかった。メモリマップ全エントリの出力は重すぎたみたい。サマリーだけ出す形にした。

結果: Exit Boot Services 後にフレームバッファへの描画が成功。83 MiB のメモリが使える。

![カーネルとして動作中](images/2026-02-01-kernel.png)

```
=== SABOS ===

Framebuffer: 1280x800
Pixel format: Bgr

Boot services exited successfully!
Kernel is now in control.

Memory map:
  Usable memory: 83 MiB (21446 pages)
  Total entries: 100
```

## 次にやりたいこと

- ページングのセットアップ
- 割り込みハンドラ (GDT/IDT)
- スクロール機能
